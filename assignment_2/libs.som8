/?-------------------------------------------------------------------------?
 ?---									---?
 ?---		defaultInitKb.som8					---?
 ?---									---?
 ?---	    This file defines the Scienceomatic 8b files to be used to	---?
 ?---	initialize the Struct Proc knowledge base.			---?
 ?---									---?
 ?---	----	----	----	----	----	----	----	----	---?
 ?---									---?
 ?---	Version 8b		2013 September 27	Joseph Phillips	---?
 ?---									---?
 ?-------------------------------------------------------------------------?/

thisSE->parseFile("knowledgebases/standard/operational.som8");

/?-------------------------------------------------------------------------?
 ?---									---?
 ?---		operational.som8					---?
 ?---									---?
 ?---	    This file defines basic knowledge that StructProc knowledge	---?
 ?---	base needs to operate.						---?
 ?---									---?
 ?---	----	----	----	----	----	----	----	----	---?
 ?---									---?
 ?---	Version 8a		2011 April 03		Joseph Phillips	---?
 ?---									---?
 ?---	Version 8b		2013 February 10	Joseph Phillips	---?
 ?---									---?
 ?-------------------------------------------------------------------------?/


//  PURPOSE:  To represent the root identity of the knowledge base.  Everything
//	else is either a subclass or instance of this.
Idea
{*
isA->assertZ(Idea);
instanceOf->assertZ(Idea);

ideasIsImmutableA->subAssertZ(false);
ideasIsSingleDistinctA->subAssertZ(false);
isIdeaANonspecifiedSetMemberA->subAssertZ(false);
mayBeDestroyedA->subAssert(false);
*};



/?	Subontology Attribute:
?
?	PURPOSE:  To represent the class of identities that map subjects to
?		their various properties.
?	NOTE:  For the most part, this subontology mirrors the ontology of the
?		subjects being described.  One exception to this is subclass
?		'OntologyStructureA' because there is no subclass
?		'OntologyStructure'.
?/
Attribute
{*
isA->assertZ(Idea);
*};



/?	Subontology ProgramObject
?
?	PURPOSE:  To represent the class of identities used in the internal
?		workings of the StructProc program.
?/
ProgramObject
{*
isA->assertZ(Idea);
*};

ProgramObjectA
{*
isA->assertZ(Attribute);
*};


instancesOfIdeaShouldHaveAttrA
{*
instanceOf->assertZ(ProgramObjectA);
*};


ideasMethodA
{*
instanceOf->assertZ(ProgramObjectA);
*};


ideasImplicitConstructorA
{*
instanceOf->assertZ(ProgramObjectA);
*};


ideasImmutableSingleDistinctA
{*
instanceOf->assertZ(ProgramObjectA);
*};

ideasExprA
{*
instanceOf->assert(ProgramObjectA);
*};

ideasAssertionA
{*
instanceOf->assert(ProgramObjectA);
*};

ideasIsImmutableA
{*
instanceOf->assert(ProgramObjectA);
*};

ideasIsSingleDistinctA
{*
instanceOf->assert(ProgramObjectA);
*};

isIdeaANonspecifiedSetMemberA
{*
instanceOf->assert(ProgramObjectA);
*};

ideasIsClassFullA
{*
instanceOf->assert(ProgramObjectA);
*};

mayBeDestroyedA
{*
instanceOf->assertZ(ProgramObjectA);
*};

attrsIsSingleValuedA
{*
instanceOf->assertZ(ProgramObjectA);
*};


attrsDomainA
{*
instanceOf->assertZ(ProgramObjectAttrA);
*};

attrsRangeA
{*
instanceOf->assertZ(ProgramObjectAttrA);
*};


CulturalConventionA
{*
isA->assertZ(Attribute);
*};


/?	Subontology NoAnswer:
?
?	PURPOSE:  To represent the class of "answers" to give for unanswerable
?		queries.
?/
NoAnswer
{*
isA->assertZ(Idea);
*};


//  PURPOSE:  To represent the answer to give when no more answers are computed.
final
null
{*
instanceOf->assertZ(NoAnswer);
*};


//  PURPOSE:  To represent the answer to give for queries that do not make
//	sense.
final
nonsense
{*
instanceOf->assertZ(NoAnswer);
*};



/?	Subontology Unaffliated:
?
?	PURPOSE:  To represent the class of ideas that have yet to be
?		incorporated elsewhere in the ontology proper.
?/
final
Unaffliated
{*
isA->assertZ(Idea);
*};


/?	Subontology Value:
?
?	PURPOSE:  To represent the class of answers to empirical questions.
?/
Value
{*
  isA->assertZ(Idea);
*};

ValueA
{*
  isA->assertZ(Attribute);
*};


//  PURPOSE:  To represent raw values themselves, before any annotation has
//	been given them.
UnannotatedValue
{*
isA->assertZ(Value);
*};


Boolean			{* isA->assertZ(UnannotatedValue); *};
final true		{* instanceOf->assertZ(Boolean); *};
final false		{* instanceOf->assertZ(Boolean); *};
final
noMore
Boolean			{* *};


Number
{*
isA->assertZ(UnannotatedValue);
*};


Rational
{*
isA->assertZ(Number);
*};


FloatingPt
{*
isA->assertZ(Number);
*};


String
{*
isA->assertZ(UnannotatedValue);
*};


//  PURPOSE:  To be a default type distinct from 'String', 'Rational',
//	'FloatingPt', 'VectorList', 'Bag' etc.  Not meant to actually make an
//	instance of.
final noMore Concept
{*
isA->assertZ(UnannotatedValue);
*};


//  PURPOSE:  To represent values that have been annotated by subjects,
//	dimensions/units, etc.
AnnotatedValue
{*
  isA->assert(Value);
*};

AnnotatedValueA
{*
  isA->assert(ValueA);
*};


CulturalConvention
{*
isA->assertZ(Idea);
*};


thisSE->parseFile("ProgramObject.som8");

/?-------------------------------------------------------------------------?
 ?---									---?
 ?---		ProgramObject.som8					---?
 ?---									---?
 ?---	    This file defines knowledge about program objects that the	---?
 ?---	StructProc knowledge base needs to operate.			---?
 ?---									---?
 ?---	----	----	----	----	----	----	----	----	---?
 ?---									---?
 ?---	Version 8b		2013 September 29	Joseph Phillips	---?
 ?---									---?
 ?-------------------------------------------------------------------------?/


/?---?			OntologyStructure
 ?---?
 ?---?	    This section defines knowledge about the attributes used to
 ?---?	structure the StructProc knowledge base.  This knowledge is
 ?---?	needed for it to operate.
 ?---?/


//  PURPOSE:  To represent how knowledge can be asserted.
HowAssert			{* isA->assertZ(ProgramObject); *};
  final locallyAsserted		{* instanceOf->assertZ(HowAssert); *};
  final inheritedAsserted	{* instanceOf->assertZ(HowAssert); *};
final
noMore
HowAssert			{* *};


OntologyStructureA
{*
  isA->assertZ(ProgramObjectA);
*};

isA
{*
  instanceOf->assertZ(OntologyStructureA);
*};

instanceOf
{*
  instanceOf->assertZ(OntologyStructureA);
*};

hasSubclass
{*
  instanceOf->assertZ(OntologyStructureA);
*};

hasInstance
{*
  instanceOf->assertZ(OntologyStructureA);
*};



/?---?			ProgrammingElement
 ?---?/

ProgrammingElement
{*
  isA->assertZ(ProgramObject);
*};

ProgrammingElementA
{*
  isA->assertZ(ProgramObjectA);
*};


/?---?				Constructor
 ?---?
 ?---?	    This section defines knowledge about constructors that the
 ?---?	StructProc knowledge base needs to operate.
 ?---?/

ImplicitConstructor
{*
  isA->assertZ(ProgrammingElement);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		{*
		    implicitConstructorsAttrUTypeListA->
		    	assert([[implicitConstructorsAttrUTypeListA,Idea],
				[implicitConstructorsDefaultListA, Idea]
		       	       ]
		      	      );
		 *}
	);

*};


ConstructorA
{*
  isA->assertZ(ProgramObjectA);
*};


//  PURPOSE:  To map from implicit constructors to a list of pairs of form
//	[ [attr_1, class_1], [attr_2, class_2], . . . [attr_n, class_n] ].
//	When a constructor call of from ^SomeClass[*val_1,val_2,...val_n*]
//	is encountered, then for each i in [1..n] the system:
//	(1) makes sure val_i is in class_i
//	(2) @this->assertA(attr_i,val_i)
//	It does assertA() so that values specified in the constructor call can
//	take precedence over the default values of
//	'implicitConstructorsDefaultListA'
implicitConstructorsAttrUTypeListA
{*
  instanceOf->assertZ(ConstructorA);
*};


//  PURPOSE:  To map from implicit constructors to a list of pairs of form
//	[ [attr_1, val_1], [attr_2, val_2], . . . [attr_n, val_m] ].
//	When a constructor call of from ^SomeClass[*...*]
//	is encountered, then for each i in [1..m] the system does
//	@this->assertA(attr_i,val_i).  Assigning these default values is done
//	before the assertion of 'implicitConstructorsAttrUTypeListA' is done,
//	so that these default values will have lesser precedence than those
//	ones given in the constructor call.
implicitConstructorsDefaultListA
{*
  instanceOf->assertZ(ConstructorA); 
*};


implicitConstructorsMultiValuedAttrA
{*
  instanceOf->assertZ(ConstructorA); 
*};

implicitConstructorsMultiValuedTypeA
{*
  instanceOf->assertZ(ConstructorA); 
*};


/?---?				DataStructure
 ?---?
 ?---?	    This file defines knowledge about data structures that the
 ?---?	StructProc knowledge base needs to operate.
 ?---?
 ?---?	NOTE:  This class is completely distinct from 'Value'!
 ?---?	       The metaphysical assumption being that NATURE thinks
 ?---?	       in terms of AnnotatedValue while PROGRAMMERS think in
 ?---?	       terms of datastructures!
 ?---?/

//  PURPOSE:  To represent the class of data-structures.
//	NOTE:  This class is completely distinct from 'Value'!
//	       The metaphysical assumption being that NATURE thinks in terms
//	       of AnnotatedValue while PROGRAMMERS think in terms of
//	       datastructures!
DataStructure
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};


//  PURPOSE:  To represent the set of attributes over DataStructure instances.
DataStructureStructureA
{*
  isA->assertZ(ProgramObjectA);
*};

//  PURPOSE:  To map from a datastructure to its size (used by dataStruct_size())
datastructuresSizeA
{*
  instanceOf->assertZ(DataStructureStructureA);
*};

bagsCountSumA
{*
  instanceOf->assertZ(DataStructureStructureA);
*};


//  PURPOSE:  To map from tree-implemented DataStructure instances to the
//	NodeStructure that is currently at their root position.
treesRootA
{*
  instanceOf->assertZ(DataStructureStructureA);
*};


//  PURPOSE:  To map from DataStructure instances to the 'nil' NodeStructure
//	they use for house-keeping purposes.
datastructuresNilA
{*
  instanceOf->assertZ(DataStructureStructureA);
*};


//  PURPOSE:  To map from a datastructure to the actual internal list of data
//	stored by that datastructure, as how 'VectorList' keep track of what
//	they hold.
datastructuresDataA
{*
  instanceOf->assertZ(DataStructureStructureA);
*};


//  PURPOSE:  To represent the class of lists (both node and vector).
List
{*
  isA->assertZ(DataStructure);
*};


//  PURPOSE:  To represent the class of vector-implemented lists.
VectorList
{*
  isA->assertZ(List);
*};


//  PURPOSE:  To represent the class of vector-implemented lists.
NodeList
{*
  isA->assertZ(List);
*};


//  PURPOSE:  To represent the class of bag datastructures.
Bag
{*
  isA->assertZ(DataStructure);
*};


//  PURPOSE:  To represent the class of map datastructures.
Map
{*
  isA->assertZ(DataStructure);
*};



/?---?			VariableStaticContext
 ?---?
 ?---?	    This file defines knowledge about the variable static
 ?---?	contexts that the StructProc knowledge base needs to operate.
 ?---?/


VariableStaticContext
{*
  isA->assertZ(ProgramObject);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [
		   ],
		   [[variableStaticContextsNumVarDeclsA,0]
		   ]
		*]
	);

*};

VariableStaticContextA
{*
  isA->assertZ(ProgramObjectA);
*};

variableStaticContextsVarDeclA
{*
  instanceOf->assertZ(VariableStaticContextA);
*};

variableStaticContextsNumVarDeclsA
{*
  instanceOf->assertZ(VariableStaticContextA);
*};


/?---?				ProgrammingExpr
 ?---?
 ?---?	    This file defines knowledge about programming expressions
 ?---?	that the StructProc knowledge base needs to operate.
 ?---?/

ProgrammingExpr
{*
  isA->assertZ(ProgrammingElement);
*};

ProgrammingExprA
{*
  isA->assertZ(ProgrammingElementA);
*};



final
VariableUsage
{*
  isA->assertZ(ProgrammingExpr);
*};

VariableUsageA
{*
  isA->assertZ(ProgrammingExprA);
*};

variableUsagesDoesRepresentSelfA
{*
  instanceOf->assertZ(VariableUsageA);
*};



final
MethodCallSequence
{*
  isA->assertZ(ProgrammingExpr);
*};

MethodCallSequenceA
{*
  isA->assertZ(ProgrammingExprA);
*};

methodCallSequencesObjectA
{*
  instanceOf->assertZ(MethodCallSequenceA);
*};

methodCallSequencesFncCallListA
{*
  instanceOf->assertZ(MethodCallSequenceA);
*};



final
FunctionCall
{*
  isA->assertZ(ProgrammingExpr);
*};

FunctionCallA
{*
  isA->assertZ(ProgrammingExprA);
*};

functionCallsFamilyA
{*
  instanceOf->assertZ(FunctionCallA);
*};

functionCallsArgListA
{*
  instanceOf->assertZ(FunctionCallA);
*};



/?---?				Assertion
 ?---?
 ?---?	    This file defines knowledge about assertions that the
 ?---?	StructProc knowledge base needs to operate.
 ?---?/

Assertion
{*
  isA->assertZ(ProgramObject);

  ideasImplicitConstructorA->subAssert
	( ^ImplicitConstructor
	  [*
	    [ [assertionsTypedEntityListA, MultiVarDecl],
	      [assertionsConditionListA,   Idea],
	      [assertionsExpressionListA,  Idea]
	    ]
	  *]
	);
*};


//  PURPOSE:  To be the class of Iterator related attributes
AssertionA
{*
  isA->assertZ(ProgramObjectA);
*};

assertionsTypedEntityListA
{*
  instanceOf->assertZ(AssertionA);
*};

assertionsConditionListA
{*
  instanceOf->assertZ(AssertionA);
*};

assertionsExpressionListA
{*
  instanceOf->assertZ(AssertionA);
*};

Equation
{*
  isA->assertZ(Assertion);
*};


Inequality
{*
  isA->assertZ(Assertion);
*};


DecisionTree
{*
  isA->assertZ(Assertion);
*};


Fnc
{*
  isA->assertZ(Assertion);

/????
  ideasDescExprA->subAssert
    (^ImplicitConstructor
	[*
	  [ [descExprsAttrA, Idea],
	    [descExprsExprA, Idea]
	  ]
	*]
    );
????/
  ideasImplicitConstructorA->subAssert
    (^ImplicitConstructor
	[*
	  [[fncsFamilyA,  Idea],
	   [fncsReturnSA, Idea],
	   [fncsParamLA,  MultiVarDecl],
	   [fncsInstrA,	  Idea]
	  ]
	*]
    );
  ideasExprA->subAssertZ(fncsParamLLenACompFnc);
*};


AnonFnc
{*
  isA->assertZ(Fnc);
*};

FncA
{*
  isA->assertZ(AssertionA);
*};

fncsFamilyA
{*
  instanceOf->assertZ(FncA);
*};

fncsParamLLenA
{*
  instanceOf->assertZ(FncA);
*};

fncsInstrA
{*
  instanceOf->assertZ(FncA);
*};

fncsParamLLenACompFnc
{*
  instanceOf->assertZ(FncA);
*};


FncA
{*
  isA->assertZ(ProgramObjectA);
*};


//  PURPOSE: To map from ^Fnc to their return types.
fncsReturnSA
{*
  instanceOf->assertZ(FncA);
*};


//  PURPOSE: To map from ^Fnc to their list of parameters.
fncsParamLA
{*
  instanceOf->assertZ(FncA);
*};


//  PURPOSE: To map from ^Fnc to their body to compute.
fncsBodyA
{*
  instanceOf->assertZ(FncA);
*};


/?---?
 ?---?/

ProgramObjectAttrA
{*
  isA->assertZ(ProgramObjectA);
*};


VariableA
{*
  isA->assertZ(ProgramObjectA);
*};


variablesDomainA
{*
  instanceOf->assertZ(VariableA);
*};


variablesValueA
{*
  instanceOf->assertZ(VariableA);
*};


/?---?				PredefinedCommand
 ?---?
 ?---?	    This file defines knowledge about predefined commands that
 ?---?	the StructProc knowledge base needs to operate.
 ?---?/

PredefinedCommand
{*
  isA->assertZ(ProgrammingExpr);
*};

PredefinedCommandA
{*
  isA->assertZ(ProgrammingElementA);
*};

//  PURPOSE:  To map from programming elements to either 'true', if that
//	programming element was created internally, or 'false' (or 'null')
//	otherwise.
isProgrammingElementInternallyCreatedA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from a command instance to an alternative body of code
//	that it is supposed to execute when invoked (else clause of If
//	commands, or catch clause of Try commands)
commandsBodyA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from a command instance to the code to execute before the
//	main body (for the initialization step of For commands)
commandsPrebodyA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from a command instance to the code to execute after the
//	main body (for the increment step of For commands)
commandsPostbodyA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from a command instance to an alternative body of code
//	that it is supposed to execute when invoked (else clause of If
//	commands, or catch clause of Try commands)
commandsAlternativeBodyA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from a command instance to the test expression it should
//	invoke in conditions and loops (for all commands except Do, which is
//	the only non-loop and non-conditional)
commandsTestA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from a Catch instance to the subclass of Exception that
//	that Catch statement matches.
catchsExceptionClassA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from Match instances to their comparison operator.
matchesOperatorA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from Match instances to the operand with which the outer
//	Match instance's test value should be compared.
matchesOperandA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from Try instances to the declaration of the variable that
//	catches the Exception instance.
trysVarDeclA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from Try instances to the usage of the variable that
//	catches the Exception instance.
trysVarUsageA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};

//  PURPOSE:  To map from Exception instances to a single value that describes
//	them.
exceptionsValueA
{*
  instanceOf->assertZ(PredefinedCommandA);
*};



//  PURPOSE:  To represent the class of variable declarations.
VarDecl
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [*
	    [ [varDeclsVarUsageA,	Idea],
	      [varDeclsDomainA,		Idea],
	      [commandsBodyA,		Idea]
	    ],
	    [ [varDeclsDomainA,	Idea]
	    ]
	  *]
	);

*};

VarDeclA
{*
  isA->assertZ(PredefinedCommandA);
*};


varDeclsDomainA
{*
  instanceOf->assertZ(VarDeclA);
*};


varDeclsVarUsageA
{*
  instanceOf->assertZ(VarDeclA);
*};


MultiVarDecl
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->subAssert
     (^ImplicitConstructor
	{* implicitConstructorsMultiValuedAttrA->
				assert(multiVarDeclsVarDeclareA);
		   implicitConstructorsMultiValuedTypeA->
				assert(VarDecl);
	 *}
     );
*};

MultiVarDeclA
{*
  isA->assertZ(ProgramObjectA);
*};

multiVarDeclsVarDeclareA
{*
  instanceOf->assertZ(MultiVarDeclA);
*};


//  PURPOSE:  To represent the C-style break loop command
final
Return
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [[commandsBodyA,	Idea]
		  ]
		*]
	);
*};


//  PURPOSE:  To represent the C-style break loop command
final
Break
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->subAssert(^ImplicitConstructor[* [] *]);
*};


//  PURPOSE:  To represent the C-style continue loop command
final
Continue
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->subAssert(^ImplicitConstructor[* [] *]);
*};

//  PURPOSE:  To represent the C++-style exception throwing command
final
Throw
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->
	subAssert
	( ^ImplicitConstructor
	  [* [ [commandsBodyA,	Idea]
	     ]
	  *]
	);
*};



PredefCmdConditional
{*
  isA->assertZ(PredefinedCommand);
*};

PredefCmdConditionalA
{*
  isA->assertZ(PredefinedCommandA);
*};


final
If
{*
  isA->assertZ(PredefCmdConditional);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
 		  [[commandsTestA,		Idea],
		   [commandsBodyA,		Idea],
		   [commandsAlternativeBodyA,	Idea]
		  ]
		*]
	);
*};


Match
{*
  isA->assertZ(PredefCmdConditional);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [[matchesOperatorA,	Idea],
		   [matchesOperandA,	Idea],
		   [commandsBodyA,	Idea]
		  ]
		*]
	);
*};


MultiMatch
{*
  isA->assertZ(PredefCmdConditional);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		{* implicitConstructorsMultiValuedAttrA->
				assert(multiMatchesMatchA);
		   implicitConstructorsMultiValuedTypeA->
				assert(Match);
		 *}
	);
*};

multiMatchesMatchA
{*
  instanceOf->assertZ(PredefCmdConditionalA);
*};


Test
{*
  isA->assertZ(PredefCmdConditional);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [[commandsTestA,		Idea],
		   [commandsBodyA,		MultiMatch]
		  ]
		*]
	);
*};


PredefCmdLoop
{*
  isA->assertZ(PredefinedCommand);
*};


//  PURPOSE:  To represent blocks of code to be done sequentially.
final
Do
{*
  isA->assertZ(PredefinedCommand);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [[commandsBodyA,	Idea]
		  ]
		*]
	);
*};


//  PURPOSE:  To represent a block of code that may throw an exception, and
//	some of the code that might handle the exception.
final
Try
{*
  isA->assertZ(PredefCmdLoop);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [ [commandsBodyA,		Do],
		    [commandsAlternativeBodyA,	List]
		  ]
		*]
	);
*};

//  PURPOSE:  To represent a Catch clause inside of a Try statement.
final
Catch
{*
  isA->assertZ(ProgrammingElement);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [ [catchsExceptionClassA,	Idea],
		    [commandsBodyA,		Do]
		  ]
		*]
	);
*};


//  PURPOSE:  To represent initialization/test/body/increment for-loops.
final
For
{*
  isA->assertZ(PredefCmdLoop);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [ [commandsPrebodyA,	Idea],
		    [commandsTestA,	Idea],
		    [commandsBodyA,	Idea],
		    [commandsPostbodyA,	Idea]
		  ]
		*]
	);
*};


//  PURPOSE:  To represent test/body while-loops.
final
While
{*
  isA->assertZ(PredefCmdLoop);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [[commandsTestA,	Idea],
		   [commandsBodyA,	Idea]
		  ]
		*]
	);
*};

final
Repeat
{*
  isA->assertZ(PredefCmdLoop);

  ideasImplicitConstructorA->
	subAssert
	(^ImplicitConstructor
		[*
		  [[commandsBodyA,	Idea],
		   [commandsTestA,	Idea]
		  ]
		*]
	);
*};


/?---?				FncsFamily
 ?---?
 ?---?	    This file defines knowledge about function families that
 ?---?	the StructProc knowledge base needs to operate.
 ?---?/

FncsFamily
{*
  isA->assertZ(ProgramObject);
*};

NatLangRelatedFncsFamily
{*
  isA->assertZ(FncsFamily);
*};

InterTermGrammarInfoFncsFamily
{*
  isA->assertZ(NatLangRelatedFncsFamily);
*};

//  PURPOSE:  To represent the class of predefined function families.
PredefinedFncsFamily
{*
  isA->assertZ(FncsFamily);
*};


//  PURPOSE:  To represent the class of predefined knowledge asserting function
//	families.
PredefinedKnowledgeAssertingFncsFamily
{*
  isA->assertZ(PredefinedFncsFamily);
*};


//  PURPOSE:  To represent the function family for asserting a property and
//	erasing others of the same attribute 
final
assert
{*
  isA->assertZ(PredefinedKnowledgeAssertingFncsFamily);
*};


//  PURPOSE:  To represent the function family for asserting the first property
//	of an attribute.
final
assertA
{*
  isA->assertZ(PredefinedKnowledgeAssertingFncsFamily);
*};


//  PURPOSE:  To represent the function family for asserting the last property
//	of an attribute
final
assertZ
{*
  isA->assertZ(PredefinedKnowledgeAssertingFncsFamily);
*};


//  PURPOSE:  To represent the function family for asserting an inherited
//	property and erasing others of the same attribute.
final
subAssert
{*
  isA->assertZ(PredefinedKnowledgeAssertingFncsFamily);
*};


//  PURPOSE:  To represent the function family for asserting the first
//	inherited property of an attribute.
final
subAssertA
{*
  isA->assertZ(PredefinedKnowledgeAssertingFncsFamily);
*};


//  PURPOSE:  To represent the function family for asserting the last inherited
//	property of an attribute.
final
subAssertZ
{*
  isA->assertZ(PredefinedKnowledgeAssertingFncsFamily);
*};


PredefinedKnowledgeQueryingFncsFamily
{*
  isA->assertZ(PredefinedFncsFamily);
*};

get
{*
  instanceOf->assertZ(PredefinedKnowledgeQueryingFncsFamily);
*};

localGet
{*
  instanceOf->assertZ(PredefinedKnowledgeQueryingFncsFamily);
*};

//  PURPOSE:  To represent the class of predefined I/O function families.
PredefinedIOFncsFamily
{*
  isA->assertZ(PredefinedFncsFamily);
*};


//  PURPOSE:  To represent the function family to read from a file.  '@this'
//	should be the file.
read
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the function family to print the names of identities
//  	to a file.  '@this' should be the file.
print
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the function family to print the names of identities
//	to a file, followed by a newline.  '@this' should be the file.
printSc
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the function family to print the names of identities
//  	to a file.  '@this' should be the file.
printLn
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the function family to print the names of identities
//	to a file, followed by a newline.  '@this' should be the file.
printScLn
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the function family to print the knowledge of
//	names of identities to a file, followed by a newline.  '@this' should be
//	the file.
describe
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the function family to print the knowledge of
//	names of identities to a file, followed by a newline.  '@this' should be
//	the file.
describeLn
{*
  instanceOf->assertZ(PredefinedIOFncsFamily);
*};


//  PURPOSE:  To represent the class of predefined function families for
//	subject 'thisSE'.
PredefinedThisSEFncsFamily
{*
  isA->assertZ(PredefinedFncsFamily);
*};

//  PURPOSE:  To represent the function family of 'thisSE' that takes a
//	filename, attempts to open that file, and (if successful) returns an
//	'InputStream' instance.
final
openIn
{*
  instanceOf->assertZ(PredefinedThisSEFncsFamily);
*};


//  PURPOSE:  To represent the function family of 'thisSE' that takes a
//	filename, attempts to open that file, and (if successful) returns an
//	'OutputStream' instance.
final
openOut
{*
  instanceOf->assertZ(PredefinedThisSEFncsFamily);
*};


//  PURPOSE:  To represent the function family of 'thisSE' that takes no
//	parameters and turns tracing on (TRace ON).  The function then returns
//	'thisSE'.
final
trOn
{*
  instanceOf->assertZ(PredefinedThisSEFncsFamily);
*};


//  PURPOSE:  To represent the function family of 'thisSE' that takes no
//	parameters and turns tracing off (TRace OFF).  The function then
//	returns 'thisSE'.
final
trOff
{*
  instanceOf->assertZ(PredefinedThisSEFncsFamily);
*};


//  PURPOSE:  To represent the function family of 'thisSE' that takes a
//	filename and attempts to parse that file and incorporate that knowledge
//	into the knowledge base.  The function returns the filename.
final
parseFile
{*
  instanceOf->assertZ(PredefinedThisSEFncsFamily);
*};

final
noMore
PredefinedThisSEFncsFamily		{* *};


//  PURPOSE:  To represent the class of predefined iterator function families.
PredefinedIteratorFncsFamily
{*
  isA->assertZ(PredefinedFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'Iterator' instances
//	that returns 'true' if '@this' is at the end, or 'false' otherwise.
iter_isAtEnd
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'Iterator' instances
//	that returns value at '@this' current position.
iter_value
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'Iterator' instances
//	that advances '@this' to its next position.
iter_advance
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'Iterator' instances
//	that resets '@this' to refer to its first position.
iter_reset
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To be the method over iterators thru node lists that inserts an
//	item just before the current iterator position, and revises the
//	iterator to refer to the newly inserted item.
nListIter_insertA
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To be the method over iterators thru node lists that inserts an
//	item just after the current iterator position, and revises the iterator
//	to refer to the newly inserted item.
nListIter_insertZ
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To be the method over iterators thru node lists that removes the
//	currently referred item and moves the iterator to the item before the
//	removed item (if it exists).
nListIter_removeA
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To be the method over iterators thru node lists that removes the
//	currently referred item and moves the iterator to the item after the
//	removed item (if it exists).
nListIter_removeZ
{*
  isA->assertZ(PredefinedIteratorFncsFamily);
*};


//  PURPOSE:  To represent the class of predefined data structure function
//	families.
PredefinedDataStructFncsFamily
{*
  isA->assertZ(PredefinedFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns 'true' if '@this' is empty or 'false' otherwise
dataStruct_isEmpty
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns the number of items in '@this'.
dataStruct_size
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns the number of distinct items in '@this'.
dataStruct_distinctCount
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns an iterator over '@this'.
dataStruct_iter
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that inserts the 1st arg at the beginning of '@this'.
dataStruct_insertA
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that inserts the 1st arg at the end of '@this'.
dataStruct_insertZ
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that inserts the 1st arg in '@this'.
dataStruct_insert
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that inserts the 1st arg in '@this' only if it is not already in
//	'@this'.
dataStruct_didInsertBecauseNotPresent
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns 'true' if '@this' contains the 1st arg, or 'false'
//	otherwise.
dataStruct_doesHave
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns 'true' if the 1st arg was successfully removed from
//	'@this', or 'false' otherwise.
dataStruct_didRemove
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that removes all items from '@this'.
dataStruct_clear
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that returns another instance that is a copy of '@this'.
dataStruct_copy
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'DataStructure' instances
//	that 
dataStruct_peek
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'List' instances that
//	returns the first thing in the list.
list_firstItem
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'List' instances that
//	returns the second thing in the list.
list_secondItem
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'List' instances that
//  	returns 'this' list, but sorted.
list_sort
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'VectorList' returns 'true'
//	if a position with index given as the first argument exists, in which
//	case the value at that index is overwritten by the value given as the
//	second argument in.  Returns 'false' if the index is not present.
vList_didPut
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'VectorList' instances that
//	returns the value that has been paired with an integer index, where the
//	index is the 1st arg to the function call.  Returns 'null' if the index
//	is not there.
vList_get
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'VectorList' instances that
//	returns the number of times 'dataStruct_insertA()' has been called
//	since the last time 'dataStruct_clear()' has been called.
vList_numInsertA
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};



//  PURPOSE:  To represent the function family over 'Bag' instances that
//	returns the number of times the 1st arg to the fnc call has been
//	inserted in '@this'.
bag_count
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'Map' instances that
//	puts pair <key,value> in '@this' map, where key is the 1st arg to the
//	function call and 'value' is the 2nd.  Returns '@this'.
map_put
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'Map' instances that
//	returns the value that has been paired with a key, where the key is the
//	1st arg to the function call.  Returns 'null' if the key is not there.
map_get
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};


//  PURPOSE:  To represent the function family over 'String' instances that
//  	returns 'true' if 'this' string begins with the given substring, or
//	'false' otherwise.
string_hasPrefix
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};

//  PURPOSE:  To represent the function family over 'String' instances that
//  	returns 'true' if 'this' string ends with the given substring, or
//	'false' otherwise.
string_hasSuffix
{*
  instanceOf->assertZ(PredefinedDataStructFncsFamily);
*};



/?---?				Operator
 ?---?
 ?---?	    This file defines knowledge about operators that the
 ?---?	StructProc knowledge base needs to operate.
 ?---?/

Operator
{*
  isA->assertZ(ProgrammingElement);
*};

OperatorA
{*
  isA->assertZ(ProgramObjectA);
*};


doesMultiplicativeOpMultiplyA
{*
  instanceOf->assertZ(OperatorA);
*};


doesAdditiveOpAddA
{*
  instanceOf->assertZ(OperatorA);
*};


ExponentLogOp
{*
  isA->assertZ(Operator);
*};

ExponentiatingOp
{*
  isA->assertZ(ExponentLogOp);
*};

`**`
{*
  instanceOf->assertZ(ExponentiatingOp);
*};

TrigonometricOp
{*
  isA->assertZ(Operator);
*};

AngleTrigonometricOp
{*
  isA->assertZ(TrigonometricOp);
*};

`sin`
{*
  instanceOf->assertZ(AngleTrigonometricOp);
*};

`cos`
{*
  instanceOf->assertZ(AngleTrigonometricOp);
*};

`tan`
{*
  instanceOf->assertZ(AngleTrigonometricOp);
*};


ArcTrigonometricOp
{*
  isA->assertZ(TrigonometricOp);
*};

`asin`
{*
  instanceOf->assertZ(ArcTrigonometricOp);
*};

`acos`
{*
  instanceOf->assertZ(ArcTrigonometricOp);
*};

`atan`
{*
  instanceOf->assertZ(ArcTrigonometricOp);
*};


AssignmentOp
{*
  isA->assertZ(Operator);
*};


ExistenceOp
{*
  isA->assertZ(Operator);
*};


PropertyOp
{*
  isA->assertZ(Operator);
*};


StringOp
{*
  isA->assertZ(Operator);
*};


NumericOp
{*
  isA->assertZ(Operator);
*};


ExponentiatingOp
{*
  isA->assertZ(NumericOp);
*};


MultiplicativeOp
{*
  isA->assertZ(NumericOp);
*};


DividingOp
{*
  isA->assertZ(NumericOp);
*};


AdditiveOp
{*
  isA->assertZ(NumericOp);
*};


GroupingAdditiveOp
{*
  isA->assertZ(AdditiveOp);
*};


ExtendingAdditiveOp
{*
  isA->assertZ(AdditiveOp);
*};


NondeltaAdditiveOp
{*
  isA->assertZ(AdditiveOp);
*};


DeltaAdditiveOp
{*
  isA->assertZ(AdditiveOp);
*};


PositiveAddOp
{*
  isA->assertZ(AdditiveOp);
*};


NegativeAddOp
{*
  isA->assertZ(AdditiveOp);
*};


BooleanOp
{*
  isA->assertZ(Operator);
*};


LogicOp
{*
  isA->assertZ(BooleanOp);
*};


ComparisonOp
{*
  isA->assertZ(BooleanOp);
*};


EqualityOp
{*
  isA->assertZ(ComparisonOp);
*};


LesserGreaterOp
{*
  isA->assertZ(ComparisonOp);
*};


/?---?				Iterator
 ?---?
 ?---?	    This file defines knowledge about Iterators and Iterator
 ?---?	entries that the StructProc knowledge base needs to operate.
 ?---?/

Iterator
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};

//  PURPOSE:   To represent the class of predefined iterators.
PredefinedIter
{*
  isA->assertZ(Iterator);
*};

//  PURPOSE:  To be the class of Iterator related attributes
IteratorA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertZ(Iterator);
*};

//  PURPOSE:   To represent the class of iterators related to the ontology.
PredefOntologyIter
{*
  isA->assertZ(PredefinedIter);
*};

//  PURPOSE:   To represent the class of iterators iterating over
//	ontological parents (for instances, sets; for sets supersets).
PredefOntolParentIter
{*
  isA->assertZ(PredefOntologyIter);
*};

//  PURPOSE:   To represent the attr mapping from PredefOntolParentIter
//	instances to the list of ideas to visit.
predefOntolParentItersToVisitListA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To represent the attr mapping from PredefOntolParentIter
//	instances to the set of visited ideas.
predefOntolParentItersVisitedSetA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To represent the set of iterators iterating over ontological
//	subsets.
PredefOntolSubsetIter
{*
  isA->assertZ(PredefOntologyIter);
*};

//  PURPOSE:   To represent the class of iterators iterating over ontological
//	 instances.
PredefOntolInstanceIter
{*
  isA->assertZ(PredefinedIter);
*};

//  PURPOSE:   To represent the class of iterators iterating over properties.
PredefPropertyIter
{*
  isA->assertZ(PredefinedIter);
*};


//  PURPOSE:   To represent the attribute that maps from instances of
//	PredefPropertyIter to the iterator of locally stored values. 
predefPropertyItersLocalListIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To represent the attribute that maps from instances of
//	PredefPropertyIter to the iterator sets for inherited values.
predefPropertyItersSetIter
{*
  instanceOf->assertZ(IteratorA);
*};

predefPropertyItersLocalPropertyIterA
{*
  instanceOf->assertZ(IteratorA);
*};

predefPropertyItersToVisitQueueA
{*
  instanceOf->assertZ(IteratorA);
*};

predefPropertyItersHaveVisitedSetA
{*
  instanceOf->assertZ(IteratorA);
*};

predefPropertyItersAttributeA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from iterators to the next entity they should return,
//	if it is trouble to compute it.
itersStoredEntryA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To represent the class of predefined iterators over simple data
//	structures.
PredefSimpleDataStructIter
{*
  isA->assertZ(PredefinedIter);
*};

//  PURPOSE:   To represent the attr that maps from instances in
//	PredefListIter to the list over which they iterate.
predefListItersListA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To represent the attr that maps from instances in
//	PredefListIter to their current position in that list.
predefListItersPositionA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator to its index in a vector list.
iteratorsIndexA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator to its current node in a node list or
//	tree.
iteratorsNodeA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator to the node just beyond its last legal
//	node.
iteratorsEndNodeA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from iterators to the subject over which they iterate.
iteratorsSubjectA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from iterators to the attribute for which they iterate.
iteratorsAttributeA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from iterators to either 'locallyAsserted' if they
//	iterate over local values or 'inheritedAsserted' if they iterate over
//	locally inherited values.
iteratorsHowAssertedA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from iterators to the assumption context on which
//	they rely.
iteratorsDataA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from iterators to the assumption context on which
//	they rely.
iteratorsAssumptionsA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:  To map from iterators to 'true' if they are inherently
//	unsatisfiable.
iteratorsIsInherentlyUnsatisfiableA
{*
  instanceOf->assertZ(IteratorA);
  attrsRangeA->assertZ(Boolean);
*};


//  PURPOSE:   To map from inherited property iterators to the iterators
//	they used over sets
inheritedPropItersIncludingSetIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from inherited property iterators to the attribute
//	that the query wants.
inheritedPropItersQuerysAttrA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:  To map from ontology property iterators to their iterator over
//	the context (if there is a context over which to iterate).
ontologyPropItersContextIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from ontology property iterators to their iterator
//	over locally stored properties.
ontologyPropItersLocalPropIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from ontology property iterators to their iterator
//	over including sets.
ontologyPropItersIncludingSetIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from ontology property iterators to their iterator
//	over the inherited stated values of the current set.
ontologyPropItersInheritedPropListIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from ontology property iterators to their iterator over
//	the inherited computing assertions of the current set.
ontologyPropItersInheritedAssertListIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from ontology property iterators to their iterator over
//	expression of the current computing assertion.
ontologyPropItersInheritedAssertExprIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator over a derived binary tree container
//	to the iterator it uses to actually iterate over items in the binary
//	tree (regardless of the tree's derived class).
derivedBinTreeIteratorsIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator over a bag to the current count
//	(starting from 0) of the current item.
bagIteratorsCountA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator over the instances of a class to the
//	subclass iterator it uses.
instanceItersSubclassIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from an iterator over the instances of a class to the
//	iterator over the locally-asserted instances of the current class it
//	uses.
instanceItersLocalInstanceIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:  To map from instances of iterators to 'true' if occurrences of
//	'theSubject' should be replaced by their subject, or to 'false' or
//	'null' otherwise.
shouldIterReplaceTheSubjectOccurrenceA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from instances of class iterators to either 'isA'
//	if that iterator returns supersets of a given set or 'instanceOf' if
//	that it returns sets of a given instance.
iteratorsQueryRelationA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from instances of class iterators to the class being
//	considered.
iteratorsBeingConsideredSetA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from instances of class iterators to the list of
//	super/subclasses to consider.
iteratorsToVisitListA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:   To map from instances of class iterators to the iterator over
//	the list of super/subclasses to consider.
iteratorsToVisitListIterA
{*
  instanceOf->assertZ(IteratorA);
*};

//  PURPOSE:  To map from instances of class Iterator to either 'true' if the
//	iterator has reached its end, or to 'false' otherwise.  NOTE: Only
//	meant for iterators for which this is impossible to determine by
//	looking at other state.
hasIteratorReachedEndA
{*
  instanceOf->assertZ(IteratorA);
  attrsRangeA->assertZ(Boolean);
*};

//  PURPOSE:  To represent the class of iterators iterating over rules.
RuleIter
{*
  isA->assertZ(PredefinedIter);
*};

//  PURPOSE:  To represent the class of attributes specific to domain
//	'RuleIter'.
RuleIterA
{*
  isA->assertZ(IteratorA);
  attrsDomainA->assertZ(RuleIter);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a non-negative integer
//	telling the index of the highest clause.
ruleItersHighestClauseIndexA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(Rational);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a non-negative integer
//	telling the maximum number of clauses that may be resolved at one time.
ruleItersMaxNumSimultaneousClausesA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(Rational);
*};


//  PURPOSE:  To map from 'RuleIter' instances to the data structure which
//	holds the rules in which to search.
ruleItersRuleDSA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(DataStructure);
*};

//  PURPOSE:  To map from 'RuleIter' instances to the type of search to conduct
//	(e.g. breadth-first, A*, etc.).
ruleItersSearchStructA
{*
  instanceOf->assertZ(RuleIterA);
*};

//  PURPOSE:  To map from 'RuleIter' instances to an (optional) list of classes
//	and/or data-structures that tell the values that the corresponding
//	quantifier variables ought to iterate over.
ruleItersVarScopeListA
{*
  instanceOf->assertZ(RuleIterA);
*};

//  PURPOSE:  To map from 'RuleIter' instances to other (optional) parameters.
ruleItersOtherParamA
{*
  instanceOf->assertZ(RuleIterA);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a vector list indexed by
//	search depth of the predicate expression for which a match is searched.
ruleItersPredExprListA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(VectorList);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a vector list indexed by
//	search depth of rules being considered to satisfy the corresponding
//	clause.
ruleItersRuleListA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(VectorList);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a vector list indexed by
//	search depth of data structure iterators over rules, all of which
//	always refer to the last rule used.
ruleItersRuleDataStructIterListA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(VectorList);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a vector list indexed by
//	search depth of highest indexes needed to satisfy each corresponding
//	clause.
ruleItersIndexListA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(VectorList);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a vector list indexed by
//	search depth of RuleVarBindingGroup instances.
ruleItersVarBindingGroupListA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(VectorList);
*};

//  PURPOSE:  To map from 'RuleIter' instances to a 'RuleVarBindingGroup'
//	instance that binds the arguments to the initial rule query.
ruleItersExtVarBindingGroupA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(RuleVarBindingGroup);
*};

//  PURPOSE:  To map from 'RuleIter' instances to the
//	'RuleIterBindingSolnIterator' instance for the current variable binding
//	solution (if one exists).
ruleItersRuleIterBindingSolnIterA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(RuleIterBindingSolnIterator);
*};

//  PURPOSE:  To map from 'RuleIter' instances to the initial predicate
//	expression query that it is trying to satisfy.
ruleItersInitialQueryPredExprA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(PredicateExpression);
*};

//  PURPOSE:  To map from 'RuleIter' instances to 'true' if the iterator has
//	been initialized or to 'false' otherwise.
hasRuleIterBeenInitializedA
{*
  instanceOf->assertZ(RuleIterA);
  attrsRangeA->assertZ(Boolean);
*};


//  PURPOSE:  To represent a group of iterators that implementing an internal
//	class used by 'RuleIteratorIdeaStructure' instances to iterate over
//	the solutions to one particular configuration of bindings and rules.
RuleIterBindingSolnIterator
{*
  isA->assertZ(PredefinedIter);
*};

//  PURPOSE:  To represent the class of attributes specific to
//	RuleIterBindingSolnIterator instances.
RuleIterBindingSolnIteratorA
{*
  isA->assertZ(IteratorA);
  attrsDomainA->assertZ(RuleIterBindingSolnIterator);
*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the
//	vectorlist that contains their bindings.
//ruleIterBindingSolnItersBindingVectA
//{*
//  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
//  attrsRangeA->assertZ(VectorList);
//  attrsIsSingleValuedA->assertZ(true);
//*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the
//	vectorlist that contains the RuleVarBindingGroup for the corresponding
//	bindings in 'ruleIterBindingSolnItersBindingVectA'
//ruleIterBindingSolnItersBindingGroupVectA
//{*
//  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
//  attrsRangeA->assertZ(VectorList);
//  attrsIsSingleValuedA->assertZ(true);
//*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the
//	RuleVarBindingGroup instance from which they were constructed.
ruleIterBindingSolnItersRuleVarBindingGroupA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
  attrsRangeA->assertZ(RuleVarBindingGroup);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the vector
//	in which they store and report their values.
ruleIterBindingSolnItersValueVectA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
  attrsRangeA->assertZ(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the vector
//	in which they store the iterators they use.
ruleIterBindingSolnItersIterVectA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
  attrsRangeA->assertZ(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the vector
//	in which they store the indexes of where in the
//	'ruleIterBindingSolnItersValueVectA' vector to store the value from the
//	iterator with the corresponding position in
//	'ruleIterBindingSolnItersIterVectA'.
ruleIterBindingSolnItersIndexVectA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
  attrsRangeA->assertZ(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to the map
//	from ultimate bindings to the indices in the
//	ruleIterBindingSolnItersValueVectA value at which their corresponding
//	values are placed.
ruleIterBindingSolnItersUltBindToValIndexMapA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);

  attrsRangeA->assertZ(Map);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to a list of
//	quantifiers.  Legal values for that position must satisfy all the
//	conditions.
ruleIterBindingSolnItersQuantListVectA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);

  attrsRangeA->assertZ(List);
  attrsIsSingleValuedA->assertZ(true);
*};


//  PURPOSE:  To map from RuleIterBindingSolnIterator instances to 'true' if
//	the current values in the 'ruleIterBindingSolnItersValueVectA' have
//	been checked, or to 'false' otherwise.
ruleIterBindingSolnItersHaveValueVecValsBeenCheckedA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
  attrsRangeA->assertZ(Boolean);
  attrsIsSingleValuedA->assertZ(true);
*};


//  PURPOSE:  To map form RuleIterBindingSolnIterator instances to a map from
//	variable names in the external binding group's rule to their
//	corresponding index in 'ruleIterBindingSolnItersValueVectA'.
ruleIterBindingSolnItersRuleVarToIndexMapA
{*
  instanceOf->assertZ(RuleIterBindingSolnIteratorA);
  attrsRangeA->assertZ(Map);
  attrsIsSingleValuedA->assertZ(true);
*};

IterEntry
{*
  isA->assertZ(ProgramObject);
*};

PropIterQEntry
{*
  isA->assertZ(IterEntry);

  ideasImplicitConstructorA->subAssert
    (^ImplicitConstructor
	[*
	  [propIterQEntrysValA,		// Maps to value to return
	   propIterQEntrysSubjA,	// Maps to subj (set or inst)
	   propIterQEntrysExprA,	// Maps to expression
	   propIterQEntrysExprsIterA	// Maps to iterator over expr
	  ]
	*]
    );
*};

IteratorEntryA
{*
  isA->assertZ(ProgramObjectA);
*};

propIterQEntrysValA
{*
  instanceOf->assertZ(IteratorEntryA);
*};

propIterQEntrysSubjA
{*
  instanceOf->assertZ(IteratorEntryA);
*};

propIterQEntrysExprA
{*
  instanceOf->assertZ(IteratorEntryA);
*};

propIterQEntrysExprsIterA
{*
  instanceOf->assertZ(IteratorEntryA);
*};


RuleIterEntry
{*
  isA->assertZ(IterEntry);
*};

RuleIterEntryA
{*
  isA->assertZ(IteratorEntryA);

  attrsDomainA->subAssertZ(RuleIter);
*};

ruleIterEntrysValueVectA
{*
  instanceOf->assertZ(RuleIterEntryA);
  attrsRangeA->assert(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};

ruleIterEntrysRulesVarToIndexMapA
{*
  instanceOf->assertZ(RuleIterEntryA);
  attrsRangeA->assert(Map);
  attrsIsSingleValuedA->assertZ(true);
*};


AssertionApplyIter
{*
  isA->assertZ(Iterator);
*};


/?---?				Assumption
 ?---?
 ?---?	    This file defines knowledge about Assumption instances that
 ?---?	the StructProc knowledge base needs to operate.
 ?---?/

Assumption
{*
  isA->assertZ(ProgramObject);
*};


AssumptionA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertZ(Assumption);
*};


assumptionsThisA
{*
  instanceOf->assertZ(AssumptionA);
  attrsRangeA->assertZ(Idea);
*};


//  PURPOSE:  To map from an instance of an Assumption to the Assumption from
//	which it was derived.
assumptionsDerivedFromAssumptionA
{*
  instanceOf->assertZ(AssumptionA);
  attrsRangeA->assertZ(Assumption);
*};


//  PURPOSE:  To map from an instance of an Assumption to a non-negative
//	integer that tells the maximum effort (implemented as maximum recursive
//	depth, maximum number of simultaneous clauses to match, etc.)
assumptionsMaxEffortIntegerLimitA
{*
  instanceOf->assertZ(AssumptionA);
  attrsRangeA->assertZ(Rational);
*};




final
noAssumptions
{*
  instanceOf->assertZ(Assumption);
*};

AssumptionSubjEntry
{*
  isA->assertZ(ProgramObject);
*};


/?---?				Rule
 ?---?
 ?---?	    This section defines knowledge about rules, predicate
 ?---?	expressions, quantifiers and predicates that the StructProc knowledge
 ?---?	base needs to operate.
 ?---?/

//PURPOSE:  To represent the set of rules.
Rule
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};

//PURPOSE:  To represent the set of attributes of instances of 'Rule'.
RuleA
{*
  isA->assertZ(ProgramObjectA);
  attrsDomainA->assertZ(Rule);
*};

//PURPOSE:  To map from a rule to its head predicate expression.
rulesHeadPredExprA
{*
  instanceOf->assertZ(RuleA);
  attrsRangeA->assertZ(PredicateExpression);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from a rule to its list of conjunctive clauses to satisfy.
rulesConjunctiveClauseListA
{*
  instanceOf->assertZ(RuleA);
  attrsRangeA->assertZ(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from a rule to a list of quantifiers (other than
//	SpecValQuant instances) that appear in it.
rulesQuantListA
{*
  instanceOf->assertZ(RuleA);
  attrsRangeA->assertZ(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from a rule to a list of names of variables that it
//	quantifies.
rulesVarNameListA
{*
  instanceOf->assertZ(RuleA);
  attrsRangeA->assertZ(VectorList);
  attrsIsSingleValuedA->assertZ(true);
*};


// PURPOSE:  To map from a rule to a map from the variable names in the rule to
//	the quantifier that quantifies them.
rulesVarNameToQuantMapA
{*
  instanceOf->assertZ(RuleA);
  attrsRangeA->assertZ(Map);
  attrsIsSingleValuedA->assertZ(true);
*};



//PURPOSE:  To represent the class of predicate expressions and quantifier
//	instances.
LogicClause
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};


//PURPOSE:  To represent the class of predicate expressions.
PredicateExpression
{*
  isA->assertZ(LogicClause);
*};

//PURPOSE:  To represent the set of attributes of instances of
//	'PredicateExpression'.
PredicateExpressionA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertZ(PredicateExpression);
*};

//PURPOSE:  To map from a predicate expression to its predicate.
predicateExpressionsPredicateA
{*
  instanceOf ->assertZ(PredicateExpressionA);
  attrsRangeA->assertZ(Predicate);
  attrsIsSingleValuedA->assertZ(true);
*};

//PURPOSE:  To map from a predicate expression to its list of arguments.
predicateExpressionsArgListA
{*
  instanceOf->assertZ(PredicateExpressionA);
//  attrsRangeA->assertZ(List);
  attrsIsSingleValuedA->assertZ(true);
*};



//PURPOSE:  To represent the class of quantifiers.
Quantifier
{*
  isA->assertZ(LogicClause);
*};

//PURPOSE:  To represent the set of attributes of instances of 'Quantifier'.
QuantifierA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertZ(Quantifier);
*};

//PURPOSE:  To map from a quantifier to the variable usage that it has.
quantifiersVarUsageA
{*
  instanceOf->assertZ(QuantifierA);
*};

//PURPOSE:  To map from a quantifier to the class of which it finds instances.
quantifiersClassA
{*
  instanceOf->assertZ(QuantifierA);
  attrsRangeA->assertA(Idea);
*};

//PURPOSE:  To map from a quantifier to the instance of which it finds classes
//	that contain it.
quantifiersInstanceA
{*
  instanceOf->assertZ(QuantifierA);
  attrsRangeA->assertA(Idea);
*};

//PURPOSE:  To map from a quantifier to the subject of the <subj,attr> pair
//	over which it quantifies.
quantifiersSubjA
{*
  instanceOf->assertZ(QuantifierA);
  attrsRangeA->assertA(Idea);
*};

//PURPOSE:  To map from a quantifier to the attribute of the <subj,attr> pair
//	over which it quantifies.
quantifiersAttrA
{*
  instanceOf->assertZ(QuantifierA);
  attrsRangeA->assertA(Attribute);
*};

//PURPOSE:  To map from a quantifier to the single specific value that its
//	variable must have.
quantifiersValA
{*
  instanceOf->assertZ(QuantifierA);
  attrsRangeA->assertA(Idea);
*};


//PURPOSE:  To represent the class of quantifiers over single specific values.
SpecValQuant
{*
  isA->assertZ(Quantifier);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [quantifiersValA,	Idea]
		   ]
		*]
	);
*};


//PURPOSE:  To represent the class of quantifiers over values of a given
//	<subj,attr> pair.
ValOfQuant
{*
  isA->assertZ(Quantifier);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [quantifiersVarUsageA,	VariableUsage],
		     [quantifiersSubjA,		Idea],
		     [quantifiersAttrA,		Attribute]
		   ]
		*]
	);
*};


//PURPOSE:  To represent the class of quantifiers over a instances of a class.
InClassQuant
{*
  isA->assertZ(Quantifier);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [quantifiersVarUsageA,	VariableUsage],
		     [quantifiersClassA,	Idea]
		   ]
		*]
	);
*};


//PURPOSE:  To represent the class of quantifiers over classes of a given
//	instance.
ClassOfQuant
{*
  isA->assertZ(Quantifier);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [quantifiersVarUsageA,	VariableUsage],
		     [quantifiersInstanceA,	Idea]
		   ]
		*]
	);
*};


//PURPOSE:  To represent the class of quantifiers over superclasses of a given
//	class.
SuperclassOfQuant
{*
  isA->assertZ(Quantifier);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [quantifiersVarUsageA,	VariableUsage],
		     [quantifiersClassA,	Idea]
		   ]
		*]
	);
*};


//PURPOSE:  To represent the class of quantifiers over subclasses of a given
//	class.
SubclassOfQuant
{*
  isA->assertZ(Quantifier);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [quantifiersVarUsageA,	VariableUsage],
		     [quantifiersClassA,	Idea]
		   ]
		*]
	);
*};



//PURPOSE:  To represent the class of predicates.
Predicate
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};


//  PURPOSE:  To represent the class of bindings of rule vars instances.
RuleVarBinding
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};

//  PURPOSE:  To represent the class of attributes with RuleVarBinding
//	instances as their sole domain.
RuleVarBindingA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertA(RuleVarBinding);
*};

//  PURPOSE:  To map from 'RuleVarBinding' instances to the single quantifier
//	with the variable that they bind.
ruleVarBindingsQuantA
{*
  instanceOf->assertA(RuleVarBindingA);
  attrsRangeA->assertA(Quantifier);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from 'RuleVarBinding' instances to list of quantifiers
//	that they are charged with trying to satisfy.  This attribute is
//	mutually exclusive with 'ruleVarBindingsSpecValA'.
ruleVarBindingsQuantListA
{*
  instanceOf->assertA(RuleVarBindingA);
  attrsRangeA->assertA(List);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from 'RuleVarBinding' instances to the specific value (if
//	there is one) to which the quantifiers are bound.  This attribute is
//	mutually exclusive with 'ruleVarBindingsQuantListA'.
ruleVarBindingsSpecValA
{*
  instanceOf->assertA(RuleVarBindingA);
  attrsRangeA->assertA(Idea);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from 'RuleVarBinding' instances to another
//	'RuleVarBinding' instance for a variable in the rule that caused the
//	current rule to be recursively invoked, and to which this rule var is
//	bound.
ruleVarBindingsImmediateBindingA
{*
  instanceOf->assertA(RuleVarBindingA);
  attrsRangeA->assertA(RuleVarBinding);
  attrsIsSingleValuedA->assertZ(true);
*};

//  PURPOSE:  To map from 'RuleVarBinding' instances to the first such
//	'RuleVarBinding' instance with the first variable to which this subject
//	'RuleVarBinding' instance is ultimately bound.
ruleVarBindingsUltimateBindingA
{*
  instanceOf->assertA(RuleVarBindingA);
  attrsRangeA->assertA(RuleVarBinding);
  attrsIsSingleValuedA->assertZ(true);
*};



//  PURPOSE:  To represent a group of 'RuleVarBinding' instances for one
//	particular rule invocation.
RuleVarBindingGroup
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);

  //  NOTE:  The code below tells the work that is done to construct a
  //	usable RuleVarBindingGroup instance.  That work is actually done in
  //	the language that the SP8b is implemented in for speed.  As rules
  //	provide basic functionality the design decision was made to optimize
  //	for speed rather than flexibility.
  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [ruleVarBindingGroupsRuleA, Rule],
		     [  ruleVarBindingGroupsPrevRuleVarBindingGroupA,
			RuleVarBindingGroup
		     ]
		   ],
		   [ [ ruleVarBindingGroupsVarToSpecValMapA,
		       ^^Map[* *]
		     ],
		     [ ruleVarBindingGroupsToCheckLogicClauseListA,
		       ^^VectorList[* *]
		     ],
		     [ ruleVarBindingGroupsVarBindingGroupOfToCheckLogicClauseListA,
		       ^^VectorList[* *]
		     ]
		   ]
		*]
	);
*};

//  PURPOSE:  To represent the class of attributes with RuleVarBindingGroupA
//	instances as their sole domain.
RuleVarBindingGroupA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertA(RuleVarBindingGroup);
*};

//  PURPOSE:  To map from 'RuleVarBindingGroup' instances to their map of
//	rule variable names to that variable's specific value (if a specific
//	value has been defined).
ruleVarBindingGroupsVarToSpecValMapA
{*
  instanceOf->assertZ(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Map);
*};

//  PURPOSE:  To map from external 'RuleVarBindingGroup' instances to their map
//	of rule variable names to their bindings.
ruleVarBindingGroupsVarNameToBindingMapA
{*
  instanceOf->assertZ(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Map);
*};

//  PURPOSE:  To map from 'RuleVarBindingGroup' instances to their map of rule
//	quantifiers to the bindings that serve them.
ruleVarBindingGroupsQuantToBindingMapA
{*
  instanceOf->assertZ(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Map);
*};

//  PURPOSE:  To map from 'RuleVarBindingGroup' instances to the list of logic
//	clauses they should check after their rule's logic clause list is at
//	the end.
ruleVarBindingGroupsToCheckLogicClauseListA
{*
  instanceOf->assertA(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(VectorList);
*};

//  PURPOSE:  To map from 'RuleVarBindingGroup' instances to the list of
//	'RuleVarBindingGroup' used in the clauses of the corresponding
//	'ruleVarBindingGroupsToCheckLogicClauseListA' list.
ruleVarBindingGroupsVarBindingGroupOfToCheckLogicClauseListA
{*
  instanceOf->assertA(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(VectorList);
*};

//  PURPOSE:  To map from 'RuleVarBindingGroup' instances to the previous
//	'RuleVarBindingGroup' upon which they are based.
ruleVarBindingGroupsPrevRuleVarBindingGroupA
{*
  instanceOf->assertA(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(RuleVarBindingGroup);
*};

//  PURPOSE:  To map from 'RuleVarBindingGroup' instances to the rule whose
//	quantifiers that this instance binds.
ruleVarBindingGroupsRuleA
{*
  instanceOf->assertA(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Rule);
*};

//  PURPOSE:  To map from external 'RuleVarBindingGroup' that originates a
//	query to a list of the quantifiers that appear in the querying
//	predicate expression.
extRuleVarBindingGroupsQuantListA
{*
  instanceOf->assertA(RuleVarBindingGroupA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(VectorList);
*};


/?---?				SpEnv
 ?---?
 ?---?	    This file defines knowledge about the StructProc
 ?---?	environment that the StructProc knowledge base needs to operate.
 ?---?/

SpEnv
{*
  isA->assertZ(ProgramObject);
*};


//  PURPOSE:  To represent the class of attributes of the SP environment.
SpEnvA
{*
  isA->assertZ(ProgramObjectA);
*};


//  PURPOSE:  To map from 'thisSE' to the specific natural language function
//	family it should use for 'NatLangExpr' instances.
spEnvsNatLangFncA
{*
  instanceOf->assertZ(SpEnvA);
*};


//  PURPOSE:  To map from 'thisSE' to the level of formality the SP environment
//	should address the user.
spEnvsNatLangFormalityA
{*
  instanceOf->assertZ(SpEnvA);
*};


//  PURPOSE:  To map from 'thisSE' to the filename currently being parsed.
spEnvsCurrentParseFileA
{*
  instanceOf->assertZ(SpEnvA);
*};


//  PURPOSE:  To represent the multi-valued attribute that tells which
//	subclasses of 'DomainsSemanticRangeA' are to generate warnings when
//	AnnotatedValue instances are generated with values outside of their
//	range.
spEnvsWarningGeneratingSemanticDomainClassA
{*
  instanceOf->assertZ(SpEnvA);
*};


//  PURPOSE:  To represent the multi-valued attribute that tells which
//	subclasses of 'DomainsSemanticRangeA' are to generate errors (exception
//	'AnnotatedValueOutsideOfRangeException') when AnnotatedValue instances
//	are generated with values outside of their range.
spEnvsErrorGeneratingSemanticDomainClassA
{*
  instanceOf->assertZ(SpEnvA);
*};


//  PURPOSE:  To represent this running of the SP environment.
thisSE
{*
  instanceOf->assertZ(SpEnv);

  isNatLangKbInitialized Boolean
  [*
    [ ],

    ^Do
    [*[
      ^Return[* thisSE->localGet(spEnvsNatLangFncA) !=ref null *]
    ]*]
  *];

*};


/?---?				IoStream
 ?---?
 ?---?	    This file defines knowledge about Input/Output streams that
 ?---?	the StructProc knowledge base needs to operate.
 ?---?/

IoStream
{*
  isA->assertZ(ProgramObject);
*};


InputStream
{*
  isA->assertZ(IoStream);
*};


stdIn
{*
  instanceOf->assertZ(InputStream);
*};


OutputStream
{*
  isA->assertZ(IoStream);
*};


stdOut
{*
  instanceOf->assertZ(OutputStream);
*};


stdErr
{*
  instanceOf->assertZ(OutputStream);
*};



/?---?				Search
 ?---?
 ?---?	    This file defines knowledge about search classes that
 ?---?	the StructProc knowledge base needs to operate.
 ?---?/

Search
{*
  isA->assertZ(ProgramObject);
*};

BreadFirstOntologySearch
{*
  isA->assertZ(Search);
*};


BreadFirstSetsOfMemberSearch
{*
  isA->assertZ(BreadFirstOntologySearch);
*};



/?---?				Sort related
 ?---?
 ?---?/
SortOrder
{*
  isA->assertZ(ProgramObject);
*};

ascendingOrder
{*
  instanceOf->assertZ(SortOrder);
*};

descendingOrder
{*
  instanceOf->assertZ(SortOrder);
*};


/?---?
 ?---?/

/? Is this used under either "L(ambda)Template" or "AnonFncTemplate"?
LTemplate
{*
  isA->assertZ(ProgramObject);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[*
		  [[lTemplatesTemplateVarsListA,Idea],
		   [lTemplatesReturnTypeA,	Idea],
		   [lTemplatesFncsParamsListA,	Idea],
		   [lTemplatesBodyA,		Idea]
		  ]
		*]
	);
*};
?/


//  PURPOSE:  To represent different alternatives on hold to deal with errors.
ErrorAction
{*
  isA->assertZ(ProgramObject);
*};

  //  PURPOSE:  To represent the action of warning when an error occurs.
  warnErrorAction
  {*
    instanceOf->assertZ(ErrorAction);
  *};

  //  PURPOSE:  To represent the action of throwing an Exception an error
  //	occurs.
  exceptionErrorAction
  {*
    instanceOf->assertZ(ErrorAction);
  *};

//  PURPOSE:  To represent the class of all exceptions.
Exception
{*
  isA->assertZ(ProgramObject);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [* [ [exceptionsValueA,	Idea]
	     ]
	  *]
	);

*};

  //  PURPOSE:  To represent the subclass of 'Exception' for exceptions defined
  //	within the StructProc language.
  SPDefinedException
  {*
    isA->assertZ(Exception);
  *};

  //  PURPOSE:  To represent the class of attributes whose domain is Exception.
  ExceptionA
  {*
    isA->assertZ(ProgramObjectA);
    attrsDomainA->subAssertZ(Exception);
  *};

/? --- end of file --- ?/

thisSE->parseFile("SecondaryDataStructure.som8");
/?-------------------------------------------------------------------------?
 ?---									---?
 ?---		SecondaryDataStructure.som8				---?
 ?---									---?
 ?---	    This file section define knowledge for data-structures	---?
 ?---	not directly architecturally supported.				---?
 ?---									---?
 ?---	----	----	----	----	----	----	----	----	---?
 ?---									---?
 ?---	Version 8b		2014 October 23		Joseph Phillips	---?
 ?---									---?
 ?-------------------------------------------------------------------------?/

//  PURPOSE:  To define that class of data-structures that do not (necessarily)
//	support the dataStruct_* methods (like 'dataStruct_iter()').
NonQueryableDataStructure
{*
  isA->assertZ(ProgramObject);

  mayBeDestroyedA->subAssert(true);
*};


//  PURPOSE:  To represent the set of attributes over NonQueryableDataStructure
//	instances.
NonQueryableDataStructureStructureA
{*
  isA->assertZ(ProgramObjectA);
*};


//  PURPOSE:  To represent a class of singleDistinct pairs of arbitrary things.
SingleDistinctPair
{*
  isA->assertZ(NonQueryableDataStructure);

  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
  ideasImplicitConstructorA->subAssert
      (^ImplicitConstructor
	[*
	  [ [singleDistinctPairsFirstItemA,	Idea],
	    [singleDistinctPairsSecondItemA,	Idea]
	  ]
	*]
      );
*};


//  PURPOSE:  To map from a 'SingleDistinctPair' instance to its first item.
singleDistinctPairsFirstItemA
{*
  instanceOf->assertZ(NonQueryableDataStructureStructureA);
  attrsDomainA->assertZ(SingleDistinctPair);
*};


//  PURPOSE:  To map from a 'SingleDistinctPair' instance to its second item.
singleDistinctPairsSecondItemA
{*
  instanceOf->assertZ(NonQueryableDataStructureStructureA);
  attrsDomainA->assertZ(SingleDistinctPair);
*};
/? --- end of file --- ?/
/? --- end of file --- ?/


makeInterTermGrammarInfo_english
{*
  instanceOf->assertZ(InterTermGrammarInfoFncsFamily);
*};

makeInterTermGrammarInfo_indoEuropean
{*
  instanceOf->assertZ(InterTermGrammarInfoFncsFamily);
*};

thisSE->parseFile("knowledgebases/standard/NaturalLanguage.som8");
/?
    Suggested form:
     <lang> + "_" + <locale> + "_" + <time> + "_" + <professional culture>

    Where:
    <lang>: ISO 639-3 language code
	(English =ref "eng")
    <locale>:
        Form 1 (by country): "coun" + <ISO 3166-1 alpha-3 codes>
	(country United States of America = "counUSA")
    <time>:
	Form 1 (by century):
	"cent" + ("Early"|"Mid"|"Late") + <common era century> + ["ce"|"bce"]
	(2011 is in "centEarly21ce" or just "centEarly21")
    <professional culture>:
	(Scientific =ref "sci")

    Example:
	"eng_counUSA_centEarly21_sci"
 ?/

//  PURPOSE:  To serve as the superclass of most natural language related
//	identities.
NatLangRelated
{*
  isA->assertZ(CulturalConvention);
*};


NatLangDefn
{*
  isA->assertZ(ProgramObject);
*};


eng_counUSA_centEarly21_sci
{*
  instanceOf->assertZ(NatLangDefn);
*};


//  PURPOSE:  To represent the class of attributes of natural language related
//	identities.
NatLangRelatedA
{*
  isA->assertZ(CulturalConventionA);

  attrsDomainA->subAssertA(NatLangRelated);
*};


natLangBecauseThereforePhrasesPreconditionA
{*
  instanceOf->assertZ(NatLangRelatedA);
*};



//									//
//			    NatLangPerson				//
//									//

NatLangPerson		{* isA->assertZ(NatLangRelated); *};
  firstPerson		{* instanceOf->assertZ(NatLangPerson); *};
  secondPerson		{* instanceOf->assertZ(NatLangPerson); *};
  thirdPerson		{* instanceOf->assertZ(NatLangPerson); *};
noMore NatLangPerson	{* *};



//									//
//			    NatLangPlurality				//
//									//

//  PURPOSE:  To define identities that specify the plurality of phrases
//	in a sentence.
NatLangPlurality	{* isA->assertZ(NatLangRelated); *};
  zeroPlurality		{* instanceOf->assertZ(NatLangPlurality);
			   natLangMinPluralityCountA->assert(0);
			   natLangMaxPluralityCountA->assert(0);
			*};
  moreThanZeroPlurality	{* instanceOf->assertZ(NatLangPlurality);
      			   natLangMinPluralityCountA->assertZ(1);
			*};
  singularPlurality	{* instanceOf->assertZ(NatLangPlurality);
			   natLangMinPluralityCountA->assert(1);
			   natLangMaxPluralityCountA->assert(1);
			*};
  moreThanOnePlurality	{* instanceOf->assertZ(NatLangPlurality);
			   natLangMinPluralityCountA->assert(2);
			*};
  fewPlurality		{* instanceOf->assertZ(NatLangPlurality);
			   natLangMinPluralityCountA->assert(2);
			*};
  manyPlurality		{* instanceOf->assertZ(NatLangPlurality);
			   natLangMinPluralityCountA->assertZ(3);
      			*};
  // Allow for more instances of NatLangPlurality

//  PURPOSE:  To map from instances of 'NatLangPlurality' to Rational instances
//	telling the exact count implied.
natLangPluralityCountA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Rational);
*};

//  PURPOSE:  To map from instances of 'NatLangPlurality' to Rational instances
//	telling the minimum count implied.
natLangMinPluralityCountA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Rational);
*};

//  PURPOSE:  To map from instances of 'NatLangPlurality' to Rational instances
//	telling the maximum count implied.
natLangMaxPluralityCountA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Rational);
*};



//									//
//			NatLangPersonPlurality				//
//									//

//  PURPOSE:  To represent simultaneous person and plurality values, to
//	make the conjugation of verbs easier (at least in Indo-European
//	 languages).
NatLangPersonPlurality	  {* isA->assertZ(NatLangRelated); *};
  firstPersonSingle	  {* instanceOf->assertZ(NatLangPersonPlurality); *};
  secondPersonSingle	  {* instanceOf->assertZ(NatLangPersonPlurality); *};
  thirdPersonSingle	  {* instanceOf->assertZ(NatLangPersonPlurality); *};
  firstPersonPlural	  {* instanceOf->assertZ(NatLangPersonPlurality); *};
  secondPersonPlural	  {* instanceOf->assertZ(NatLangPersonPlurality); *};
  thirdPersonPlural	  {* instanceOf->assertZ(NatLangPersonPlurality); *};
  // Allow for more instances of NatLangPersonPlurality



//									//
//			NatLangPersonPlurality				//
//									//

//  PURPOSE:  To define identities that specify the gender of phrases
//	in a sentence.
NatLangGender			{* isA->assertZ(NatLangRelated); *};
  final femaleNatLangGender	{* instanceOf->assertZ(NatLangGender); *};
  final maleNatLangGender	{* instanceOf->assertZ(NatLangGender); *};
  final neuterNatLangGender	{* instanceOf->assertZ(NatLangGender); *};
  // Allow for more instances of NatLangGender
  // (perhaps from non-IndoEuropean languages)



//									//
//	NatLangTenseWhen, NatLangTenseImmediacy, and NatLangTense	//
//									//

//  PURPOSE:  To define identities that specify when the action of a phrase
//	did, is, will, or whether, take place.
NatLangTenseWhen		{* isA->assertZ(NatLangRelated); *};
  final pastNatLangTenseWhen	{* instanceOf->assertZ(NatLangTenseWhen); *};
  final presentNatLangTenseWhen	{* instanceOf->assertZ(NatLangTenseWhen); *};
  final futureNatLangTenseWhen	{* instanceOf->assertZ(NatLangTenseWhen); *};
  final conditionalNatLangTenseWhen
				{* instanceOf->assertZ(NatLangTenseWhen); *};
noMore NatLangTenseWhen		{* *};


//  PURPOSE:  To map from an 'NatLangTense' instance to its
//	'NatLangTenseWhen' value.
natLangTensesWhenA
{*
  instanceOf->assertZ(NatLangRelatedA);
*};

//  PURPOSE:  To map from an 'NatLangTense' instance to its
//	'NatLangTenseImmediacy' value.
natLangTensesImmediacyA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(NatLangTenseImmediacy);
*};


//  PURPOSE:  To define identities that specify how immediate the action
//	of a phrase is, whether it occurs in-general, right-then, or was
//	completed.
NatLangTenseImmediacy		{* isA->assertZ(NatLangRelated); *};
  inGeneralNatLangTenseImmediacy
  {* instanceOf->assertZ(NatLangTenseImmediacy); *};
  // In English what I call "in general" is generally called "simple tense".
  //  I think "in general" is more intuitive.

  rightThenNatLangTenseImmediacy
  {* instanceOf->assertZ(NatLangTenseImmediacy); *};
  // In English what I call "right then" is generally called "continuous
  //  tense" or "progressive".  I think "right then" is more intuitive.

  completedNatLangTenseImmediacy
  {* instanceOf->assertZ(NatLangTenseImmediacy); *};
  // In English what I call "completed tense" is generally called
  // "perfect tense".  I think "completed tense" is more intuitive


  // Allow for more periods, perhaps accounting for the English tenses:
  // present perfect on going, past perfect on going and
  // future perfect on going.


//  PURPOSE:  To define identities that specify both a 'NatLangTenseWhen'
//	instance and a 'NatLangTenseImmediacy' instance.
NatLangTense
{*
  isA->assertZ(NatLangRelated);

  ideasImplicitConstructorA->
     subAssert
	(^ImplicitConstructor
	    [* [[natLangTensesWhenA,		NatLangTenseWhen],
	        [natLangTensesImmediacyA,	NatLangTenseImmediacy]
	       ]
	    *]
	);
*};

  //  InGeneral past (English): "I programmed"
  inGeneralPastNatLangTense
      [* NatLangTense|pastNatLangTenseWhen,inGeneralNatLangTenseImmediacy *];

  //  Right then past (English): "I was programming"
  rightThenPastNatLangTense
      [* NatLangTense|pastNatLangTenseWhen,rightThenNatLangTenseImmediacy *];

  //  Completed past (English): "I had programmed"
  completedPastNatLangTense
      [* NatLangTense|pastNatLangTenseWhen,completedNatLangTenseImmediacy *];

  //  InGeneral present (English): "I program"
  inGeneralPresentNatLangTense
      [* NatLangTense|presentNatLangTenseWhen,inGeneralNatLangTenseImmediacy *];

  //  Right then present (English): "I am programming"
  rightThenPresentNatLangTense
      [* NatLangTense|presentNatLangTenseWhen,rightThenNatLangTenseImmediacy *];

  //  Completed present (English): "I have programmed"
  completedPresentNatLangTense
      [* NatLangTense|presentNatLangTenseWhen,completedNatLangTenseImmediacy *];

  //  InGeneral future (English): "I will program"
  inGeneralFutureNatLangTense
      [* NatLangTense|futureNatLangTenseWhen,inGeneralNatLangTenseImmediacy *];

  //  Right then future (English): "I will be programming"
  rightThenFutureNatLangTense
      [* NatLangTense|futureNatLangTenseWhen,rightThenNatLangTenseImmediacy *];

  //  Completed future (English): "I will have programmed"
  completedFutureNatLangTense
      [* NatLangTense|futureNatLangTenseWhen,completedNatLangTenseImmediacy *];

  //  "Tense" of verb abstracted from time.  In some Indo-European languages
  //  this is the infinitive form of the verb (English): "to program"
  timelessNatLangTense
      [* NatLangTense|null,inGeneralNatLangTenseImmediacy *];

  //  "Tense" of verb when turned into a noun.  In some Indo-European languages
  //  this is the gerund form of the verb (English): "programming"
  nounifiedNatLangTense
      [* NatLangTense|null,rightThenNatLangTenseImmediacy *];



//									//
//			    NatLangFormality				//
//									//

//  PURPOSE:  To define identities that specify the level of formality to
//	be used in a 'NatLangExpr' instance.
NatLangFormality		{* isA->assertZ(NatLangRelated); *};
  final rudeNatLangFormality	{* instanceOf->assertZ(NatLangFormality); *};
  final informalNatLangFormality{* instanceOf->assertZ(NatLangFormality); *};
  final formalNatLangFormality	{* instanceOf->assertZ(NatLangFormality); *};
  final obsequiousNatLangFormality
				{* instanceOf->assertZ(NatLangFormality); *};
noMore NatLangFormality		{* *};



//									//
//			NatLangAffirmNegateStatus			//
//									//

//  PURPOSE:  To define identities that distinguish whether an expression is
//	being affirmed, negated, or declared as unknown.
NatLangAffirmNegateStatus	{* isA->assertZ(NatLangRelated); *};

  final affirmNatLangStatus
  {*  instanceOf->assertZ(NatLangAffirmNegateStatus);  *};

  final negateNatLangStatus
  {*  instanceOf->assertZ(NatLangAffirmNegateStatus);  *};

  final ignorantNatLangStatus
  {*  instanceOf->assertZ(NatLangAffirmNegateStatus);  *};


//									//
//			    NatLangPhraseRole				//
//									//

//  PURPOSE:  To define identities that distinguish among the roles that
//	phrases may play in sentences (other than being the verb).
NatLangPhraseRole		{* isA->assertZ(NatLangRelated); *};
  subjectNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  directObjectNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  directObjectTextNatLangPhraseRole
				{* instanceOf->assertZ(NatLangPhraseRole); *};
  havingNatLangPhraseRole 	{* instanceOf->assertZ(NatLangPhraseRole); *};
  withValueNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  becauseOfNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  usingNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  forThePurposeOfNatLangPhraseRole
				{* instanceOf->assertZ(NatLangPhraseRole); *};
  towardNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  awayFromNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  whereNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  whenNatLangPhraseRole		{* instanceOf->assertZ(NatLangPhraseRole); *};
  relativeToNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};
  notObjectNatLangPhraseRole	{* instanceOf->assertZ(NatLangPhraseRole); *};



//									//
//			        NatLangExpr				//
//									//

//  PURPOSE:  To represent the set of natural language expressions.
NatLangExpr
{*
  isA->assertZ(NatLangRelated);

  mayBeDestroyedA->subAssert(true);
*};
//  NatLangExpr


//  PURPOSE:  To map from an 'NatLangExpr' instance representing a sentence
//	phrase to its 'NatLangPhraseRole' value.
natLangExprsPhraseRoleA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(NatLangPhraseRole);
*};


//  PURPOSE:  To map from 'NatLangExpr' instances to 'true' if they are the
//	main topic, or to 'false' (or 'null') otherwise.  NOTE: THE TOPIC OF A
//	SENTENCE DOES NOT HAVE TO BE ITS SUBJECT!  For example, if want to
//	emphasize that Ann gave Bob $100 (as oppose to giving it to Charlie,
//	we could say in English "Ann gave BOB $100",
isNatLangExprPhraseTheTopicA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsDomainA->subAssertA(NatLangExpr);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(Boolean);
*};



//									//
//		NatLangParameterizedDescriptorPhrase			//
//									//

//  PURPOSE:  To represent the class of parameterized descriptor phrases.
//	The term "parameterized descriptor phrases" encompasses what in many
//	Indo-European languages are prepositional phrases, what in Japanese
//	are particle phrases like "ni".
NatLangParameterizedDescriptorPhrase
{*
  isA->assertZ(NatLangExpr);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [[natLangParameterizedDescriptorPhrasesDescriptorA,
					NatLangParameterizedDescriptorTerm],
	       [natLangExprsPhraseRoleA,NatLangPhraseRole],
	       [natLangParameterizedDescriptorPhrasesArgA,
					NatLangExpr]
	      ]
	    *]
	);
*};


//  PURPOSE:  To represent the class of attributes over
//	'NatLangParameterizedDescriptorPhrase' instances.
NatLangParameterizedDescriptorPhraseA
{*
  isA->assertZ(NatLangRelatedA);
*};

//  PURPOSE:  To map from 'NatLangParameterizedDescriptorPhrase' instances to
//	their descriptor.
natLangParameterizedDescriptorPhrasesDescriptorA
{*
  instanceOf->assertZ(NatLangParameterizedDescriptorPhraseA);
*};

//  PURPOSE:  To map from 'NatLangParameterizedDescriptorPhrase' instances to
//	one of their parameters.  Is potentially multi-valued.
natLangParameterizedDescriptorPhrasesArgA
{*
  instanceOf->assertZ(NatLangParameterizedDescriptorPhraseA);
*};



//									//
//	    NatLangRolePhrase, NatLangConjunctiveAndNounPhrase		//
//									//

//  PURPOSE:  To represent the class of natural language noun phrases that
//	have been labeled by a role.
NatLangRolePhrase
{*
  isA->assertZ(NatLangExpr);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [[natLangRolePhrasesNounA,	Idea],
	       [natLangExprsPhraseRoleA,	NatLangPhraseRole],
	       [nounPhrasesPersonA,		NatLangPerson],
	       [nounPhrasesPluralityA,		NatLangPlurality],
	       [isNatLangExprPhraseTheTopicA,	Boolean],
	       [natLangRolePhrasesDescriptorA,	Idea],
	       [natLangRolePhrasesDescriptorA,	Idea]
	      ],
	      [[isNatLangExprPhraseTheTopicA,	false]
	      ]
	    *]
	);
*};
//  NatLangRolePhrase


//  PURPOSE:  To represent a noun phrase that is the conjunction of two or more
//	distinct noun phrases
NatLangConjunctiveAndNounPhrase
{*
  isA->assertZ(NatLangRolePhrase);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [[natLangRolePhrasesNounA,	Idea],
	       [natLangRolePhrasesNounA,	Idea],
	       [natLangExprsPhraseRoleA,	NatLangPhraseRole],
	       [nounPhrasesPersonA,		NatLangPerson],
	       [nounPhrasesPluralityA,		NatLangPlurality],
	       [isNatLangExprPhraseTheTopicA,	Boolean],
	       [natLangRolePhrasesDescriptorA,	Idea]
	      ]
	    *]
	);
*};


final	theSpRunSubject
{*
  instanceOf->assertZ(NatLangRolePhrase);
  natLangRolePhrasesNounA->assertZ(theSpRun);
  natLangExprsPhraseRoleA->assertZ(subjectNatLangPhraseRole);
  nounPhrasesPersonA->assertZ(thirdPerson);
  nounPhrasesPluralityA->assertZ(singularPlurality);
  isNatLangExprPhraseTheTopicA->assertZ(true);
*};


//  PURPOSE:  To represent the class of attribute over 'NatLangRolePhrase'
//	instances.
NatLangRolePhraseA
{*
  isA->assertZ(NatLangRelatedA);
*};

//  PURPOSE:  To map from instances of 'NatLangRolePhrase' to the one (for
//	just 'NatLangRolePhrase') or several (for
//	'NatLangConjunctiveAndNounPhrase') nouns being including.
natLangRolePhrasesNounA
{*
  instanceOf->assertZ(NatLangRolePhraseA);
*};

//  PURPOSE:  To map from instances of 'NatLangRolePhrase' to zero or more
//	adjectives and 'NatLangParameterizedDescriptorPhrase' (e.g. descriptive
//	prepositional phrases and sentence fragments) that describe the noun
//	of 'this' noun phrase.
natLangRolePhrasesDescriptorA
{*
  instanceOf->assertZ(NatLangRolePhraseA);
*};


//									//
//	NatLangSentence, NatLangInterrogativeSentence,			//
//	NatLangImperativeSentence, NatLangExclamatorySentence,		//
//	NatLangDeclarativeSentence 					//
//									//

//  PURPOSE:  To represent the class of natural language sentences
NatLangSentence
{*
  isA->assertZ(NatLangExpr);
*};


//  PURPOSE:  To map from an 'NatLangSentence' instance to its verb term.
natLangSentencesVerbA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(NatLangVerbTerm);
*};


//  PURPOSE:  To map from an 'NatLangSentence' instance to the tense of its verb
//	term.
natLangSentencesTenseA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(NatLangTense);
*};


//  PURPOSE:  To map from an 'NatLangSentence' instance to its
//	'NatLangAffirmNegateStatus' value that tells whether the sentence is
//	affirmed, negated, or unknown.
natLangSentencesAffirmNegateStatusA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(NatLangAffirmNegateStatus);
*};


//  PURPOSE:  To map from an 'NatLangSentence' instance to the datastructure of
//	role-labeled phrases (other than its verb) that it includes.
natLangSentencesPhraseDSA
{*
  instanceOf->assertZ(NatLangRelatedA);
  attrsIsSingleValuedA->assertA(true);
  attrsRangeA->assertA(List);
*};


//  PURPOSE:  To represent the class of natural language sentences for
//	questions.
NatLangInterrogativeSentence
{*
  isA->assertZ(NatLangSentence);
*};


//  PURPOSE:  To represent the class of natural language sentences for
//	commands.
NatLangImperativeSentence
{*
  isA->assertZ(NatLangSentence);
*};


//  PURPOSE:  To represent the class of natural language sentences for
//	exclamations.
NatLangExclamatorySentence
{*
  isA->assertZ(NatLangSentence);
*};


//  PURPOSE:  To represent the class of natural language sentences for
//	declarations of thoughts.
NatLangDeclarativeSentence
{*
  isA->assertZ(NatLangSentence);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [[natLangSentencesVerbA,		NatLangVerbTerm],
	       [natLangSentencesTenseA,		NatLangTense],
	       [natLangSentencesAffirmNegateStatusA,NatLangAffirmNegateStatus],
	       [natLangSentencesPhraseDSA,	DataStructure],
	       [natLangExprsPhraseRoleA,	NatLangPhraseRole]
	      ]
	    *]
	);

  //  PURPOSE:  To generate and return a string for the representation of
  //	'@this' in thisSE's currently defined natural language
  //	(attr 'spEnvsNatLangFncA') given thisSE's currently defined natural
  //	language formality (attr 'spEnvsNatLangFormalityA').  No parameters.
  sub toNatLang String
  [*
    [],

    ^Do
    [*[
      ^VarDecl[* @langFnc,Idea *],
      ^VarDecl[* @formality,NatLangFormality *],
      ^VarDecl[* @interTermInfoFnc,Idea *],
      ^VarDecl[* @interTermInfo,InterTermGrammarInfo *],

      @langFnc	 	:= thisSE->get(spEnvsNatLangFncA),
      @formality	:= thisSE->get(spEnvsNatLangFormalityA),
      @interTermInfoFnc	:= @langFnc->
			   get(languageFamilysInterTermGrammarMakingFncFamilyA),

      ^If
      [*
	@interTermInfoFnc =ref null,
	@interTermInfoFnc := makeInterTermGrammarInfo_indoEuropean
      *],

      @interTermInfo := @this->@interTermInfoFnc(@langFnc,@formality),
      ^Return[* @this->@langFnc(@interTermInfo,@langFnc) *]

    ]*]
  *];
  // toNatLang

*};
//  NatLangDeclarativeSentence



//									//
//	NatLangTerm, NatLangVerbTerm, NatLangNounTerm,			//
//	NatLangAdjectiveTerm, NatLangConjunctionTerm,			//
//	NatLangParameterizedDescriptorTerm: 				//
//									//

NatLangTerm
{*
  isA->assertZ(NatLangExpr);

  mayBeDestroyedA->subAssert(false);
*};


//  PURPOSE:  To represent the class of verb terms.
NatLangVerbTerm
{*
  isA->assertZ(NatLangTerm);
*};


//  PURPOSE:  Individual verb terms.
toExist			{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeAs			{* instanceOf->assertZ(NatLangVerbTerm); *};
toOwn			{* instanceOf->assertZ(NatLangVerbTerm); *};
toBelongTo		{* instanceOf->assertZ(NatLangVerbTerm); *};
toHaveTheProperty	{* instanceOf->assertZ(NatLangVerbTerm); *};
toHappen		{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeAbleTo		{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeAllowed		{* instanceOf->assertZ(NatLangVerbTerm); *};
toMust			{* instanceOf->assertZ(NatLangVerbTerm); *};
toKnow			{* instanceOf->assertZ(NatLangVerbTerm); *};
toRecognize		{* instanceOf->assertZ(NatLangVerbTerm); *};
toAttempt		{* instanceOf->assertZ(NatLangVerbTerm); *};
toRedo			{* instanceOf->assertZ(NatLangVerbTerm); *};
toSucceed		{* instanceOf->assertZ(NatLangVerbTerm); *};
toFail			{* instanceOf->assertZ(NatLangVerbTerm); *};
toUse			{* instanceOf->assertZ(NatLangVerbTerm); *};
toModify		{* instanceOf->assertZ(NatLangVerbTerm); *};
toAssert		{* instanceOf->assertZ(NatLangVerbTerm); *};
toDeclareAVarOrFnc	{* instanceOf->assertZ(NatLangVerbTerm); *};
toQuantifyTheScopeOf	{* instanceOf->assertZ(NatLangVerbTerm); *};
toDefine		{* instanceOf->assertZ(NatLangVerbTerm); *};
toAssignAValueTo	{* instanceOf->assertZ(NatLangVerbTerm); *};
toLookFor		{* instanceOf->assertZ(NatLangVerbTerm); *};
toFind			{* instanceOf->assertZ(NatLangVerbTerm); *};
toQuery			{* instanceOf->assertZ(NatLangVerbTerm); *};
toSort			{* instanceOf->assertZ(NatLangVerbTerm); *};
toCompile		{* instanceOf->assertZ(NatLangVerbTerm); *};
toCompute		{* instanceOf->assertZ(NatLangVerbTerm); *};
toParse			{* instanceOf->assertZ(NatLangVerbTerm); *};
toOpen			{* instanceOf->assertZ(NatLangVerbTerm); *};
toClose			{* instanceOf->assertZ(NatLangVerbTerm); *};
toRead			{* instanceOf->assertZ(NatLangVerbTerm); *};
toWrite			{* instanceOf->assertZ(NatLangVerbTerm); *};
toFlush			{* instanceOf->assertZ(NatLangVerbTerm); *};
toInsert		{* instanceOf->assertZ(NatLangVerbTerm); *};
toRemove		{* instanceOf->assertZ(NatLangVerbTerm); *};
toAdd			{* instanceOf->assertZ(NatLangVerbTerm); *};
toSubtract		{* instanceOf->assertZ(NatLangVerbTerm); *};
toMultiply		{* instanceOf->assertZ(NatLangVerbTerm); *};
toDivide		{* instanceOf->assertZ(NatLangVerbTerm); *};
toRaiseToAPower		{* instanceOf->assertZ(NatLangVerbTerm); *};
toThrow			{* instanceOf->assertZ(NatLangVerbTerm); *};
toStart			{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeInTheActOf		{* instanceOf->assertZ(NatLangVerbTerm); *};
toInterrupt		{* instanceOf->assertZ(NatLangVerbTerm); *};
toContinue		{* instanceOf->assertZ(NatLangVerbTerm); *};
toStop			{* instanceOf->assertZ(NatLangVerbTerm); *};
toFinish		{* instanceOf->assertZ(NatLangVerbTerm); *};
toExpect		{* instanceOf->assertZ(NatLangVerbTerm); *};
toNeed			{* instanceOf->assertZ(NatLangVerbTerm); *};
toLack			{* instanceOf->assertZ(NatLangVerbTerm); *};
toName			{* instanceOf->assertZ(NatLangVerbTerm); *};
toNumber		{* instanceOf->assertZ(NatLangVerbTerm); *};
toMatch			{* instanceOf->assertZ(NatLangVerbTerm); *};
toRun			{* instanceOf->assertZ(NatLangVerbTerm); *};
toImplement		{* instanceOf->assertZ(NatLangVerbTerm); *};
toEncounter		{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeDescribedBy		{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeOwnedBy		{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeIn			{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeOut			{* instanceOf->assertZ(NatLangVerbTerm); *};
toBeReserved		{* instanceOf->assertZ(NatLangVerbTerm); *};
toConvert		{* instanceOf->assertZ(NatLangVerbTerm); *};
toRegister		{* instanceOf->assertZ(NatLangVerbTerm); *};
toViolate		{* instanceOf->assertZ(NatLangVerbTerm); *};



/?
 ?			NatLangNounTerm related:
 ?/

//  PURPOSE:  To represent the class of nouns, noun terms and pronouns.
NatLangNounTerm
{*
  isA->assertZ(NatLangTerm);
  isA->assertZ(NatLangRolePhrase);

  natLangRolePhrasesNounA->subAssertZ(theSubject);
  nounPhrasesPluralityA->subAssert(singularPlurality);
  nounPhrasesPersonA->subAssert(thirdPerson);
*};
//  NatLangNounTerm


//  PURPOSE:  To represent the class of attributes over 'NatLangNounTerm'
//	instances.
NatLangNounTermA
{*
  isA->assertZ(NatLangRelatedA);
*};

//  PURPOSE:  To map from 'NatLangNounTerm' instances to the plurality of the
//	term.
nounPhrasesPluralityA
{*
  instanceOf->assertZ(NatLangNounTermA);
*};

//  PURPOSE:  To map from 'NatLangNounTerm' instances to the plurality of the
//	"person" (i.e. 1st, 2nd or 3rd) of the term.
nounPhrasesPersonA
{*
  instanceOf->assertZ(NatLangNounTermA);
*};

//  PURPOSE:  To map from 'NatLangNounTerm' instances to the gender.
nounPhrasesGenderA
{*
  instanceOf->assertZ(NatLangNounTermA);
*};

//  PURPOSE:  Individual noun terms.
theLastRequestedComputation
			{* instanceOf->assertZ(NatLangNounTerm); *};
theUser
{*
  instanceOf->assertZ(NatLangNounTerm);
  nounPhrasesPersonA->subAssert(secondPerson);
*};

theSomProgrammers
{*
  instanceOf->assertZ(NatLangNounTerm);
  nounPhrasesPluralityA->assert(moreThanOnePlurality);
*};

theKnowledgeBase	{* instanceOf->assertZ(NatLangNounTerm); *};
theSpProgram		{* instanceOf->assertZ(NatLangNounTerm); *};
theSpRun		{* instanceOf->assertZ(NatLangNounTerm); *};
theComputer		{* instanceOf->assertZ(NatLangNounTerm); *};
theNetworkedComputingSystem
			{* instanceOf->assertZ(NatLangNounTerm); *};
theInternet		{* instanceOf->assertZ(NatLangNounTerm); *};
aQuery			{* instanceOf->assertZ(NatLangNounTerm); *};
anAnswer		{* instanceOf->assertZ(NatLangNounTerm); *};
aSubject		{* instanceOf->assertZ(NatLangNounTerm); *};
anAttribute		{* instanceOf->assertZ(NatLangNounTerm); *};
anExpression		{* instanceOf->assertZ(NatLangNounTerm); *};
aNonannotatedValue	{* instanceOf->assertZ(NatLangNounTerm); *};
anAnnotatedValue	{* instanceOf->assertZ(NatLangNounTerm); *};
aValue			{* instanceOf->assertZ(NatLangNounTerm); *};
anIndex			{* instanceOf->assertZ(NatLangNounTerm); *};
aKey			{* instanceOf->assertZ(NatLangNounTerm); *};
aConstant		{* instanceOf->assertZ(NatLangNounTerm); *};
aVariable		{* instanceOf->assertZ(NatLangNounTerm); *};
aSelfVariable		{* instanceOf->assertZ(NatLangNounTerm); *};
aDivisor		{* instanceOf->assertZ(NatLangNounTerm); *};
aMathematicalPower	{* instanceOf->assertZ(NatLangNounTerm); *};
anIdea			{* instanceOf->assertZ(NatLangNounTerm); *};
aClass			{* instanceOf->assertZ(NatLangNounTerm); *};
aSubclass		{* instanceOf->assertZ(NatLangNounTerm); *};
aSuperclass		{* instanceOf->assertZ(NatLangNounTerm); *};
anInstance		{* instanceOf->assertZ(NatLangNounTerm); *};
aBooleanValue		{* instanceOf->assertZ(NatLangNounTerm); *};
aNumber			{* instanceOf->assertZ(NatLangNounTerm); *};
anInteger		{* instanceOf->assertZ(NatLangNounTerm); *};
aRationalNumber		{* instanceOf->assertZ(NatLangNounTerm); *};
aFloatingPointNumber	{* instanceOf->assertZ(NatLangNounTerm); *};
unicodeByteSequence	{* instanceOf->assertZ(NatLangNounTerm); *};
aCharacterString	{* instanceOf->assertZ(NatLangNounTerm); *};
aCharacter		{* instanceOf->assertZ(NatLangNounTerm); *};
aNextLineChar		{* instanceOf->assertZ(NatLangNounTerm); *};
aHexadecimalDigit	{* instanceOf->assertZ(NatLangNounTerm); *};
aDecimalDigit		{* instanceOf->assertZ(NatLangNounTerm); *};
anIdeasHexadecimalValue	{* instanceOf->assertZ(NatLangNounTerm); *};
anIterator		{* instanceOf->assertZ(NatLangNounTerm); *};
aDataStructure		{* instanceOf->assertZ(NatLangNounTerm); *};
aNode			{* instanceOf->assertZ(NatLangNounTerm); *};
aDomain			{* instanceOf->assertZ(NatLangNounTerm); *};
aRange			{* instanceOf->assertZ(NatLangNounTerm); *};
aBinaryTreeNode		{* instanceOf->assertZ(NatLangNounTerm); *};
aLinearDataStructure	{* instanceOf->assertZ(NatLangNounTerm); *};
aList			{* instanceOf->assertZ(NatLangNounTerm); *};
aVectorList		{* instanceOf->assertZ(NatLangNounTerm); *};
aNodeList		{* instanceOf->assertZ(NatLangNounTerm); *};
aListNode		{* instanceOf->assertZ(NatLangNounTerm); *};
aDataNode		{* instanceOf->assertZ(NatLangNounTerm); *};
aNilNode		{* instanceOf->assertZ(NatLangNounTerm); *};
aStack			{* instanceOf->assertZ(NatLangNounTerm); *};
aQueue			{* instanceOf->assertZ(NatLangNounTerm); *};
anIdentifier		{* instanceOf->assertZ(NatLangNounTerm); *};
aCommand		{* instanceOf->assertZ(NatLangNounTerm); *};
aFunction		{* instanceOf->assertZ(NatLangNounTerm); *};
aConstructor		{* instanceOf->assertZ(NatLangNounTerm); *};
anAnonymousFunction	{* instanceOf->assertZ(NatLangNounTerm); *};
anAnonymousFunctionTemplate
			{* instanceOf->assertZ(NatLangNounTerm); *};
aFunctionCall		{* instanceOf->assertZ(NatLangNounTerm); *};
anOperator		{* instanceOf->assertZ(NatLangNounTerm); *};
aMethodCallSequence	{* instanceOf->assertZ(NatLangNounTerm); *};
aPredicate		{* instanceOf->assertZ(NatLangNounTerm); *};
aPredicateExpression	{* instanceOf->assertZ(NatLangNounTerm); *};
aRule			{* instanceOf->assertZ(NatLangNounTerm); *};
aRulesHeadPredicate	{* instanceOf->assertZ(NatLangNounTerm); *};
aRulesClauseList	{* instanceOf->assertZ(NatLangNounTerm); *};
anAssumptionContext	{* instanceOf->assertZ(NatLangNounTerm); *};
anArgument		{* instanceOf->assertZ(NatLangNounTerm); *};
anOperand		{* instanceOf->assertZ(NatLangNounTerm); *};
aMapping		{* instanceOf->assertZ(NatLangNounTerm); *};
aNaturalLanguage	{* instanceOf->assertZ(NatLangNounTerm); *};
anAssumption		{* instanceOf->assertZ(NatLangNounTerm); *};
anIOProblem		{* instanceOf->assertZ(NatLangNounTerm); *};
aBug			{* instanceOf->assertZ(NatLangNounTerm); *};
aSyntaxError		{* instanceOf->assertZ(NatLangNounTerm); *};
aFile			{* instanceOf->assertZ(NatLangNounTerm); *};
anInputFile		{* instanceOf->assertZ(NatLangNounTerm); *};
anOutputFile		{* instanceOf->assertZ(NatLangNounTerm); *};
aDirectory		{* instanceOf->assertZ(NatLangNounTerm); *};
theEndOfFile		{* instanceOf->assertZ(NatLangNounTerm); *};
ideaType		{* instanceOf->assertZ(NatLangNounTerm); *};
aDescription		{* instanceOf->assertZ(NatLangNounTerm); *};
aPrefix			{* instanceOf->assertZ(NatLangNounTerm); *};
aSuffix			{* instanceOf->assertZ(NatLangNounTerm); *};


//  PURPOSE: To represent the class of adjective terms
NatLangAdjectiveTerm
{*
  isA->assertZ(NatLangTerm);
*};
//  NatLangAdjectiveTerm


//  Individual adjective terms:
nonSpecific	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
immutable	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
singleDistinct	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
setFull		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
redundant	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
nonredundant	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
tooFew		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
tooMany		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
legal		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
illegal		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
expected	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
same		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
different	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
positive	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
negative	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
nonPositive	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
nonNegative	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
executable	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
nonExecutable	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
recognized	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
nonRecognized	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
ordered		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
unordered	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
compatible	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
incompatible	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
usable		{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
unusable	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
contradictory	{* instanceOf->assertZ(NatLangAdjectiveTerm); *};
noncontradictory{* instanceOf->assertZ(NatLangAdjectiveTerm); *};


NatLangConjunctionTerm
{*
  isA->assertZ(NatLangTerm);
*};
and		{* instanceOf->assertZ(NatLangConjunctionTerm); *};
but		{* instanceOf->assertZ(NatLangConjunctionTerm); *};
or		{* instanceOf->assertZ(NatLangConjunctionTerm); *};
andThen		{* instanceOf->assertZ(NatLangConjunctionTerm); *};
because		{* instanceOf->assertZ(NatLangConjunctionTerm); *};
therefore	{* instanceOf->assertZ(NatLangConjunctionTerm); *};


//  PURPOSE:  To represent the class of parameterized descriptors
//	(e.g. what in English would be prepositional phrases)
NatLangParameterizedDescriptorTerm
{*
  isA->assertZ(NatLangTerm);
*};
insteadOf	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
continuationOf	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
asAnArgumentTo	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
thatBelongsTo	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
thatResultedFromTheComputationOf
		{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
insideOf	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
outsideOf	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
atThePositionWithIndex
		{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
toTheFunction	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
between		{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
into		{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
thatServes	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
from		{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
withValue	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
locatedAt	{* instanceOf->assertZ(NatLangParameterizedDescriptorTerm); *};
//  End NatLangParameterizedDescriptorTerm



LanguageFamily
{*
  isA->assertZ(CulturalConvention);
*};

ideasLanguageFamilyA
{*
  instanceOf->assertZ(NatLangRelatedA);
*};



//									//
//			TermsTextA related				//
//									//

//  PURPOSE:  To tell the set that maps from words to their string text terms
//	according as parameterized by a natural language function family
//	(like toEnglish).
TermsTextA
{*
  isA->assertZ(NatLangRelated);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//									//
//			TermsGenderA related				//
//									//

//  PURPOSE:  To tell the set that maps from words to their string text terms
//	according as parameterized by a natural language function family
//	(like toEnglish).
TermsGenderA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangAdjectiveTerm' to a Boolean that
//	tells whether or not that adjective can serve as an article, obviating
//	the need for using an article in addition to the adjective.
DoesAdjectiveServeAsArticleA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 
ShouldNounTermHaveArticleA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangAdjectiveTerm' to a Rational
//	that tells the relative order in which adjectives are expected
//	in conventional English.
AdjectiveOrderA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangNounTerm' to the text of the
//	plural form of that noun, if the plural form is irregular.
NounTermsIrregularPluralA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To be instantiated by 'LanguageFamily' instances  into an
//	attribute that maps from 'NatLangAdjectiveTerm' instances to 'true'
//	if the adjective comes before the noun or 'false' otherwise.
DoesAdjComeBeforeNounA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To be instantiated by 'LanguageFamily' instances  into an
//	attribute that maps from 'NatLangVerbTerm' instances to 'true'
//	if the verb is reflexive or 'false' otherwise.
IsVerbReflexiveA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};



//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to either 'true' if
//	that verb term should really conjugate the English verb "to be", or
//	false otherwise (it should just be conjugated itself).
DoesVerbUseToBeA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to either 'true' if
//	that verb term should really conjugate the English verb "to have", or
//	false otherwise (it should just be conjugated itself).
DoesVerbUseToHaveA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};



//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to either a string
//	telling the letter to add between the base form of the verb and the
//	"-ed" or "-ing" ending, or to 'null' when no such string exists.  A
//	case where it does exist in with the verb 'toProgram'.  This attribute
//	specified the "M", as when constructing "programMing" and "programMed".
VerbTermsEndingBeforePastTenseAndGerundA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to the text of the
//	simple past form in English, if that form is irregular.  This form is
//	to be use with .
VerbTermsIrregularPastSimpleTenseA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to the text of the
//	simple past form in English, if that form is irregular.
VerbTermsIrregularPastContinuousTenseA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to the text of the
//	past perfect form in English, if that form is irregular.
VerbTermsIrregularPastPerfectTenseA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to the text of the
//	present perfect form in English, if that form is irregular.
VerbTermsIrregularPresentPerfectTenseA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};


//  PURPOSE:  To map from instances of 'NatLangVerbTerm' to either a string
//	to be appended after the verb has been conjugated, or to 'null' when
//	no such string exists.  A case where it does exist is with the verb
//	'toDivide'.  The proper text form of the verb ought to be "divide by",
//	where " by" is appended once 'toDivide' has been conjugated.
VerbTermsPostpositionTextA
{*
  isA->assertZ(NatLangRelatedA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	       [ [ideasLanguageFamilyA, LanguageFamily]
	       ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};




//									//
//			InterTermGrammarInfo				//
//									//

//  PURPOSE:  To hold inter-term information used to construct a natural
//	language string from a NatLangExpr instance.
InterTermGrammarInfo
{*
  isA->assertZ(NatLangRelated);

  mayBeDestroyedA->subAssert(true);
*};
//  InterTermGrammarInfo


//  PURPOSE:  To hold inter-term information used to construct an IndoEuropean
//	natural language string from a NatLangExpr instance.
IndoEuropeanInterTermGrammarInfo
{*
  isA->assertZ(InterTermGrammarInfo);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [ [nounPhrasesGenderA,		NatLangGender],
		[nounPhrasesPersonA,		NatLangPerson],
	      	[nounPhrasesPluralityA,		NatLangPlurality],
		[natLangSentencesTenseA,	NatLangTense],
		[natLangSentencesAffirmNegateStatusA,
						NatLangAffirmNegateStatus]
	      ]
	    *]
	);
*};
//  IndoEuropeanInterTermGrammarInfo
/? --- end of file --- ?/


thisSE->parseFile("knowledgebases/standard/toEnglish.som8");
//
//	Definition of English
//

thisSE
{*
  spEnvsNatLangFncA	 ->assertZ(toEnglish);
  spEnvsNatLangFormalityA->assert(formalNatLangFormality);
*};

toEnglish
{*
  instanceOf->assertZ(LanguageFamily);
  languageFamilysInterTermGrammarMakingFncFamilyA->
		assert(makeInterTermGrammarInfo_english);
*};


//									//
//			        NatLangExpr				//
//									//

//  PURPOSE:  To represent the set of natural language expressions.
NatLangExpr
{*

  //  PURPOSE:  To compute and return an instance of
  //	'IndoEuropeanInterTermGrammarInfo' that contains inter-term info
  //	
  sub makeInterTermGrammarInfo_english InterTermGrammarInfo
  [*

    [ [@langFnc,	Idea],
      [@formality,	NatLangFormality]
    ],

    ^Do
    [*[
      ^VarDecl[* @phraseDS,DataStructure *],
      ^VarDecl[* @iter,Iterator *],
      ^VarDecl[* @temp, NatLangExpr *],
      ^VarDecl[* @subj,NatLangExpr *],
      ^VarDecl[* @person, NatLangPerson *],
      ^VarDecl[* @plurality, NatLangPlurality *],
      @phraseDS := @this->get(natLangSentencesPhraseDSA),

      //  Look for subject
      ^For
      [*
        @iter	:= @phraseDS->dataStruct_iter(),

	!@iter->iter_isAtEnd(),

	^If
	[*
	  ^Do
	  [*[
	    @temp := @iter->iter_value(),
	    @temp->get(natLangExprsPhraseRoleA) =ref subjectNatLangPhraseRole
	  ]*],

	  ^Do[*[   @subj := @temp,  ^Break  ]*]
	*],

	@iter->iter_advance()
      *],


      //  Assign '@person' and '@plurality' from @subj (if it was found)
      //  or use default values (if not subject was found)
      ^If
      [*
	@subj =ref null,
	^Do
	[*[
	  @person	:= thirdPerson,
	  @plurality	:= singularPlurality
	]*],
	^Do
	[*[
	  @person	:= @subj->get(nounPhrasesPersonA),
	  @plurality	:= @subj->get(nounPhrasesPluralityA)
	]*]
      *],

      //  Create and return grammar info:
      ^Return
      [*
        ^^IndoEuropeanInterTermGrammarInfo
	[*
	  neuterNatLangGender,
	  	// English is gender-poor relative to other IndoEuropean langs
	  @person,
	  @plurality,
	  @this->get(natLangSentencesTenseA),
	  @this->get(natLangSentencesAffirmNegateStatusA)
	*]
      *]
    ]*]
  *];
  // makeInterTermGrammarInfo_english


  sub makeInterTermGrammarInfo_indoEuropean InterTermGrammarInfo
  [*
    [
      [@langFnc,  Idea],
      [@formality,NatLangFormality]
    ],

    ^Do
    [*[
      ^VarDecl[* @phraseDS,DataStructure *],
      ^VarDecl[* @iter,Iterator *],
      ^VarDecl[* @temp, NatLangExpr *],
      ^VarDecl[* @subj,NatLangExpr *],
      ^VarDecl[* @person, NatLangPerson *],
      ^VarDecl[* @plurality, NatLangPlurality *],
      @phraseDS := @this->get(natLangSentencesPhraseDSA),

      ^For
      [*
        @iter	:= @phraseDS->dataStruct_iter(),

	!@iter->iter_isAtEnd(),

	^If
	[*
	  ^Do
	  [*[
	    @temp := @iter->iter_value(),
	    @temp->get(natLangExprsPhraseRoleA) =ref subjectNatLangPhraseRole
	  ]*],

	  ^Do[*[   @subj := @temp,  ^Break  ]*]
	*],

	@iter->iter_advance()
      *],

      ^If
      [*
	@subj =ref null,
	^Do
	[*[
	  @person	:= thirdPerson,
	  @plurality	:= singularPlurality
	]*],
	^Do
	[*[
	  @person	:= @subj->get(nounPhrasesPersonA),
	  @plurality	:= @subj->get(nounPhrasesPluralityA)
	]*]
      *],

      ^Return
      [*
        ^^IndoEuropeanInterTermGrammarInfo
	[*
	  neuterNatLangGender,
	  	// English is gender-poor relative to other IndoEuropean langs
	  @person,
	  @plurality,
	  @this->get(natLangSentencesTenseA),
	  @this->get(natLangSentencesAffirmNegateStatusA)
	*]
      *]
    ]*]
  *];
  // makeInterTermGrammarInfo_indoEuropean

*};
//  NatLangExpr



//									//
//		NatLangParameterizedDescriptorPhrase			//
//									//

NatLangParameterizedDescriptorPhrase
{*

  //  PURPOSE:  To generate and return a string for the English representation
  //	of '@this' given the grammatical info in '@interTermInfo'.
  sub toEnglish	String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea]
    ],

    ^Do
    [*[
      //  I.  Applicability validity check:

      //  II.  Compute text:
      //  II.A.  Get preposition:
      ^VarDecl[* @prepText,String *],
      ^VarDecl[* @phrase, NatLangParameterizedDescriptorPhrase *],

      @phrase := @this,
      @prepText := 
        @this->localGet(natLangParameterizedDescriptorPhrasesDescriptorA)->
			localGet(^TermsTextA[*toEnglish*]),

      //  II.B.  Get preposition's object:
      ^VarDecl[* @obj,Idea *],
      ^VarDecl[* @objText,String *],

      @obj := @this->localGet(natLangParameterizedDescriptorPhrasesArgA),

      ^If
      [*
	@obj->isInstanceOf(String),
	@objText := @obj,
	^If
	[*
	  @obj->isInstanceOf(NatLangTerm),
	  @objText := @obj->localGet(^TermsTextA[*toEnglish*]),
	  @objText := @obj->toEnglish(@interTermInfo,@this)
	*]
      *],

      ^Return[* @prepText +con " " +con @objText *]

    ]*]

  *];
  // toEnglish

*};
//  NatLangParameterizedDescriptorPhrase



//									//
//	    NatLangRolePhrase, NatLangConjunctiveAndNounPhrase		//
//									//

//  PURPOSE:  To represent the set of natural language noun phrases.
NatLangRolePhrase
{*

  //  PURPOSE:  To generate and return a string for the English representation
  //	of '@this' noun phrase given the grammatical info in '@interTermInfo'.
  sub toEnglish	String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compose text:
      ^VarDecl[* @toReturn, String *],
      ^VarDecl[* @nounTerm, Idea *],
      ^VarDecl[* @isProperNoun, Boolean *],
      @toReturn		:= "",
      @nounTerm	 	:= @this->get(natLangRolePhrasesNounA),
      @isProperNoun	:= !@nounTerm->isInstanceOf(NatLangNounTerm),

      //  II.A.  Gather descriptors into adjectives (coming before the noun)
      //  	 and anything else (coming after):
      ^VarDecl[* @adjectiveList, VectorList *],
      ^VarDecl[* @nonAdjDescriptorList, VectorList *],
      ^VarDecl[* @descriptorIter, Iterator *],
      ^VarDecl[* @descriptor,  CulturalConvention *],
      ^VarDecl[* @hasArticleBeenGiven, Boolean *],

      @adjectiveList		:= ^^VectorList[* *],
      @nonAdjDescriptorList	:= ^^VectorList[* *],
      @hasArticleBeenGiven	:= false,

      ^For
      [*
	@descriptorIter := @this->prop_iter(natLangRolePhrasesDescriptorA),

	!@descriptorIter->iter_isAtEnd(),

	^Do
	[*[
	  @descriptor	:= @descriptorIter->iter_value(),

	  ^If
	  [*
	    @descriptor->isInstanceOf(NatLangAdjectiveTerm),

	    ^Do
	    [*[
	      @adjectiveList->dataStruct_insert(@descriptor),

	      ^If
	      [*
		( !@hasArticleBeenGiven					&&
		  @descriptor->get(^DoesAdjectiveServeAsArticleA[*toEnglish*])
		),
		@hasArticleBeenGiven	:= true
	      *]
	    ]*],

	    @nonAdjDescriptorList->dataStruct_insert(@descriptor)
	  *]
	]*],

	@descriptorIter->iter_advance()
      *],


      //  II.B.  Compose adjective text:
      //  II.B.1.  If '@adjectiveList' has adjectives then:
      //  	   (1) sort them by their expected order in English, and
      //	   (2) generate text of adjectives in '@adjectiveList':
      ^If
      [*
	!@adjectiveList->dataStruct_isEmpty(),

	^Do
	[*[
	  //  II.B.2.a.  Sort adjectives by their expected order in English:
	  @adjectiveList->
		list_sort(ascendingOrder,^AdjectiveOrderA[*toEnglish*]),

	  //  II.B.2.b.  Generate text of adjectives in '@adjectiveList':
	  ^For
	  [*
	    @descriptorIter	:= @adjectiveList->dataStruct_iter(),

	    !@descriptorIter->iter_isAtEnd(),

	    @toReturn :=
	      @toReturn
	      +con @descriptorIter->iter_value()->get(^TermsTextA[*toEnglish*])
	      +con ", ",

	    @descriptorIter->iter_advance()
	  *],

	  @toReturn := @toReturn -unc ~", " +con " "
	]*]

      *],


      //  II.C.  Compose noun term text:
      ^VarDecl[* @nounText, String *],

      ^If
      [*
	@isProperNoun,
	@nounText := @nounTerm->toString(),
        @nounText := @nounTerm->get(^TermsTextA[*toEnglish*])
      *],

      ^If
      [*
        ( !@isProperNoun						&&
	  @this->get(nounPhrasesPluralityA) !=ref singularPlurality
	),

	@nounText :=
		^Do
		[*[
		  ^VarDecl[* @irregularPlural, Idea *],

		  @irregularPlural :=
		  	@nounTerm->get(^NounTermsIrregularPluralA[*toEnglish*]),

		  ^If
		  [*
		    @irregularPlural =ref null,
		    ^If
		    [*
		      @nounText->string_hasSuffix("s"),
		      @nounText +con "es",
		      ^If
		      [*
		        @nounText->string_hasSuffix("y"),
		        @nounText -unc ~"y" +con "ies",
		        @nounText +con "s"
		      *]
		    *],
		    @irregularPlural
		  *]
		]*]
      *],

      @toReturn := @toReturn +con @nounText,

      //  II.D.  Compose article text (if should):
      ^If
      [*
	!@isProperNoun && !@hasArticleBeenGiven,

	@toReturn :=
	  ^Test
	  [*
	    @this->get(nounPhrasesPluralityA),

	    [
	      [ '=ref, zeroPlurality, "no "],
	      [ '=ref, moreThanZeroPlurality, "at least one "],
	      [ '=ref, singularPlurality,
	        ^If
		[*
		  @this->get(isNatLangExprPhraseTheTopicA) =ref true,
		  "the ",
		  ^If
		  [*
		    {"a","A","e","E","i","I","o","O","u","U"}->
			dataStruct_doesHave(@toReturn->string_prefix(1)),
		    "an ",
		    "a "
		  *]
		*]
	      ],
	      [ '=ref, moreThanOnePlurality,
		^If
		[*
		  @this->get(isNatLangExprPhraseTheTopicA) =ref true,
		  "these ",
		  "some "
		*]
	      ],
	      [ '=ref, fewPlurality,
		^If
		[*
		  @this->get(isNatLangExprPhraseTheTopicA) =ref true,
		  "these few ",
		  "a few "
		*]
	      ],
	      [ '=ref, manyPlurality,
		^If
		[*
		  @this->get(isNatLangExprPhraseTheTopicA) =ref true,
		  "these many ",
		  "a lot "
		*]
	      ]
	    ]
	  *]
	  +con					@toReturn

      *],

      //  II.E.  Compose prepositional and descriptive
      //  	 sentence fragment phrase text:
      ^If
      [*
	!@nonAdjDescriptorList->dataStruct_isEmpty(),

	^For
	[*
	  @descriptorIter	:= @nonAdjDescriptorList->dataStruct_iter(),

	  !@descriptorIter->iter_isAtEnd(),

	  ^Do
	  [*[
	    @descriptor	:= @descriptorIter->iter_value(),

	    ^If
	    [*
	      @descriptor->isInstanceOf(NatLangDeclarativeSentence),
	      @toReturn	:=
		@toReturn					+con
		" that"						+con
		@descriptor->toEnglish(@interTermInfo,@this),

	      ^If
	      [*
		@descriptor->isInstanceOf(NatLangRolePhrase),
		@toReturn	:=
		    @toReturn					+con
		    " of "					+con
		    @descriptor->toEnglish(@interTermInfo,@this),
		@toReturn	:=
		    @toReturn					+con
		    " "						+con
		    @descriptor->toEnglish(@interTermInfo,@this)
	      *]
	    *]
	  ]*],

	  @descriptorIter->iter_advance()
	*]

      *],

      //  II.F.  Capitalize if should:
      ^If
      [*
	( !@isProperNoun						&& 
	  (@this->get(natLangExprsPhraseRoleA) =ref subjectNatLangPhraseRole)
	),
	@toReturn := @toReturn->string_capitalize()
      *],

      //  III.  Finished:
      ^Return[* @toReturn *]
    ]*]
  *];
  //  toEnglish


*};
//  NatLangRolePhrase


NatLangConjunctiveAndNounPhrase
{*
  //  PURPOSE:  To generate and return a string for the English representation
  //	of '@this' noun phrase given the grammatical info in '@interTermInfo'.
  sub toEnglish	String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compose text:
      ^VarDecl[* @toReturn, String *],
      @toReturn		:= "",

      //  II.A.  Gather descriptors into adjectives (coming before the noun)
      //  	 and anything else (coming after):
      ^VarDecl[* @adjectiveList, VectorList *],
      ^VarDecl[* @nonAdjDescriptorList, VectorList *],
      ^VarDecl[* @descriptorIter, Iterator *],
      ^VarDecl[* @descriptor,	    CulturalConvention *],
      ^VarDecl[* @hasArticleBeenGiven, Boolean *],

      @adjectiveList		:= ^^VectorList[* *],
      @nonAdjDescriptorList	:= ^^VectorList[* *],
      @hasArticleBeenGiven	:= false,

      ^For
      [*
	@descriptorIter := @this->prop_iter(natLangRolePhrasesDescriptorA),

	!@descriptorIter->iter_isAtEnd(),

	^Do
	[*[
	  @descriptor	:= @descriptorIter->iter_value(),

	  ^If
	  [*
	    @descriptor->isInstanceOf(NatLangAdjectiveTerm),

	    ^Do
	    [*[
	      @adjectiveList->dataStruct_insert(@descriptor),

	      ^If
	      [*
		( !@hasArticleBeenGiven					&&
		  @descriptor->get(^DoesAdjectiveServeAsArticleA[*toEnglish*])
		),
		@hasArticleBeenGiven	:= true
	      *]
	    ]*],

	    @nonAdjDescriptorList->dataStruct_insert(@descriptor)
	  *]
	]*],

	@descriptorIter->iter_advance()
      *],


      //  II.B.  Compose adjective text:
      //  II.B.1.  If '@adjectiveList' has adjectives then:
      //  	   (1) sort them by their expected order in English, and
      //	   (2) generate text of adjectives in '@adjectiveList':
      ^If
      [*
	!@adjectiveList->dataStruct_isEmpty(),

	^Do
	[*[
	  //  II.B.2.a.  Sort adjectives by their expected order in English:
	  @adjectiveList->
		list_sort(ascendingOrder,^AdjectiveOrderA[*toEnglish*]),

	  //  II.B.2.b.  Generate text of adjectives in '@adjectiveList':
	  ^For
	  [*
	    @descriptorIter	:= @adjectiveList->dataStruct_iter(),

	    !@descriptorIter->iter_isAtEnd(),

	    @toReturn :=
	      @toReturn
	      +con @descriptorIter->iter_value()->get(^TermsTextA[*toEnglish*])
	      +con ", ",

	    @descriptorIter->iter_advance()
	  *],

	  @toReturn := @toReturn -unc ~", " +con " "
	]*]

      *],


      //  II.C.  Compose noun term text:
      ^VarDecl[* @nounPhraseIter, Iterator *],
      ^VarDecl[* @isFirstIteration, Boolean *],

      @isFirstIteration	:= true,

      ^For
      [*
	@nounPhraseIter	:= @this->prop_iter(natLangRolePhrasesNounA),

       !@nounPhraseIter->iter_isAtEnd(),

	^Do
	[*[

	  ^If
	  [*
	    @isFirstIteration,
	    @isFirstIteration := false,
	    @toReturn	      := @toReturn +con " and "
	  *],

	  ^VarDecl[* @noun, Idea *],

	  @noun		:= @nounPhraseIter->iter_value(),
	  @toReturn	:=  @toReturn				+con
			    ^If
			    [*
			      @noun->isInstanceOf(NatLangNounTerm),
	      		      @noun->toEnglish(@interTermInfo,@this),
			      @noun->toString()
			    *]
	]*],

	@nounPhraseIter->iter_advance()
      *],


      //  II.D.  Compose prepositional and descriptive
      //  	 sentence fragment phrase text:
      ^If
      [*
	!@nonAdjDescriptorList->dataStruct_isEmpty(),

	^For
	[*
	  @descriptorIter	:= @nonAdjDescriptorList->dataStruct_iter(),

	  !@descriptorIter->iter_isAtEnd(),

	  ^Do
	  [*[
	    @descriptor	:= @descriptorIter->iter_value(),

	    ^If
	    [*
	      @descriptor->isInstanceOf(NatLangDeclarativeSentence),
	      @toReturn	:=
		@toReturn					+con
		" that"						+con
		@descriptor->toEnglish(@interTermInfo,@this),
	      @toReturn	:=
		@toReturn					+con
		" "						+con
		@descriptor->toEnglish(@interTermInfo,@this)
	    *]
	  ]*],

	  @descriptorIter->iter_advance()
	*]

      *],


      //  II.E.  Capitalize if should:

      //  III.  Finished:
      ^Return[* @toReturn *]
    ]*]
  *];
  //  toEnglish


*};
//  NatLangConjunctiveAndNounPhrase


//									//
//	NatLangSentence, NatLangInterrogativeSentence,			//
//	NatLangImperativeSentence, NatLangExclamatorySentence,		//
//	NatLangDeclarativeSentence 					//
//									//

NatLangDeclarativeSentence
{*

  //  PURPOSE:  To return the conjugation of verb @verb with infinitive
  //	@verbString, text @neg with negation-telling text (or "" if not
  //	negated) and @pp telling the person and plurality.  @verb should uses
  //	"to be".
  sub toEnglish_predicate_verbConjugate_toBe String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea],
      [@verb,	       NatLangVerbTerm],
      [@verbString,    String],
      [@neg,	       String],
      [@pp,	       NatLangPersonPlurality]
    ],

    ^Do
    [*[
      // Conjugate the verb "to be" and append @verbString
      ^Test
      [*
	@this->get(natLangSentencesTenseA),

	[ //  inGeneralPastNatLangTense
	  //  (e.g. "(I) was ~/was not ~.")
	  [ '=ref, inGeneralPastNatLangTense,
	    ^If
	    [*
	      ( (@pp =ref firstPersonSingle)  ||
		(@pp =ref thirdPersonSingle)
	      ),
	      "was "  +con @neg +con @verbString,
	      "were " +con @neg +con @verbString
	    *]
	  ],

	  //  rightThenPastNatLangTense
	  //  (e.g. "(I) was being ~/was not being ~.")
	  [ '=ref, rightThenPastNatLangTense,
	    ^If
	    [*
	      ( (@pp =ref firstPersonSingle)  || (@pp =ref thirdPersonSingle) ),
	      "was "  +con @neg +con "being " +con @verbString,
	      "were " +con @neg +con "being " +con @verbString
	    *]
	  ],

	  //  completedPastNatLangTense
	  //  (e.g. "(I) had been ~/had not been ~.")
	  [ '=ref, completedPastNatLangTense,
 	    "had " +con @neg +con "been " +con @verbString
	  ],

	  //  inGeneralPresentNatLangTense
	  //  (e.g. "(I) am ~/am not ~")
	  [ '=ref, inGeneralPresentNatLangTense,
	    ^Test
	    [*
	      @pp,
	      [
		[ '=ref, firstPersonSingle,
		  "am " +con @neg +con @verbString
		],
		[ '=ref, thirdPersonSingle,
		  "is " +con @neg +con @verbString
		],
		[ true, true,
		  "are " +con @neg +con @verbString
		]
	      ]
	    *]
	  ],

	  //  rightThenPresentNatLangTense
	  //  (e.g. "(I) am being ~/am not being ~")
	  [ '=ref, rightThenPresentNatLangTense,
	    ^Test
	    [*
	      @pp,
	      [
		[ '=ref, firstPersonSingle,
		  "am " +con @neg +con "being " +con @verbString
		],
		[ '=ref, thirdPersonSingle,
		  "is " +con @neg +con "being " +con @verbString
		],
		[ true, true,
		  "are " +con @neg +con "being " +con @verbString
		]
	      ]
	    *]
	  ],

	  //  completedPresentNatLangTense
	  //  (e.g. "(I) have been ~/have not been ~")
	  [ '=ref, completedPresentNatLangTense,
	    ^If
	    [*
	      (@pp =ref thirdPersonSingle),
	      "has "  +con @neg +con "been " +con @verbString,
	      "have " +con @neg +con "been " +con @verbString
	    *]
	  ],

	  //  timelessNatLangTense
	  //  (e.g. "to be ~/not to be ~")
	  [ '=ref, timelessNatLangTense,
	    @neg +con "to be " +con @verbString
	  ]
	]
      *]
    ]*]
  *];

  //  PURPOSE:  To return the conjugation of verb @verb with infinitive
  //	@verbString, text @neg with negation-telling text (or "" if not
  //	negated) and @pp telling the person and plurality.  @verb should does
  //	*not* use "to be".
  sub toEnglish_predicate_verbConjugate	String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea],
      [@verb,	       NatLangVerbTerm],
      [@verbString,    String],
      [@affirmStat,    NatLangAffirmNegateStatus],
      [@neg,	       String],
      [@pp,	       NatLangPersonPlurality]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Conjugate verb:
      ^VarDecl[* @irregularForm,Idea *],

      //  II.A.  Get the doubled-letter (for some verbs) needed when forming
      //  	 -ed and -ing forms:
      ^VarDecl[* @doubledLetter, String *],

      @doubledLetter :=
	    @verb->get(^VerbTermsEndingBeforePastTenseAndGerundA[*toEnglish*]),

      //  II.B.  Conjugate verb:
      ^Test
      [*
	@this->get(natLangSentencesTenseA),

	[ //  inGeneralPastNatLangTense
	  //  (e.g. "(I) programmed/did not program.")
	  [ '=ref, inGeneralPastNatLangTense,
	    ^If
	    [*
	      @affirmStat =ref negateNatLangStatus,
	      "did not " +con @verbString,
	      ^If
	      [*
		(@irregularForm :=
		    @verb->get(^VerbTermsIrregularPastSimpleTenseA[*toEnglish*])
		)
		!=ref null,
		@irregularForm,
		^If
		[*
		  @verbString->string_hasSuffix("y"),
		  @verbString -unc ~"y" +con "ied",
		  @verbString -unc ~"e" +con @doubledLetter +con "ed"   
		*]
	      *]
	    *]
	  ],

	  //  rightThenPastNatLangTense
	  //  (e.g. "(I) was programming/was not programming.")
	  [ '=ref, rightThenPastNatLangTense,
 	    ^If
 	    [*
 	      (@pp =ref firstPersonSingle) || (@pp =ref thirdPersonSingle),
 	      "was ",
 	      "were "
	    *]
 	    +con @neg
	    +con @verbString -unc ~"e" +con @doubledLetter +con "ing"
	  ],

	  //  completedPastNatLangTense
	  //  (e.g. "(I) had programmed/had not programmed.")
	  [ '=ref, completedPastNatLangTense,
	    ^If
	    [*
	      (@irregularForm :=
		 @verb->get(^VerbTermsIrregularPastPerfectTenseA[*toEnglish*])
	      )
	      !=ref null,
	      "had " +con @neg +con @irregularForm,
	      ^If
	      [*
		@verbString->string_hasSuffix("y"),
		"had " +con @neg +con @verbString -unc ~"y" +con "ied",
		"had " +con @neg +con @verbString -unc ~"e" +con @doubledLetter
		       	    	      		     	  +con "ed"
	      *]
	    *]
	  ],

	  //  inGeneralPresentNatLangTense
	  //  (e.g. "(I) program/do not program")
	  [ '=ref, inGeneralPresentNatLangTense,
	    ^If
	    [*
	      @affirmStat =ref negateNatLangStatus,
	      ^If
	      [*
		(@pp =ref thirdPersonSingle),
		"does not " +con @verbString,
		"do not "   +con @verbString
	      *],
	      ^If
	      [*
		(@pp =ref thirdPersonSingle),
		^If
		[*
		  @verbString->string_hasSuffix("y"),

		  @verbString -unc ~"y" +con "ies",

		  ^If
		  [*
		    @verbString->string_hasSuffix("tch"),
		    @verbString  +con  "es",
		    @verbString  +con  "s"
		  *]
		*],
		@verbString
	      *]
	    *]
	  ],

	  //  rightThenPresentNatLangTense
	  //  (e.g. "(I) am programming/am not programming")
	  [ '=ref, rightThenPresentNatLangTense,
	    ^Test
	    [*
	      @pp,
	      [ ['=ref, firstPersonSingle, "am " ],
		['=ref, thirdPersonSingle, "is " ],
		[true,  true, "are " ]
	      ]
	    *]
	    +con @neg +con @verbString -unc ~"e" +con @doubledLetter +con "ing"
	  ],

	  //  completedPresentNatLangTense
	  //  (e.g. "(I) have programmed/have not programmed")
	  [ '=ref, completedPresentNatLangTense,
	    ^Do
	    [*[
	      ^VarDecl[* @helpingVerb, String *],

	      @helpingVerb	:=
		^If
		[*
		  (@pp =ref thirdPersonSingle),
		  "has ",
		  "have "
		*],

	      ^If
	      [*
		(@irregularForm :=
		   @verb->get(^VerbTermsIrregularPastPerfectTenseA[*toEnglish*])
		)
		=ref null,
		^If
		[*
		  @verbString->string_hasSuffix("y"),
		  @helpingVerb +con @neg +con @verbString -unc ~"y" +con "ied",
		  @helpingVerb +con @neg +con @verbString
				   -unc ~"e" +con @doubledLetter +con "ed"
		*],
		@helpingVerb +con @neg +con @irregularForm
	      *]
	    ]*]
	  ],

	  //  timelessNatLangTense
	  //  (e.g. "to program")
	  [ '=ref, timelessNatLangTense,
	    "to " +con @verbString
	  ],

	  //  nounifiedNatLangTense
	  //  (e.g. "programming")
	  [ '=ref, nounifiedNatLangTense,
	    @verbString -unc ~"e" +con @doubledLetter +con "ing"
	  ]
	]

      *]

    ]*]

  *];


  //  PURPOSE:  To generate and return a string for the English representation
  //	of the predicate of '@this' declarative sentence given the grammatical
  //	info in '@interTermInfo'.
  sub toEnglish_predicate	String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea]
    ],

    ^Do
    [*[
      //  I.  Applicability validity check:

      //  II.  Construct verb phrase:
      ^VarDecl[* @theSentence, NatLangDeclarativeSentence *],
      ^VarDecl[* @verb,NatLangVerbTerm *],
      ^VarDecl[* @verbString,String *],

      @theSentence	:= @this,
      @verb		:= @theSentence->get(natLangSentencesVerbA),

      //  II.A.  Get verb stem string:
      ^Test
      [*
	@verb,

	[
	  [ '=ref, toRedo,
	    ^Do
	    [*[
	      ^VarDecl[* @phraseDSIter, Iterator *],

	      ^For
	      [*
		@phraseDSIter :=
		    @theSentence->get(natLangSentencesPhraseDSA)->
				dataStruct_iter(),

		!@phraseDSIter->iter_isAtEnd(),

		^If
		[*
		  ( @phraseDSIter->iter_value()->get(natLangExprsPhraseRoleA)
		    =ref directObjectNatLangPhraseRole
		  ),
		  ^Break
		*],

		@phraseDSIter->iter_advance()
	      *],

	      @theSentence  := @phraseDSIter->iter_value(),
	      @verb	    := @theSentence->get(natLangSentencesVerbA),
	      @verbString   := "re"  +con  @verb->get(^TermsTextA[*toEnglish*])
	    ]*]
	  ],

	  ['=ref, toBeAs, @verbString := @verb->get(^TermsTextA[*toEnglish*]) ],

	  [true, true,    @verbString := @verb->get(^TermsTextA[*toEnglish*]) ]
	]

      *],

      //  II.B.  Get negation string:
      ^VarDecl[* @neg,String*],
      ^VarDecl[* @affirmStat, NatLangAffirmNegateStatus *],

      @affirmStat := @theSentence->get(natLangSentencesAffirmNegateStatusA),

      ^If
      [*
        @affirmStat =ref negateNatLangStatus,
	@neg := "not ",
	@neg := ""
      *],

      //  II.D.  Conjugate verb base upon tense, person and plurality:
      ^VarDecl[* @person,	NatLangPerson *],
      ^VarDecl[* @plurality,	NatLangPlurality *],
      ^VarDecl[* @pp,		NatLangPersonPlurality *],
      ^VarDecl[* @shouldInvertNotsLoc,Boolean *],
      ^VarDecl[* @toReturn,	String *],

      @person	:= @interTermInfo->get(nounPhrasesPersonA),
      @plurality:= @interTermInfo->get(nounPhrasesPluralityA),
      @shouldInvertNotsLoc
		:= false,
      @pp	:=  ^Test
		    [*
		      @person,

		      [
			[ '=ref, firstPerson,
			  ^If
			  [*
			    (@plurality =ref singularPlurality),
			    firstPersonSingle,
			    firstPersonPlural
			  *]
			],

			[ '=ref, secondPerson,
			  ^If
			  [*
			    (@plurality =ref singularPlurality),
			    secondPersonSingle,
			    secondPersonPlural
			  *]
			],

			[ true, true,
			  ^If
			  [*
			    (@plurality =ref singularPlurality),
			    thirdPersonSingle,
			    thirdPersonPlural
			  *]
			]
		      ]
		    *],

      @toReturn	:=
        ^If
	[*
	  @verb->get(^DoesVerbUseToBeA[*toEnglish*]) =ref true,

	  // Conjugate the verb "to be" and append @verbString
	  @theSentence->toEnglish_predicate_verbConjugate_toBe
		(@interTermInfo,
		 @callBack,
		 @verb,
		 @verbString,
		 @neg,
		 @pp
		),

	  //  Just conjugate the @verbString
	  @theSentence->toEnglish_predicate_verbConjugate
		(@interTermInfo,
		 @callBack,
		 @verb,
		 @verbString,
		 @affirmStat,
		 @neg,
		 @pp
		)
	*],

      //  II.E.  Append postpositions (if exist):
      ^VarDecl
      [*
	@postPosition,
	Idea,
	@verb->get(^VerbTermsPostpositionTextA[*toEnglish*])
      *],

      ^If
      [*
	(@postPosition !=ref null),
	@toReturn := @toReturn +con @postPosition
      *],

      //  II.F.  Write NatLangPhraseRole instances (other than subject, which,
      //  	  in English, generally comes before the verb phrase):
      ^VarDecl[* @roleIter, Iterator *],
      ^VarDecl
      [*
	@phraseDS,
	Idea,
	@theSentence->get(natLangSentencesPhraseDSA)
      *],

      ^If
      [*
        (@phraseDS !=ref null)  &&  (@phraseDS->dataStruct_size() > 0),

	^Do
	[*[
	  ^VarDecl[* @phraseIter, Iterator *],

	  @phraseIter := @phraseDS->dataStruct_iter(),

	  ^For
	  [*
	    @roleIter := [directObjectNatLangPhraseRole,
		          directObjectTextNatLangPhraseRole,
			  havingNatLangPhraseRole,
			  withValueNatLangPhraseRole,
			  usingNatLangPhraseRole,
			  forThePurposeOfNatLangPhraseRole,
			  awayFromNatLangPhraseRole,
			  towardNatLangPhraseRole,
			  whereNatLangPhraseRole,
			  whenNatLangPhraseRole,
			  relativeToNatLangPhraseRole,
		          notObjectNatLangPhraseRole,
			  becauseOfNatLangPhraseRole
			 ]->dataStruct_iter(),

	    !@roleIter->iter_isAtEnd(),

	    ^Do
	    [*[
	      ^VarDecl[* @role, NatLangPhraseRole *],

	      @role	:= @roleIter->iter_value(),

	      ^For
	      [*
		@phraseIter->iter_reset(),

		!@phraseIter->iter_isAtEnd(),

		^Do
		[*[
		  ^VarDecl[* @phrase, NatLangExpr *],
		  ^VarDecl[* @roleText, Idea *],

		  @phrase := @phraseIter->iter_value(),

		  ^If
		  [*
		    (@phrase->get(natLangExprsPhraseRoleA) =ref @role),

		    ^Do
		    [*[
		      @roleText	:= @role->get(^TermsTextA[*toEnglish*]),

		      ^If
		      [*
			@role =ref directObjectTextNatLangPhraseRole,
			^If
			[*
			  @roleText =ref null,
			  @toReturn :=
				@toReturn
				+con
				" "
				+con
				@phrase->toEnglish(@interTermInfo,@theSentence),
			  @toReturn := 
				@toReturn
				+con
				@roleText
				+con
				@phrase->get(natLangRolePhrasesNounA)
			*],

			^If
			[*
			  ( (@roleText =ref null)	||
			    @phrase->
				isInstanceOf
					(NatLangParameterizedDescriptorPhrase)
			  ),
			  @toReturn :=
				@toReturn
				+con
				" "
				+con
				@phrase->toEnglish(@interTermInfo,@theSentence),
			  @toReturn :=
			  	@toReturn
			  	+con
			  	" "
			  	+con
			  	@roleText
			  	+con
			  	@phrase->toEnglish(@interTermInfo,@theSentence)
			*]

		      *],

		      ^Break
		    ]*]
		  *]
		]*],

		@phraseIter->iter_advance()
	      *]
	  
	    ]*],

	    @roleIter->iter_advance()
	  *]
	]*]

      *],

      //  III.  Finished:
      ^Return[* @toReturn *]
    ]*]
  *];
  //  toEnglish_predicate

  //  PURPOSE:  To generate and return a string for the English representation
  //	of '@this' declarative sentence given the grammatical info in
  //	'@interTermInfo'.
  sub toEnglish 	String
  [*
    [
      [@interTermInfo, InterTermGrammarInfo],
      [@callBack,      Idea]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Attempt to construct text for '@this' sentence:
      //  II.A.  Attempt to get text for subject:
      ^VarDecl[* @iter,		Iterator *],
      ^VarDecl[* @subjPhrase,	NatLangExpr *],
      ^VarDecl[* @toReturn,	String *],

      //  II.A.1.  Each iteration looks for an expression in the datastructure
      //  	   that is the value of attr 'natLangSentencesPhraseDSA' that
      //	   itself has value 'natLangExprsPhraseRoleA' equal to
      //	   'subjectNatLangPhraseRole':
      ^For
      [*
	@iter	:= @this->get(natLangSentencesPhraseDSA)->dataStruct_iter(),

	!@iter->iter_isAtEnd(),

	^If
	[*
	  ^Do
	  [*[
	    @subjPhrase := @iter->iter_value(),
	    ( @subjPhrase->get(natLangExprsPhraseRoleA) =ref
	      subjectNatLangPhraseRole
	    )
	  ]*],

	  ^Break
	*],

	@iter->iter_advance()
      *],

      //  II.A.2.  Get text of subject, if it exists.  (Subjects might not
      //  	    exist in sub-sentences embedded in other sentences.  For
      //	    example, in sentence "The sp8b attempted to divide by 0."
      //	    contains the sub-sentence "to divide by 0" with verb
      //	    "to divide by", direct object "0", but no subject.)
      ^VarDecl[* @isSubsentence, Boolean *],

      @isSubsentence	:= false,

      ^If
      [*
	@iter->iter_isAtEnd(),
	^Do[*[   @toReturn := "",  @isSubsentence := true   ]*],
	@toReturn := @subjPhrase->toEnglish(@interTermInfo,@this)
      *],

      //  II.B.  Get text of predicate:
      @toReturn	 := @toReturn					+con
      		    " "						+con
		    @this->toEnglish_predicate(@interTermInfo,@this),

      //  II.C.  Add period to non sub-sentences:
      ^If[* !@isSubsentence, @toReturn := @toReturn +con "." *],

      //  III.  Finished:
      ^Return[* @toReturn *]
    ]*]
  *];
  //  toEnglish


*};
//  NatLangDeclarativeSentence




//									//
//			    NatLangPhraseRole				//
//									//
subjectNatLangPhraseRole
{* *};

directObjectNatLangPhraseRole
{* *};

directObjectTextNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ(": "); *};

havingNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("having "); *};

withValueNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("with value "); *};

becauseOfNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("because of "); *};

usingNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("using "); *};

forThePurposeOfNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("for "); *};

towardNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("to "); *};

awayFromNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("from "); *};

whereNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("at "); *};

whenNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("at "); *};

relativeToNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("relative to "); *};

notObjectNatLangPhraseRole
{* ^TermsTextA[*toEnglish*]->assertZ("not "); *};



//									//
//			    NatLangVerbTerm				//
//									//

NatLangVerbTerm
{*
  ^DoesVerbUseToBeA[*toEnglish*]->subAssert(false);
  ^VerbTermsEndingBeforePastTenseAndGerundA[*toEnglish*]->subAssert("");
*};


//  PURPOSE:  Individual verb terms.
toExist
{*
  ^TermsTextA[*toEnglish*]->assert("exist");
*};

toBeAs
{*
  ^TermsTextA[*toEnglish*]->assert("");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toOwn
{*
  ^TermsTextA[*toEnglish*]->assert("own");
*};

toBelongTo
{*
  ^TermsTextA[*toEnglish*]->assert("belong");
  ^VerbTermsPostpositionTextA[*toEnglish*]->assert(" to");
*};

toHaveTheProperty
{*
  ^TermsTextA[*toEnglish*]->assert("");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toHappen
{*
  ^TermsTextA[*toEnglish*]->assert("happen");
*};

toBeAbleTo
{*
  ^TermsTextA[*toEnglish*]->assert("able");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toBeAllowed
{*
  ^TermsTextA[*toEnglish*]->assert("allowed");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toMust
{*
  ^TermsTextA[*toEnglish*]->assert("must");
*};

toKnow
{*
  ^TermsTextA[*toEnglish*]->assert("know");
  ^VerbTermsIrregularPastSimpleTenseA[*toEnglish*]->assert("knew");
  ^VerbTermsIrregularPastPerfectTenseA[*toEnglish*]->assert("known");
  ^VerbTermsIrregularPresentPerfectTenseA[*toEnglish*]->assert("known");
*};

toRecognize
{*
  ^TermsTextA[*toEnglish*]->assert("recognize");
*};

toAttempt
{*
  ^TermsTextA[*toEnglish*]->assert("attempt");
*};

toRedo
{*
  ^TermsTextA[*toEnglish*]->assert("redo");
*};

toSucceed
{*
  ^TermsTextA[*toEnglish*]->assert("succeed");
*};

toFail
{*
  ^TermsTextA[*toEnglish*]->assert("fail");
*};

toUse
{*
  ^TermsTextA[*toEnglish*]->assert("use");
*};

toModify
{*
  ^TermsTextA[*toEnglish*]->assert("modify");
*};

toAssert
{*
  ^TermsTextA[*toEnglish*]->assert("assert");
*};

toDeclareAVarOrFnc
{*
  ^TermsTextA[*toEnglish*]->assert("declare");
*};

toQuantifyTheScopeOf
{*
  ^TermsTextA[*toEnglish*]->assert("quantify");
*};

toDefine
{*
  ^TermsTextA[*toEnglish*]->assert("define");
*};

toAssignAValueTo
{*
  ^TermsTextA[*toEnglish*]->assert("assign");
*};

toLookFor
{*
  ^TermsTextA[*toEnglish*]->assert("look for");
*};

toFind
{*
  ^TermsTextA[*toEnglish*]->assert("find");
  ^VerbTermsIrregularPastSimpleTenseA[*toEnglish*]->assert("found");
  ^VerbTermsIrregularPastPerfectTenseA[*toEnglish*]->assert("found");
  ^VerbTermsIrregularPresentPerfectTenseA[*toEnglish*]->assert("found");
*};

toQuery
{*
  ^TermsTextA[*toEnglish*]->assert("query");
*};

toSort
{*
  ^TermsTextA[*toEnglish*]->assert("sort");
*};

toCompile
{*
  ^TermsTextA[*toEnglish*]->assert("compile");
*};

toCompute
{*
  ^TermsTextA[*toEnglish*]->assert("compute");
*};

toParse
{*
  ^TermsTextA[*toEnglish*]->assert("parse");
*};

toOpen
{*
  ^TermsTextA[*toEnglish*]->assert("open");
*};

toClose
{*
  ^TermsTextA[*toEnglish*]->assert("close");
*};

toRead
{*
  ^TermsTextA[*toEnglish*]->assert("read");
  ^VerbTermsIrregularPastSimpleTenseA[*toEnglish*]->assert("read");
  ^VerbTermsIrregularPastPerfectTenseA[*toEnglish*]->assert("read");
  ^VerbTermsIrregularPresentPerfectTenseA[*toEnglish*]->assert("read");
*};

toWrite
{*
  ^TermsTextA[*toEnglish*]->assert("write");
  ^VerbTermsIrregularPastSimpleTenseA[*toEnglish*]->assert("wrote");
  ^VerbTermsIrregularPastPerfectTenseA[*toEnglish*]->assert("written");
  ^VerbTermsIrregularPresentPerfectTenseA[*toEnglish*]->assert("written");
  ^VerbTermsPostpositionTextA[*toEnglish*]->assert(" to");
*};

toFlush
{*
  ^TermsTextA[*toEnglish*]->assert("flush");
*};

toInsert
{*
  ^TermsTextA[*toEnglish*]->assert("insert");
*};

toRemove
{*
  ^TermsTextA[*toEnglish*]->assert("remove");
*};

toAdd
{*
  ^TermsTextA[*toEnglish*]->assert("add");
*};

toSubtract
{*
  ^TermsTextA[*toEnglish*]->assert("subtract");
*};

toMultiply
{*
  ^TermsTextA[*toEnglish*]->assert("multiply");
*};

toDivide
{*
  ^TermsTextA[*toEnglish*]->assert("divide");
  ^VerbTermsPostpositionTextA[*toEnglish*]->assert(" by");
*};

toRaiseToAPower
{*
  ^TermsTextA[*toEnglish*]->assert("raise");
  ^VerbTermsPostpositionTextA[*toEnglish*]->assert(" to");
*};

toThrow
{*
  ^TermsTextA[*toEnglish*]->assert("throw");
  ^VerbTermsIrregularPastSimpleTenseA[*toEnglish*]->assert("threw");
  ^VerbTermsIrregularPastPerfectTenseA[*toEnglish*]->assert("thrown");
  ^VerbTermsIrregularPresentPerfectTenseA[*toEnglish*]->assert("thrown");
*};

toStart
{*
  ^TermsTextA[*toEnglish*]->assert("start");
*};

toBeInTheActOf
{*
  ^TermsTextA[*toEnglish*]->assert("in the act of");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toInterrupt
{*
  ^TermsTextA[*toEnglish*]->assert("interrupt");
*};

toContinue
{*
  ^TermsTextA[*toEnglish*]->assert("continue");
*};

toStop
{*
  ^TermsTextA[*toEnglish*]->assert("stop");
  ^VerbTermsEndingBeforePastTenseAndGerundA[*toEnglish*]->assert("p");
*};

toFinish
{*
  ^TermsTextA[*toEnglish*]->assert("finish");
*};

toExpect
{*
  ^TermsTextA[*toEnglish*]->assert("expect");
*};

toNeed
{*
  ^TermsTextA[*toEnglish*]->assert("need");
*};

toLack
{*
  ^TermsTextA[*toEnglish*]->assert("lack");
*};

toName
{*
  ^TermsTextA[*toEnglish*]->assert("name");
*};

toNumber
{*
  ^TermsTextA[*toEnglish*]->assert("numbered");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toMatch
{*
  ^TermsTextA[*toEnglish*]->assert("match");
*};

toRun
{*
  ^TermsTextA[*toEnglish*]->assert("run");
  ^VerbTermsEndingBeforePastTenseAndGerundA[*toEnglish*]->assert("n");
  ^VerbTermsIrregularPastSimpleTenseA[*toEnglish*]->assert("ran");
  ^VerbTermsIrregularPastPerfectTenseA[*toEnglish*]->assert("run");
  ^VerbTermsIrregularPresentPerfectTenseA[*toEnglish*]->assert("run");
*};

toImplement
{*
  ^TermsTextA[*toEnglish*]->assert("implement");
*};

toEncounter
{*
  ^TermsTextA[*toEnglish*]->assert("encounter");
*};

toBeDescribedBy
{*
  ^TermsTextA[*toEnglish*]->assert("described by");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toBeOwnedBy
{*
  ^TermsTextA[*toEnglish*]->assert("owned by");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toBeIn
{*
  ^TermsTextA[*toEnglish*]->assert("inside of");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toBeOut
{*
  ^TermsTextA[*toEnglish*]->assert("outside of ");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toBeReserved
{*
  ^TermsTextA[*toEnglish*]->assert("reserved");
  ^DoesVerbUseToBeA[*toEnglish*]->assert(true);
*};

toConvert
{*
  ^TermsTextA[*toEnglish*]->assert("convert");
*};

toRegister
{*
  ^TermsTextA[*toEnglish*]->assert("register");
*};

toViolate
{*
  ^TermsTextA[*toEnglish*]->assert("violate");
*};



//									//
//			    NatLangNounTerm				//
//									//

theLastRequestedComputation
{*
  ^TermsTextA[*toEnglish*]->assert("last requested computation");
*};

theUser
{*
  ^TermsTextA[*toEnglish*]->assert("user");
*};

theSomProgrammers
{*
  ^TermsTextA[*toEnglish*]->assert("SOM programmers");
*};

theKnowledgeBase
{*
  ^TermsTextA[*toEnglish*]->assert("knowledge base");
*};

theSpProgram
{*
  ^TermsTextA[*toEnglish*]->assert("SP program");
*};

theSpRun
{*
  ^TermsTextA[*toEnglish*]->assert("SP run");
*};

theComputer
{*
  ^TermsTextA[*toEnglish*]->assert("computer");
*};

theNetworkedComputingSystem
{*
  ^TermsTextA[*toEnglish*]->assert("networked computing system");
*};

theInternet
{*
  ^TermsTextA[*toEnglish*]->assert("Internet");
*};

aQuery
{*
  ^TermsTextA[*toEnglish*]->assert("query");
*};

anAnswer
{*
  ^TermsTextA[*toEnglish*]->assert("answer");
*};

aSubject
{*
  ^TermsTextA[*toEnglish*]->assert("subject");
*};

anAttribute
{*
  ^TermsTextA[*toEnglish*]->assert("attribute");
*};

anExpression
{*
  ^TermsTextA[*toEnglish*]->assert("expression");
*};

aNonannotatedValue
{*
  ^TermsTextA[*toEnglish*]->assert("nonannotated value");
*};

anAnnotatedValue
{*
  ^TermsTextA[*toEnglish*]->assert("annotated value");
*};

aValue
{*
  ^TermsTextA[*toEnglish*]->assert("value");
*};

anIndex
{*
 ^TermsTextA[*toEnglish*]->assert("index");
*};

aKey
{*
 ^TermsTextA[*toEnglish*]->assert("key");
*};

aConstant
{*
  ^TermsTextA[*toEnglish*]->assert("constant");
*};

aVariable
{*
  ^TermsTextA[*toEnglish*]->assert("variable");
*};

aSelfVariable
{*
  ^TermsTextA[*toEnglish*]->assert("self-variable");
*};

aDivisor
{*
  ^TermsTextA[*toEnglish*]->assert("divisor");
*};

aMathematicalPower
{*
  ^TermsTextA[*toEnglish*]->assert("power");
*};

anIdea
{*
  ^TermsTextA[*toEnglish*]->assert("idea");
*};

aClass
{*
  ^TermsTextA[*toEnglish*]->assert("class");
*};

aSubclass
{*
  ^TermsTextA[*toEnglish*]->assert("subclass");
*};

aSuperclass
{*
  ^TermsTextA[*toEnglish*]->assert("superclass");
*};

anInstance
{*
  ^TermsTextA[*toEnglish*]->assert("instance");
*};

aBooleanValue
{*
  ^TermsTextA[*toEnglish*]->assert("boolean value");
*};

aNumber
{*
  ^TermsTextA[*toEnglish*]->assert("number");
*};

anInteger
{*
  ^TermsTextA[*toEnglish*]->assert("integer");
*};

aRationalNumber
{*
  ^TermsTextA[*toEnglish*]->assert("rational number");
*};

aFloatingPointNumber
{*
  ^TermsTextA[*toEnglish*]->assert("floating point number");
*};

unicodeByteSequence
{*
  ^TermsTextA[*toEnglish*]->assert("unicode byte sequence");
*};

aCharacterString
{*
  ^TermsTextA[*toEnglish*]->assert("character string");
*};

aCharacter
{*
  ^TermsTextA[*toEnglish*]->assert("character");
*};

aNextLineChar
{*
  ^TermsTextA[*toEnglish*]->assert("next line character");
*};

aHexadecimalDigit
{*
  ^TermsTextA[*toEnglish*]->assert("hexadecimal digit");
*};

aDecimalDigit
{*
  ^TermsTextA[*toEnglish*]->assert("decimal digit");
*};

anIdeasHexadecimalValue
{*
  ^TermsTextA[*toEnglish*]->assert("ideas hexadecimal value");
*};

anIterator
{*
  ^TermsTextA[*toEnglish*]->assert("iterator");
*};

aDataStructure
{*
  ^TermsTextA[*toEnglish*]->assert("data structure");
*};

aNode
{*
  ^TermsTextA[*toEnglish*]->assert("node");
*};

aDomain
{*
  ^TermsTextA[*toEnglish*]->assert("domain");
*};

aRange
{*
  ^TermsTextA[*toEnglish*]->assert("range");
*};

aBinaryTreeNode
{*
  ^TermsTextA[*toEnglish*]->assert("binary tree node");
*};

aLinearDataStructure
{*
  ^TermsTextA[*toEnglish*]->assert("linear data structure");
*};

aList
{*
  ^TermsTextA[*toEnglish*]->assert("list");
*};

aVectorList
{*
  ^TermsTextA[*toEnglish*]->assert("vector list");
*};

aNodeList
{*
  ^TermsTextA[*toEnglish*]->assert("node list");
*};

aListNode
{*
  ^TermsTextA[*toEnglish*]->assert("list node");
*};

aDataNode
{*
  ^TermsTextA[*toEnglish*]->assert("data node");
*};

aNilNode
{*
  ^TermsTextA[*toEnglish*]->assert("nil node");
*};

aStack
{*
  ^TermsTextA[*toEnglish*]->assert("stack");
*};

aQueue
{*
  ^TermsTextA[*toEnglish*]->assert("queue");
*};

anIdentifier
{*
  ^TermsTextA[*toEnglish*]->assert("identifier");
*};

aCommand
{*
  ^TermsTextA[*toEnglish*]->assert("command");
*};

aFunction
{*
  ^TermsTextA[*toEnglish*]->assert("function");
*};

aConstructor
{*
  ^TermsTextA[*toEnglish*]->assert("constructor");
*};

anAnonymousFunction
{*
  ^TermsTextA[*toEnglish*]->assert("anonymous function");
*};

anAnonymousFunctionTemplate
{*
  ^TermsTextA[*toEnglish*]->assert("anonymous function template");
*};

aFunctionCall
{*
  ^TermsTextA[*toEnglish*]->assert("function call");
*};

anOperator
{*
  ^TermsTextA[*toEnglish*]->assert("operator");
*};

aMethodCallSequence
{*
  ^TermsTextA[*toEnglish*]->assert("method call sequence");
*};

aPredicate
{*
  ^TermsTextA[*toEnglish*]->assert("predicate");
*};

aPredicateExpression
{*
  ^TermsTextA[*toEnglish*]->assert("predicate expression");
*};

aRule
{*
  ^TermsTextA[*toEnglish*]->assert("rule");
*};

aRulesHeadPredicate
{*
  ^TermsTextA[*toEnglish*]->assert("rule's head predicate");
*};

aRulesClauseList
{*
  ^TermsTextA[*toEnglish*]->assert("rule's clause list");
*};

anAssumptionContext
{*
  ^TermsTextA[*toEnglish*]->assert("assumption context");
*};

anArgument
{*
  ^TermsTextA[*toEnglish*]->assert("argument");
*};

anOperand
{*
  ^TermsTextA[*toEnglish*]->assert("operand");
*};

aMapping
{*
  ^TermsTextA[*toEnglish*]->assert("mapping");
*};

aNaturalLanguage
{*
  ^TermsTextA[*toEnglish*]->assert("natural language");
*};

anAssumption
{*
  ^TermsTextA[*toEnglish*]->assert("assumption");
*};

anIOProblem
{*
  ^TermsTextA[*toEnglish*]->assert("I/O problem");
*};

aBug
{*
  ^TermsTextA[*toEnglish*]->assert("bug");
*};

aSyntaxError
{*
  ^TermsTextA[*toEnglish*]->assert("syntax error");
*};

aFile
{*
  ^TermsTextA[*toEnglish*]->assert("file");
*};

anInputFile
{*
  ^TermsTextA[*toEnglish*]->assert("input file");
*};

anOutputFile
{*
  ^TermsTextA[*toEnglish*]->assert("output file");
*};

aDirectory
{*
  ^TermsTextA[*toEnglish*]->assert("directory");
*};

theEndOfFile
{*
  ^TermsTextA[*toEnglish*]->assert("end-of-file");
*};

ideaType
{*
  ^TermsTextA[*toEnglish*]->assert("idea");
*};

aDescription
{*
  ^TermsTextA[*toEnglish*]->assert("description");
*};

aPrefix
{*
  ^TermsTextA[*toEnglish*]->assert("prefix");
*};

aSuffix
{*
  ^TermsTextA[*toEnglish*]->assert("suffix");
*};


//  Individual adjective terms:
NatLangAdjectiveTerm
{*
  ^AdjectiveOrderA[*toEnglish*]->subAssert(400);
  ^DoesAdjectiveServeAsArticleA[*toEnglish*]->subAssert(false);
*};

nonSpecific
{*
  ^TermsTextA[*toEnglish*]->assert("non-specific");
  
*};

immutable
{*
  ^TermsTextA[*toEnglish*]->assert("immutable");
*};

singleDistinct
{*
  ^TermsTextA[*toEnglish*]->assert("single, distinct");
*};

setFull
{*
  ^TermsTextA[*toEnglish*]->assert("set full");
*};

redundant
{*
  ^TermsTextA[*toEnglish*]->assert("redundant");
*};

nonredundant
{*
  ^TermsTextA[*toEnglish*]->assert("non-redundant");
*};

tooFew
{*
  ^TermsTextA[*toEnglish*]->assert("too few");
  ^AdjectiveOrderA[*toEnglish*]->assert(100);
  ^DoesAdjectiveServeAsArticleA[*toEnglish*]->assert(true);
*};

tooMany
{*
  ^TermsTextA[*toEnglish*]->assert("too many");
  ^AdjectiveOrderA[*toEnglish*]->assert(100);
  ^DoesAdjectiveServeAsArticleA[*toEnglish*]->assert(true);
*};

legal
{*
  ^TermsTextA[*toEnglish*]->assert("legal");
  ^AdjectiveOrderA[*toEnglish*]->assert(250);
*};

illegal
{*
  ^TermsTextA[*toEnglish*]->assert("illegal");
  ^AdjectiveOrderA[*toEnglish*]->assert(250);
*};

expected
{*
  ^TermsTextA[*toEnglish*]->assert("expected");
*};

same
{*
  ^TermsTextA[*toEnglish*]->assert("same");
  ^AdjectiveOrderA[*toEnglish*]->assert(200);
*};

different
{*
  ^TermsTextA[*toEnglish*]->assert("different");
  ^AdjectiveOrderA[*toEnglish*]->assert(200);
*};

positive
{*
  ^TermsTextA[*toEnglish*]->assert("positive");
  ^AdjectiveOrderA[*toEnglish*]->assert(300);
*};

negative
{*
  ^TermsTextA[*toEnglish*]->assert("negative");
  ^AdjectiveOrderA[*toEnglish*]->assert(300);
*};

nonPositive
{*
  ^TermsTextA[*toEnglish*]->assert("non-positive");
  ^AdjectiveOrderA[*toEnglish*]->assert(300);
*};

nonNegative
{*
  ^TermsTextA[*toEnglish*]->assert("non-negative");
  ^AdjectiveOrderA[*toEnglish*]->assert(300);
*};

executable
{*
  ^TermsTextA[*toEnglish*]->assert("executable");
*};

nonExecutable
{*
  ^TermsTextA[*toEnglish*]->assert("non-executable");
*};

recognized
{*
  ^TermsTextA[*toEnglish*]->assert("recognized");
*};

nonRecognized
{*
  ^TermsTextA[*toEnglish*]->assert("non-recognized");
*};

ordered
{*
  ^TermsTextA[*toEnglish*]->assert("ordered");
*};

unordered
{*
  ^TermsTextA[*toEnglish*]->assert("unordered");
*};

compatible
{*
  ^TermsTextA[*toEnglish*]->assert("compatible");
*};

incompatible
{*
  ^TermsTextA[*toEnglish*]->assert("incompatible");
*};

usable
{*
  ^TermsTextA[*toEnglish*]->assert("usable");
*};

unusable
{*
  ^TermsTextA[*toEnglish*]->assert("unusable");
*};

contradictory
{*
  ^TermsTextA[*toEnglish*]->assert("contradictory");
*};

noncontradictory
{*
  ^TermsTextA[*toEnglish*]->assert("noncontradictory");
*};

//  End individual adjective terms:


//									//
//		NatLangParameterizedDescriptorTerm			//
//									//

insteadOf
{*
  ^TermsTextA[*toEnglish*]->assert("instead of");
*};

continuationOf
{*
  ^TermsTextA[*toEnglish*]->assert("continuation of");
*};

asAnArgumentTo
{*
  ^TermsTextA[*toEnglish*]->assert("as an argument to");
*};

thatBelongsTo
{*
  ^TermsTextA[*toEnglish*]->assert("that belongs to");
*};

thatResultedFromTheComputationOf
{*
  ^TermsTextA[*toEnglish*]->assert("that resulted from the computation of");
*};

insideOf
{*
  ^TermsTextA[*toEnglish*]->assert("inside of");
*};

outsideOf
{*
  ^TermsTextA[*toEnglish*]->assert("outside of");
*};

atThePositionWithIndex
{*
  ^TermsTextA[*toEnglish*]->assert("at the position with index");
*};

toTheFunction
{*
  ^TermsTextA[*toEnglish*]->assert("to the function");
*};

between
{*
  ^TermsTextA[*toEnglish*]->assert("between");
*};

into
{*
  ^TermsTextA[*toEnglish*]->assert("into");
*};

thatServes
{*
  ^TermsTextA[*toEnglish*]->assert("that serves");
*};

from
{*
  ^TermsTextA[*toEnglish*]->assert("from");
*};

withValue
{*
  ^TermsTextA[*toEnglish*]->assert("with value");
*};

locatedAt
{*
  ^TermsTextA[*toEnglish*]->assert("at");
*};
/? --- end of file --- ?/


//	Now that a language has been defined we can define 'spEnvsNatLangFncA'
//	This is a proxy for "The som8a program can now attempt to generate
//	natural language expressions".
thisSE
{*
  spEnvsNatLangFncA->assertA(toEnglish);
  spEnvsNatLangFormalityA->assertA(informalNatLangFormality);
*};



thisSE->parseFile("knowledgebases/standard/alEspanol.som8");

alEspanol
{*
  instanceOf->assertZ(LanguageFamily);
*};

/? --- end of file --- ?/


thisSE->parseFile("knowledgebases/standard/cultural.som8");
/?
 ?		This file section defines knowledge of
 ?		culturally important entities for science
 ?
 ?	Version 8b		2013 February 16	Joseph Phillips
 ?/

//  PURPOSE:  To encompass the set of cultural conventions, esp. for
//	describing things.  Includes the sets of units, domains, dimenions,
//	etc.
CulturalConvention
{*
  isA->assertZ(Idea);
*};


ResultingAttrStruct
{*
  isA->assertZ(CulturalConvention);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
		[[resultingAttrStructsOperatorA,Operator],
		  resultingAttrStructsOperandsAttrA,
		  resultingAttrStructsOperandsAttrSetA,
		  resultingAttrStructsResultingAttrA
		]
	    *]
	);
 *};


EmpiricalEntityA
{*
  isA->assertZ(Attribute);
*};


  CulturallyDefinedRelationshipA
  {*
    isA->assertZ(EmpiricalEntityA);
  *};

  Rationale
  {*
    isA->assertZ(CulturalConvention);
  *};

  RationaleA
  {*
    isA->assertZ(EmpiricalEntityA);
  *};

  Device
  {*
    isA->assertZ(CulturalConvention);
    isA->assertZ(EmpiricalEntity);
  *};

    PhysicalDevice
    {*
      isA->assertZ(Device);
    *};

    MethodologicalDevice
    {*
      isA->assertZ(Device);
    *};

      Algorithm
      {*
	isA->assertZ(MethodologicalDevice);
      *};

	ComputerProgram
	{*
	  isA->assertZ(Algorithm);
	*};



Spacetime
{*
  isA->assertZ(CulturalConvention);
*};


Time
{*
  isA->assertZ(CulturalConvention);
*};


Place
{*
  isA->assertZ(CulturalConvention);
*};


KnowledgeGeneratingActor
{*
  isA->assertZ(CulturalConvention);
*};


ValueGeneratingMachine
{*
  isA->assertZ(CulturalConvention);
*};




BooleanEmpiricalEntityA
{*
  isA->assertZ(EmpiricalEntityA);
*};


NumericEmpiricalEntityA
{*
  isA->assertZ(EmpiricalEntityA);
*};


SpatialExtentA
{*
  isA->assertZ(NumericEmpiricalEntityA);
*};


StructuralA
{*
  isA->assertZ(EmpiricalEntityA);
*};


WorldView
{*
  isA->assertZ(CulturalConvention);
*};

einsteinianWorldView
{*
  instanceOf->assertZ(WorldView);
*};


//  PURPOSE:  To augment class 'Exception' with a method to create a natural
//	language expression message.
Exception
{*

  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      ^Return[* "" *]
    ]*]
  *];

  sub toNatLang String
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compose string:
      //  II.A.  Get the value and class of '@this' Exception:
      ^VarDecl[* @value, Idea *],
      ^VarDecl[* @toReturn, NatLangExpr *],
      ^VarDecl[* @class,    Idea *],

      @this->computeValue(),
      @value	:= @this->get(exceptionsValueA),
      @class	:= @this->localGet(instanceOf),

      //  II.B.  If natural language knowledge base is not yet initialized
      //  	 then compose and return a string that is as informative
      //	 as possible without using natural language:
      ^If
      [*
	!thisSE->isNatLangKbInitialized(),

	^Do
	[*[
	  @toReturn	:= @class->toString(),

	  ^If
	  [*
	    @value !=ref null,
	    @toReturn := @toReturn +con ": " +con @value->toString()
	  *],

	  ^Return[* @toReturn *]
	]*]
      *],

      //  II.C.  If '@value' is a string, just return it:
      ^If
      [*
        @value->isInstanceOf(String),
	^Return[* @value *]
      *],

      //  II.D.  If get here then natural language knowledge base is
      //	 initialized.  Compose natural language response:

      //  II.D.1.  Only have work to do if '@value' is not a NatLangExpr:
      ^If
      [*
	!@value->isInstanceOf(NatLangExpr),

	^Do
	[*[
	  ^VarDecl[* @phraseDS, VectorList *],

	  //  II.D.1.a.  "The Sp run  . . . an instance of @class":
	  @phraseDS	:= ^^VectorList[**],
	  @phraseDS->dataStruct_insertZ(theSpRunSubject),
	  @phraseDS->dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    ^If
		    [*
		      ^^NatLangRolePhrase
		      [*
			@class,
			directObjectNatLangPhraseRole,
			thirdPerson,
			singularPlurality,
			false
		      *]
		    *]
		  *]
		),

	  //  II.D.1.b.  Add "with value '@value'" if '@value' is defined:
	  ^If
	  [*
	    @value !=ref null,
	    @phraseDS->dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @value,
		    withValueNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		)
	  *],

	  //  II.D.1.c.  "The Sp run threw an instance of @class
	  //		 (with value @value)":
	  @value	:=
	  	^^NatLangDeclarativeSentence
		[*
		  toThrow,
		  inGeneralPastNatLangTense,
		  affirmNatLangStatus,
		  @phraseDS
		*]
	]*]
      *],

      //  III.  Return NatLangExpr instance '@value' as a string:
      ^Return[* @value->toNatLang() *]
    ]*]
  *];
  //  toNatLangExpr

*};


//									//
//   		    Definitions of general exceptions:			//
//									//

//  PURPOSE:  To map from 'MissingValueException' instances to the subject
//	which lacks the value.
missingValueExceptionsSubjA
{*
  instanceOf->assertZ(ExceptionA);
*};


//  PURPOSE:  To map from 'MissingValueException' instances to the attribute
//	which lacks the value.
missingValueExceptionsAttrA
{*
  instanceOf->assertZ(ExceptionA);
*};


//  PURPOSE:  To represent the exception for a subject not having a value for
//	a particular attribute.
MissingValueException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [*
	    [ [missingValueExceptionsSubjA, Idea],
	      [missingValueExceptionsAttrA, Idea]
	    ]
	  *]
	);

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'MissingValueException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compose sentence:
      ^VarDecl[* @thisObj,  MissingValueException *],
      @thisObj	 := @thisObj,
      ^VarDecl
      [*
	@subject,
	Idea,
	@thisObj->localGet(missingValueExceptionsSubjA)
      *],
      ^VarDecl
      [*
	@attribute,
	Idea,
	@thisObj->localGet(missingValueExceptionsAttrA)
      *],

      //  "an attribute named <attr>"
      ^VarDecl[* @phraseDS, VectorList,  ^^VectorList[**]*],

      @phraseDS->dataStruct_insertZ
	( ^^NatLangRolePhrase
	  [*
	    @attribute,
	    directObjectNatLangPhraseRole,
	    thirdPerson,
	    singularPlurality,
	    false
	  *]
	),
      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toName,
	  inGeneralPresentNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      //  "<subject> does not have a value for an attribute named <attr>"
      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ
	( ^^NatLangRolePhrase
	  [*
	    @subject,
	    subjectNatLangPhraseRole,
	    thirdPerson,
	    singularPlurality,
	    true
	  *]
	),
      @phraseDS->dataStruct_insertZ
	( ^^NatLangRolePhrase
	  [*
	    aValue,
	    directObjectNatLangPhraseRole,
	    thirdPerson,
	    singularPlurality,
	    false
	  *]
	),
      @phraseDS->dataStruct_insertZ
	( ^^NatLangRolePhrase
	  [*
	    anAttribute,
	    forThePurposeOfNatLangPhraseRole,
	    thirdPerson,
	    singularPlurality,
	    false,
	    @sentence
	  *]
	),

      @sentence	:=
	^^NatLangDeclarativeSentence
	[*
	  toOwn,
	  inGeneralPresentNatLangTense,
	  negateNatLangStatus,
	  @phraseDS
	*],

      @this->assertZ(exceptionsValueA,@sentence),

      //  III.  Finished:
      ^Return[* @sentence *]
    ]*]
  *];
*};


//  PURPOSE:  To map from 'IllegalNameException' instances to the 'Idea'
//	instance that could not be renamed.
illegalNameExceptionsToRenameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'IllegalNameException' instances to the string
//	that is illegal to use as a name.
illegalNameExceptionsIllegalNameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent the exception of attempting to rename something to
//	an illegal name.
IllegalNameException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [*
	    [ [illegalNameExceptionsToRenameA, Idea],
	      [illegalNameExceptionsIllegalNameA, String]
	    ]
	  *]
	);

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'NameAlreadyTakenException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException, Exception, @this *],
      ^VarDecl
      [*
	@toRename,
	Idea,
	@thisException->localGet(illegalNameExceptionsToRenameA)
      *],
      ^VarDecl
      [*
	@illegalName,
	Idea,
	@thisException->localGet(illegalNameExceptionsIllegalNameA)
      *],

      //  "The Sp run cannot rename <illegalNameExceptionsToRenameA>
      //   to <illegalNameExceptionsIllegalNameA>"

      //  II.B.  "<nameAlreadyTakenExceptionsToRenameA>
      //   to <nameReservedExceptionsReservedNameA>."
      ^VarDecl[* @phraseDS,VectorList,^^VectorList[**] *],
      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @toRename,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @illegalName,
		    towardNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
      	^^NatLangDeclarativeSentence
	[*
	  toName,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->dataStruct_insertZ(theSpRunSubject),
      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toBeAllowed,
	  inGeneralPresentNatLangTense,
	  negateNatLangStatus,
	  @phraseDS
	*],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
  //  End computeValue()

*};


//  PURPOSE:  To map from 'NameReservedException' instances to the 'Idea'
//	instance that could not be renamed.
nameReservedExceptionsToRenameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'NameReservedException' instances to the name
//	that is reserved.
nameReservedExceptionsReservedNameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent the exception of attempting to rename something to
//	a name that already is reserved.
NameReservedException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [*
	    [ [nameReservedExceptionsToRenameA, Idea],
	      [nameReservedExceptionsReservedNameA, String]
	    ]
	  *]
	);

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'NameAlreadyTakenException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException, Exception, @this *],
      ^VarDecl
      [*
	@toRename,
	Idea,
	@thisException->localGet(nameReservedExceptionsToRenameA)
      *],
      ^VarDecl
      [*
	@reservedName,
	Idea,
	@thisException->localGet(nameReservedExceptionsReservedNameA)
      *],

      //  "The Sp run cannot rename <nameReservedExceptionsToRenameA>
      //   to <nameReservedExceptionsReservedNameA> because
      //   <nameReservedExceptionsReservedNameA> is reserved."

      //  II.B.  "because <nameReservedExceptionsReservedNameA> is reserved."
      ^VarDecl[* @phraseDS, VectorList, ^^VectorList[**] *],

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @reservedName,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toBeReserved,
	  completedPresentNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  becauseOfNatLangPhraseRole
	*]
      *],

      //  II.C.  "<nameAlreadyTakenExceptionsToRenameA>
      //   to <nameReservedExceptionsReservedNameA> because
      //   <nameReservedExceptionsReservedNameA> is assigned."
      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @toRename,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

        @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @reservedName,
		    towardNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toName,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  directObjectNatLangPhraseRole
	*],

      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->dataStruct_insertZ(theSpRunSubject),
      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toBeAllowed,
	  inGeneralPresentNatLangTense,
	  negateNatLangStatus,
	  @phraseDS
	*],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
  //  computeValue

*};
//  NameReservedException


//  PURPOSE:  To map from 'IllegalPrefixException' instances to the 'Idea'
//	instance that could not be renamed.
illegalPrefixExceptionsToRenameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'IllegalPrefixException' instances to the desired
//	name with the illegal prefix.
illegalPrefixExceptionsIllegalPrefixedNameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent the exception of attempting to rename something to
//	a name with an illegal prefix.
IllegalPrefixException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [*
	    [ [illegalPrefixExceptionsToRenameA, Idea],
	      [illegalPrefixExceptionsIllegalPrefixedNameA, String]
	    ]
	  *]
	);

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'NameAlreadyTakenException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException, Exception, @this *],
      ^VarDecl
      [*
	@toRename,
	Idea,
	@thisException->localGet(illegalPrefixExceptionsToRenameA)
      *],
      ^VarDecl
      [*
	@illegalName,
	Idea,
	@thisException->localGet(illegalPrefixExceptionsIllegalPrefixedNameA)
      *],

      //  "The Sp run cannot rename <illegalPrefixExceptionsToRenameA>
      //   to <illegalPrefixExceptionsIllegalPrefixedNameA> because
      //   <illegalPrefixExceptionsIllegalPrefixedNameA> has an illegal prefix."

      //  II.B.  "because <illegalPrefixExceptionsIllegalPrefixedNameA> has an
      //  	  illegal prefix."
      ^VarDecl[* @phraseDS, VectorList, ^^VectorList[**] *],

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @illegalName,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		),

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    aPrefix,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    illegal
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toHaveTheProperty,
	  completedPresentNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  becauseOfNatLangPhraseRole
	*]
      *],

      //  II.C.  "<illegalPrefixExceptionsToRenameA> to
      //   <illegalPrefixExceptionsIllegalPrefixedNameA> because
      //   <illegalPrefixExceptionsIllegalPrefixedNameA> has an illegal prefix."
      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @toRename,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

        @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @illegalName,
		    towardNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toName,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  directObjectNatLangPhraseRole
	*],

      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->dataStruct_insertZ(theSpRunSubject),
      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toBeAllowed,
	  inGeneralPresentNatLangTense,
	  negateNatLangStatus,
	  @phraseDS
	*],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
*};
//  IllegalPrefixException


//  PURPOSE:  To map from 'NameAlreadyTakenException' instances to the 'Idea'
//	instance that could not be renamed.
nameAlreadyTakenExceptionsToRenameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'NameAlreadyTakenException' instances to the name
//	that is already being used.
nameAlreadyTakenExceptionsTakenNameA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent the exception of attempting to rename something to
//	a name that already is taken.
NameAlreadyTakenException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	( ^ImplicitConstructor
	  [*
	    [ [nameAlreadyTakenExceptionsToRenameA, Idea],
	      [nameAlreadyTakenExceptionsTakenNameA, String]
	    ]
	  *]
	);

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'NameAlreadyTakenException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException, Exception, @this *],
      ^VarDecl
      [*
	@toRename,
	Idea,
	@thisException->localGet(nameAlreadyTakenExceptionsToRenameA)
      *],
      ^VarDecl
      [*
	@takenName,
	Idea,
	@thisException->localGet(nameAlreadyTakenExceptionsTakenNameA)
      *],

      //  "The Sp run cannot rename <nameAlreadyTakenExceptionsToRenameA>
      //   to <nameAlreadyTakenExceptionsTakenNameA> because
      //   <nameAlreadyTakenExceptionsTakenNameA> is assigned."

      //  II.B.  "because <nameAlreadyTakenExceptionsTakenNameA> is assigned."
      ^VarDecl[* @phraseDS, VectorList, ^^VectorList[**] *],

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @takenName,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toAssignAValueTo,
	  completedPresentNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  becauseOfNatLangPhraseRole
	*]
      *],

      //  II.C.  "<nameAlreadyTakenExceptionsToRenameA>
      //   to <nameAlreadyTakenExceptionsTakenNameA> because
      //   <nameAlreadyTakenExceptionsTakenNameA> is assigned."
      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @toRename,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

        @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @takenName,
		    towardNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toName,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  directObjectNatLangPhraseRole
	*],

      @phraseDS	:= ^^VectorList[**],
      @phraseDS->dataStruct_insertZ(@sentence),
      @phraseDS->dataStruct_insertZ(theSpRunSubject),
      @sentence	:=
      	^^NatLangDeclarativeSentence
	[*
	  toBeAllowed,
	  inGeneralPresentNatLangTense,
	  negateNatLangStatus,
	  @phraseDS
	*],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
  //  computeValue

*};


thisSE->parseFile("EmpiricalEntityA.som8");
/?-------------------------------------------------------------------------?
 ?---									---?
 ?---		EmpiricalEntityA.som8					---?
 ?---									---?
 ?---	    This file defines knowledge of empirical attributes.	---?
 ?---									---?
 ?---	----	----	----	----	----	----	----	----	---?
 ?---									---?
 ?---	Version 8b		2014 November 17	Joseph Phillips	---?
 ?---									---?
 ?-------------------------------------------------------------------------?/


//									//
//	Definition of methods needed by class 'EmpiricalEntityA':	//
//									//

//  PURPOSE:  To map from
//	'AttemptToRegisterContradictoryAttributeResultsException' instances to
//	the operator that is being doubly-registered.
attemptToRegisterContradictoryAttributeResultsExceptsOperatorA
{*
  instanceOf->assertZ(ExceptionA);
*};


//  PURPOSE:  To map from
//	'AttemptToRegisterContradictoryAttributeResultsException' instances to
//	the list of operand attributes that is being doubly-registered.
attemptToRegisterContradictoryAttributeResultsExceptsOperandListA
{*
  instanceOf->assertZ(ExceptionA);
*};


//  PURPOSE:  To map from
//	'AttemptToRegisterContradictoryAttributeResultsException' instances to
//	the existing resulting attribute that is already registered.
attemptToRegisterContradictoryAttributeResultsExceptsOldResultA
{*
  instanceOf->assertZ(ExceptionA);
*};


//  PURPOSE:  To map from
//	'AttemptToRegisterContradictoryAttributeResultsException' instances to
//	the new resulting attribute attempting to be registered that differs
//	from the old.
attemptToRegisterContradictoryAttributeResultsExceptsNewResultA
{*
  instanceOf->assertZ(ExceptionA);
*};


//  PURPOSE:  To represent an attempt to register contradictory attribute
//	results by EmpiricalEntityA's register().
AttemptToRegisterContradictoryAttributeResultsException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      (	^ImplicitConstructor
      	[*
	  [ [ attemptToRegisterContradictoryAttributeResultsExceptsOperatorA,
	      Operator
	    ],
	    [ attemptToRegisterContradictoryAttributeResultsExceptsOperandListA,
	      List
	    ],
	    [ attemptToRegisterContradictoryAttributeResultsExceptsOldResultA,
	      EmpiricalEntityA
	    ],
	    [ attemptToRegisterContradictoryAttributeResultsExceptsNewResultA,
	      EmpiricalEntityA
	    ]
	  ]
	*]
      );


  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantDimensionException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      ^VarDecl[* @thisException, SPDefinedException, @this *],
      ^VarDecl
      [*
	@operator,
	Operator,
	@thisException->localGet
	    (attemptToRegisterContradictoryAttributeResultsExceptsOperatorA)
      *],
      ^VarDecl
      [*
	@operandList,
	List,
	@thisException->localGet
	    (attemptToRegisterContradictoryAttributeResultsExceptsOperandListA)
      *],
      ^VarDecl
      [*
        @operand0,
	EmpiricalEntityA,
	@operandList->list_firstItem()
      *],
      ^VarDecl
      [*
        @operand1,
	EmpiricalEntityA,
	@operandList->list_secondItem()
      *],
      ^VarDecl
      [*
	@oldAttr,
	EmpiricalEntityA,
	@thisException->localGet
	    (attemptToRegisterContradictoryAttributeResultsExceptsOldResultA)
      *],
      ^VarDecl
      [*
	@newAttr,
	EmpiricalEntityA,
	@thisException->localGet
	    (attemptToRegisterContradictoryAttributeResultsExceptsNewResultA)
      *],

      //  "The Sp run attempted to register a contradictory mapping named
      //   '<operator> x <operands> -> <new>' because a mapping named
      //   '<operator> x <operands> -> <old>' exists."

      //  II.A.  "named '<operator> x <operands> -> <new>'":
      ^VarDecl[* @innerPhraseDS, VectorList, ^^VectorList[**] *],
      ^VarDecl
      [*
	@transformString,
	String,
	( ^If
	  [*
	    @operand1->isNull(),
	    @operator->toString() +con "(" +con @operand0->toString() +con ")",
	    @operand0->toString() +con " " +con @operator->toString() +con " "
	      +con @operand1->toString()
	  *]
	  +con " -> " +con @newAttr->toString()
	)
      *],

      @transformString	:= "\"" +con @transformString +con "\"",

      @innerPhraseDS->
	dataStruct_insertZ
	  ( ^^NatLangRolePhrase
	    [*
	      @transformString,
	      directObjectNatLangPhraseRole,
	      thirdPerson,
	      singularPlurality,
	      false
	    *]
	  ),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toName,
	  inGeneralPresentNatLangTense,
	  affirmNatLangStatus,
	  @innerPhraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      //  II.B.  "a contradictory mapping named '<op> x <operands> -> <new>'"
      ^VarDecl[* @outerPhraseDS, VectorList, ^^VectorList[**] *],

      @outerPhraseDS->
	dataStruct_insertZ
	  ( ^^NatLangRolePhrase
	    [*
	      aMapping,
	      directObjectNatLangPhraseRole,
	      thirdPerson,
	      singularPlurality,
	      false,
	      contradictory,
	      ^^NatLangDeclarativeSentence
	      [*
		toName,
		inGeneralPresentNatLangTense,
		affirmNatLangStatus,
		@innerPhraseDS,
		directObjectNatLangPhraseRole
	      *]
	    *]
	  ),

      //  II.C.  "because a mapping named '<op> x <operands> -> <old>' exists"
      @innerPhraseDS	:= ^^VectorList[**],
      @transformString	:=
	( ^If
	  [*
	    @operand1->isNull(),
	    @operator->toString() +con "(" +con @operand0->toString() +con ")",
	    @operand0->toString() +con " " +con @operator->toString() +con " "
	      +con @operand1->toString()
	  *]
	  +con " -> " +con @oldAttr->toString()
	),

      @transformString	:= "\"" +con @transformString +con "\"",

      @innerPhraseDS->
	dataStruct_insertZ
	  ( ^^NatLangRolePhrase
	    [*
	      @transformString,
	      directObjectNatLangPhraseRole,
	      thirdPerson,
	      singularPlurality,
	      false
	    *]
	  ),

      @outerPhraseDS->
	dataStruct_insertZ
	  ( ^^NatLangRolePhrase
	    [*
	      aMapping,
	      becauseOfNatLangPhraseRole,
	      thirdPerson,
	      singularPlurality,
	      false,
	      ^^NatLangDeclarativeSentence
	      [*
		toName,
		inGeneralPresentNatLangTense,
		affirmNatLangStatus,
		@innerPhraseDS,
		directObjectNatLangPhraseRole
	      *],
	      ^^NatLangDeclarativeSentence
	      [*
		toExist,
		inGeneralPresentNatLangTense,
		affirmNatLangStatus,
		[],
		directObjectNatLangPhraseRole
	      *]
	    *]
	  ),

      //  II.D.  "to register a contradictory mapping named
      //	  '<operator> x <operands> -> <new>' because a mapping named
      //	  '<operator> x <operands> -> <old>' exists."
      @sentence	:=
	^^NatLangDeclarativeSentence
	[*
	  toRegister,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @outerPhraseDS,
	  directObjectNatLangPhraseRole
	*],

       @outerPhraseDS := ^^VectorList[**],

       @outerPhraseDS->dataStruct_insert(@sentence),
       @outerPhraseDS->dataStruct_insert(theSpRunSubject),

       @sentence	:=
	^^NatLangDeclarativeSentence
	[*
	  toAttempt,
	  inGeneralPastNatLangTense,
	  affirmNatLangStatus,
	  @outerPhraseDS,
	  directObjectNatLangPhraseRole
	*],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];

*};


EmpiricalEntityA
{*

  //  PURPOSE:  To register that '@operator' operating on operands whose
  //		attributes are listed in '@operandList' result in a value
  //		whose attribute is '@resultingAttr'.  Returns '@resultingAttr'
  //		on success.  Throws an instance of
  //		'AttemptToRegisterContradictoryAttributeResultsException'
  //		if an attempt to register contradictory attribute results was
  //		made.
  register	Idea
  [*
    [ [ @operator,	Operator],
      [ @operandList,	List],
      [ @resultingAttr,	EmpiricalEntityA]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Register that '@operator' operating on the attributes listed
      //       as they are ordered in '@operandList' result in attribute
      //       '@resultingAttr':

      //  II.A.  Get a singleDistinct version of '@operandList':
      @operandList := @operandList->getEquivalentSingleDistinct(),

      //  II.B.  Get datastructure that holds all registered transformations:
      //  II.B.1.  Attempt to get datastructure:
      ^VarDecl
      [*
	@mapOfMaps,
	Map,
	EmpiricalEntityA->localGet(empiricalEntityAttrClassesOperatorToMapMapA)
      *],

      //  II.B.1.  Create datastructure if does not already exist:
      ^If
      [*
        @mapOfMaps->isNull(),
	EmpiricalEntityA->
	    assert
		(empiricalEntityAttrClassesOperatorToMapMapA,
		 @mapOfMaps := ^^Map[**]
		)
      *],

      //  II.C.  Get sub-datastructure of transformations registered for
      //  	 '@operator':
      //  II.C.1.  Attempt to get datastructure:
      ^VarDecl
      [*
        @mapToResults,
	Map,
	@mapOfMaps->map_get(@operator)
      *],

      //  II.C.2.  Create datastructure if does not already exist:
      ^If
      [*
	@mapToResults->isNull(),
	@mapOfMaps->map_put(@operator,@mapToResults := ^^Map[**])
      *],

      //  II.D.  Register '@operandList' in '@mapToResults':
      //  II.D.1.   See if there already if something registered:
      ^VarDecl
      [*
	@existingValue,
	EmpiricalEntityA,
	@mapToResults->map_get(@operandList)
      *],

      ^If
      [*
	@existingValue->isNull(),

	//  II.D.2.  Register if nothing is there already:
	@mapToResults->map_put(@operandList,@resultingAttr),

	//  II.D.3.  Something already is registered.  Take no action if
	//  	     it is the same as '@resultingAttr', otherwise complain
	//	     about double-registering:
	^If
	[*
	  @existingValue !=ref @resultingAttr,
	  ^Throw
	  [*
	    ^^AttemptToRegisterContradictoryAttributeResultsException
	    [*
	      @operator,
	      @operandList,
	      @existingValue,
	      @resultingAttr
	    *]
	  *]
	*]
      *],

      //  III.  Finished:
      ^Return[* @resultingAttr *]
    ]*]

  *];	// register


  //  PURPOSE:  To return the 'EmpiricalEntityA' instance that results from
  //  	operator '@operator' operating on the attributes listed in
  //	'@operandList'.  Returns 'null' if no attribute has been registered.
  getResult	EmpiricalEntityA
  [*
    [ [ @operator,	Operator],
      [ @operandList,	List]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Get registered attribute:
      //  II.A.  Get datastructure that holds all registered transformations:
      //  II.A.1.  Attempt to get datastructure:
      ^VarDecl
      [*
	@mapOfMaps,
	Map,
	EmpiricalEntityA->localGet(empiricalEntityAttrClassesOperatorToMapMapA)
      *],

      //  II.A.2.  Give up if no datastructure that holds all registered
      //  	   transformations exists:
      ^If
      [*
	@mapOfMaps->isNull(),
	^Return[* null *]
      *],

      //  II.B.  Get sub-datastructure of transformations registered for
      //  	 '@operator':
      //  II.B.1.  Attempt to get datastructure:
      ^VarDecl
      [*
        @mapToResults,
	Map,
	@mapOfMaps->map_get(@operator)
      *],

      //  II.B.2.  Give up if no sub-datastructure of transformations
      //	   registered for '@operator':
      ^If
      [*
	@mapToResults->isNull(),
	^Return[* null *]
      *],

      //  II.C.  Attempt to get registered resulting attribute:
      //  II.C.1.  Get a singleDistinct version of '@operandList':
      @operandList	:= @operandList->getEquivalentSingleDistinct(),

      //  III.  Finished:
      ^Return[* @mapToResults->map_get(@operandList) *]

    ]*]

  *];	// getResult
*};




MultidimensionalNumericEmpiricalEntityA
{*
  isA->assertZ(NumericEmpiricalEntityA);
*};


//			    distance Attributes:			//

SignedSpatialA
{*
  isA->assertZ(NumericEmpiricalEntityA);

  attributeSetsGenericMemberA->assertZ(genericSignedSpatialA);

  isMagnitudeAttrA->subAssert(false);
  isSignedAttrA->subAssert(true);
  signedAttrsMagnitudeAttrA->subAssertZ(genericLengthA);
*};

genericSignedSpatialA
{*
  instanceOf->assertZ(SignedSpatialA);
*};


DistanceA
{*
  isA->assertZ(NumericEmpiricalEntityA);

  attributeSetsGenericMemberA->assertZ(genericDistanceA);
*};

genericDistanceA
{*
  instanceOf->assertZ(DistanceA);
*};

heightAboveReferenceA
{*
  instanceOf->assertZ(DistanceA);
*};

depthBelowReferenceA
{*
  instanceOf->assertZ(DistanceA);
*};


LengthA
{*
  isA->assertZ(DistanceA);

  attributeSetsGenericMemberA->assertZ(genericLengthA);

  isMagnitudeAttrA->subAssert(true);
  isSignedAttrA->subAssert(false);
  magnitudeAttrsSignedAttrA->subAssertZ(genericSignedSpatialA);
*};

genericLengthA
{*
  instanceOf->assertZ(LengthA);
*};

majorAxisLengthA
{*
  instanceOf->assertZ(LengthA);
*};

minorAxisWidthA
{*
  instanceOf->assertZ(LengthA);
*};

sideToSideWidthA
{*
  instanceOf->assertZ(LengthA);
*};

frontToBackThicknessA
{*
  instanceOf->assertZ(LengthA);
*};

sheetThicknessA
{*
  instanceOf->assertZ(LengthA);
*};

tallnessA
{*
  instanceOf->assertZ(LengthA);
*};

radiusA
{*
  instanceOf->assertZ(LengthA);
*};

semiMajorAxisLenA
{*
  instanceOf->assertZ(LengthA);
*};

semiMinorAxisLenA
{*
  instanceOf->assertZ(LengthA);
*};

aphelionA
{*
  instanceOf->assertZ(LengthA);
*};

perihelionA
{*
  instanceOf->assertZ(LengthA);
*};

siderealOrbitPeriod
{*
  instanceOf->assertZ(LengthA);
*};


EmpiricalEntityA->
	register('+grp,[genericLengthA,genericLengthA],genericLengthA);
EmpiricalEntityA->
	register('+grp,[majorAxisLengthA,majorAxisLengthA],majorAxisLengthA);
EmpiricalEntityA->
	register('+grp,[minorAxisWidthA,minorAxisWidthA],minorAxisWidthA);
EmpiricalEntityA->
	register('+grp,[sideToSideWidthA,sideToSideWidthA],sideToSideWidthA);
EmpiricalEntityA->
	register('+grp,[frontToBackThicknessA,frontToBackThicknessA],frontToBackThicknessA);
EmpiricalEntityA->
	register('+grp,[sheetThicknessA,sheetThicknessA],sheetThicknessA);
EmpiricalEntityA->
	register('+grp,[tallnessA,tallnessA],tallnessA);
EmpiricalEntityA->
	register('+grp,[radiusA,radiusA],genericLengthA);

EmpiricalEntityA->
	register('+ext,[genericLengthA,genericLengthA],genericLengthA);
EmpiricalEntityA->
	register('+ext,[majorAxisLengthA,majorAxisLengthA],majorAxisLengthA);
EmpiricalEntityA->
	register('+ext,[minorAxisWidthA,minorAxisWidthA],minorAxisWidthA);
EmpiricalEntityA->
	register('+ext,[sideToSideWidthA,sideToSideWidthA],sideToSideWidthA);
EmpiricalEntityA->
	register('+ext,[frontToBackThicknessA,frontToBackThicknessA],frontToBackThicknessA);
EmpiricalEntityA->
	register('+ext,[sheetThicknessA,sheetThicknessA],sheetThicknessA);
EmpiricalEntityA->
	register('+ext,[tallnessA,tallnessA],tallnessA);
EmpiricalEntityA->
	register('+ext,[radiusA,radiusA],genericLengthA);



//			    Area Attributes:				//

AreaA
{*
  isA->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};

genericAreaA
{*
  instanceOf->assertZ(AreaA);
*};

//  PURPOSE:  To represent the area attribute for outside area, perhaps warped
//	into 3rd dimension.
surfaceAreaA
{*
  instanceOf->assertZ(AreaA);
*};

crossSectionAreaA
{*
  instanceOf->assertZ(AreaA);
*};

//  PURPOSE:  To represent the area attribute that is a special-case of
//	cross-sectional area in which only the "bottom" of the object is
//	cross-sectioned.  Does *not* include 'tallnessA'.
footprintAreaA
{*
  instanceOf->assertZ(AreaA);
*};


//				Volume Attributes:			//

volumeA
{*
  instanceOf->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};



//				angle Attributes:			//
AngularPositionA
{*
  isA->assertZ(NumericEmpiricalEntityA);
  attributeSetsGenericMemberA->assertZ(angleA);

  isMagnitudeAttrA->subAssert(false);
  isSignedAttrA->subAssert(true);
  signedAttrsMagnitudeAttrA->subAssertZ(arcA);
*};

angleA
{*
  instanceOf->assertZ(AngularPositionA);
*};

latitudeA
{*
  instanceOf->assertZ(AngularPositionA);
*};


longitudeA
{*
  instanceOf->assertZ(AngularPositionA);
*};

ArcA
{*
  isA->assertZ(NumericEmpiricalEntityA);

  attributeSetsGenericMemberA->assertZ(arcA);

  isMagnitudeAttrA->subAssert(true);
  isSignedAttrA->subAssert(false);
  signedAttrsMagnitudeAttrA->subAssertZ(arcA);
*};

arcA
{*
  instanceOf->assertZ(ArcA);
*};


//			Time Attributes:			//

TimeExtentA
{*
  isA->assertZ(NumericEmpiricalEntityA);
*};


TimeA
{*
  isA->assertZ(TimeExtentA);

  attributeSetsGenericMemberA->assertZ(genericTimeA);

  isMagnitudeAttrA->subAssert(false);
  isSignedAttrA->subAssert(true);
  signedAttrsMagnitudeAttrA->subAssertZ(genericDurationA);
*};

timeA
{*
  instanceOf->assertZ(TimeA);
*};


genericTimeA
{*
  instanceOf->assertZ(TimeA);
*};


startTimeA
{*
  instanceOf->assertZ(TimeA);
*};


endTimeA
{*
  instanceOf->assertZ(TimeA);
*};


midDurationTimeA
{*
  instanceOf->assertZ(TimeA);
*};


DurationA
{*
  isA->assertZ(TimeExtentA);

  attributeSetsGenericMemberA->assertZ(genericDurationA);

  isMagnitudeAttrA->subAssert(true);
  isSignedAttrA->subAssert(false);
  magnitudeAttrsSignedAttrA->subAssertZ(genericTimeA);
*};


genericDurationA
{*
  instanceOf->assertZ(DurationA);
*};


//				Mass Attributes:			//

MatterExtentA
{*
  isA->assertZ(NumericEmpiricalEntityA);
*};

MassA
{*
  isA->assertZ(MatterExtentA);
  attributeSetsGenericMemberA->assertZ(genericMassA);

  isMagnitudeAttrA->subAssert(true);
  isSignedAttrA->subAssert(false);
  // magnitudeAttrsSignedAttrA->subAssertZ(----);
*};

genericMassA
{*
  instanceOf->assertZ(MassA);
*};


//				Charge Attributes:			//

ChargeA
{*
  isA->assertZ(MatterExtentA);

  attributeSetsGenericMemberA->assertZ(genericChargeA);

  isMagnitudeAttrA->subAssert(false);
  isSignedAttrA->subAssert(true);
  // signedAttrsMagnitudeAttrA->subAssertZ(----);
*};

genericChargeA
{*
  instanceOf->assertZ(ChargeA);
*};


//			    Magnetic Attributes				//


//			Temperature Attributes:		//


//			    NuclearColor Attributes:			//


//			    NuclearSpin Attributes:			//


//			    InverseTime Attributes:			//

frequencyA
{*
  instanceOf->assertZ(NumericEmpiricalEntityA);
*};

//			DistanceOverTimeDimension Attributes:		//

DistanceOverTimeA
{*
  isA->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};

VelocityA
{*
  isA->assertZ(DistanceOverTimeA);

  attributeSetsGenericMemberA->assertZ(genericVelocityA);

  isMagnitudeAttrA->subAssert(false);
  isSignedAttrA->subAssert(true);
  signedAttrsMagnitudeAttrA->subAssertZ(genericSpeedA);
*};


genericVelocityA
{*
  instanceOf->assertZ(VelocityA);
*};


SpeedA
{*
  isA->assertZ(DistanceOverTimeA);

  attributeSetsGenericMemberA->assertZ(genericSpeedA);

  isMagnitudeAttrA->subAssert(true);
  isSignedAttrA->subAssert(false);
  magnitudeAttrsSignedAttrA->subAssertZ(genericVelocityA);
*};

genericSpeedA
{*
  instanceOf->assertZ(SpeedA);
*};


//			    Acceleration Attributes:			//
AccelerationA
{*
  isA->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};

inducedGravityAccelA
{*
  instanceOf->assertZ(AccelerationA);
*};


//			    Momentum Attributes:			//
MomentumA
{*
  isA->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};


//			    Force Attributes:				//
ForceA
{*
  isA->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};


//			    Energy Attributes:				//
EnergyA
{*
  isA->assertZ(MultidimensionalNumericEmpiricalEntityA);
*};
/? --- end of file --- ?/

thisSE->parseFile("DimensionsUnitsDomains.som8");
/?-------------------------------------------------------------------------?
 ?---									---?
 ?---		DimensionsUnitsDomains.som8				---?
 ?---									---?
 ?---	    This file section defines knowledge of dimensions, their	---?
 ?---	units and their domains.					---?
 ?---									---?
 ?---	----	----	----	----	----	----	----	----	---?
 ?---									---?
 ?---	Version 8b		2013 February 16	Joseph Phillips	---?
 ?---									---?
 ?-------------------------------------------------------------------------?/

//									//
//				Dimension				//
//									//

//  PURPOSE:  To map from 'ArgumentInWrongDimensionException' instances to
//	the function family which they describe.
argumentInWrongDimensionExceptionsFncFamilyA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'ArgumentInWrongDimensionException' instances to
//	the 'Dimension' instance that the function family requires.
argumentInWrongDimensionExceptionsRequiredDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'ArgumentInWrongDimensionException' instances to
//	the 'Dimension' instance that the function family was given in error.
argumentInWrongDimensionExceptionsGivenDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent an attempt to call a function with an argument
//	that has the wrong dimension.
ArgumentInWrongDimensionException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [argumentInWrongDimensionExceptionsFncFamilyA,
	     Idea
	    ],
	    [argumentInWrongDimensionExceptionsRequiredDimA,
	     Dimension
	    ],
	    [argumentInWrongDimensionExceptionsGivenDimA,
	     Dimension
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantDimensionException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@fncFamily,
	Idea,
	@thisException->localGet(argumentInWrongDimensionExceptionsFncFamilyA)
      *],
      ^VarDecl
      [*
	@requiredDim,
	Idea,
	@thisException->localGet(argumentInWrongDimensionExceptionsRequiredDimA)
      *],
      ^VarDecl
      [*
	@givenDim,
	Idea,
	@thisException->localGet(argumentInWrongDimensionExceptionsGivenDimA)
      *],

      //  "The function named @fncFamily needs dimension @desiredDim,
      //   not @givenDim"
      ^VarDecl[* @outerPhraseDS, VectorList, ^^VectorList[**] *],

      //  "not @givenDim"
      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    redundant,
		    ^^NatLangRolePhrase
		    [*
		      Dimension,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false,
		      ^^NatLangDeclarativeSentence
		      [*
			toName,
			inGeneralPresentNatLangTense,
			affirmNatLangStatus,
			@requiredDim,
			directObjectNatLangPhraseRole
		      *]
		    *]
		  *]
		),

      //  "dimension @desiredDim,"
      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    notObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    redundant,
		    ^^NatLangRolePhrase
		    [*
		      Dimension,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false,
		      ^^NatLangDeclarativeSentence
		      [*
			toName,
			inGeneralPresentNatLangTense,
			affirmNatLangStatus,
			@givenDim,
			directObjectNatLangPhraseRole
		      *]
		    *]
		  *]
		),

      //  "The function named @fncFamily"
      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true,
		    redundant,
		    ^^NatLangRolePhrase
		    [*
		      FncsFamily,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false,
		      ^^NatLangDeclarativeSentence
		      [*
			toName,
			inGeneralPresentNatLangTense,
			affirmNatLangStatus,
			@fncFamily,
			directObjectNatLangPhraseRole
		      *]
		    *]
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toNeed,
	  inGeneralPresentNatLangTense,
	  affirmNatLangStatus,
	  @outerPhraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
  //  computeValue

*};


//  PURPOSE:  To map from 'ExpectedDimensionRaisedToIntegerPowerException'
//	instances to the dimension for which there is a problem.
expectedDimensionRaisedToIntegerPowerExceptionsDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'ExpectedDimensionRaisedToIntegerPowerException'
//	instances to the annotated value the system is attempting to raise to
//	a power.
expectedDimensionRaisedToIntegerPowerExceptionsAnnotatedValueA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'ExpectedDimensionRaisedToIntegerPowerException'
//	instances to the power the system is attempting to use.
expectedDimensionRaisedToIntegerPowerExceptionsBadPowerA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent the error of trying to raise a dimension in a
//	non-annotated value to a non-integer power
ExpectedDimensionRaisedToIntegerPowerException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [ expectedDimensionRaisedToIntegerPowerExceptionsDimA,
	      Dimension
	    ],
	    [ expectedDimensionRaisedToIntegerPowerExceptionsAnnotatedValueA,
	      AnnotatedValue
	    ],
	    [ expectedDimensionRaisedToIntegerPowerExceptionsBadPowerA,
	      Number
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantDimensionException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@dimension,
	Idea,
	@thisException->
		localGet(expectedDimensionRaisedToIntegerPowerExceptionsDimA)
      *],
      ^VarDecl
      [*
	@value,
	AnnotatedValue,
	@thisException->
	    localGet
	      (expectedDimensionRaisedToIntegerPowerExceptionsAnnotatedValueA)
      *],
      ^VarDecl
      [*
	@badPower,
	Number,
	@thisException->
	    localGet
		(expectedDimensionRaisedToIntegerPowerExceptionsBadPowerA)
      *],

      //  "'@dimension' was not raised to an integer power for '@value'
      //   instead of '@badPower'"
      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toRaiseToAPower,
	  inGeneralPastNatLangTense,
	  negateNatLangStatus,
	  ^^VectorList[**]->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    aMathematicalPower,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    ^^NatLangRolePhrase
		    [*
		      anInteger,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false
		    *]
		  *]
		)->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @dimension,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		)->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @value,
		    forThePurposeOfNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		)->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @badPower,
		    notObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		)
	*]
      *],
      
      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
  
*};


//  PURPOSE:  To map from an 'AttemptToRegisterRedundantDimensionException'
//	instance to the already registered dimension.
attemptToRegisterRedundantDimensionExceptionsAlreadyRegisteredDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an 'AttemptToRegisterRedundantDimensionException'
//	instance to the dimension that was redundantly attempted to register.
attemptToRegisterRedundantDimensionExceptionsRedundandDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent an attempt to register a redundant dimension.
AttemptToRegisterRedundantDimensionException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [attemptToRegisterRedundantDimensionExceptionsAlreadyRegisteredDimA,
	     Idea
	    ],
	    [attemptToRegisterRedundantDimensionExceptionsRedundandDimA,
	     Idea
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantDimensionException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@redundant,
	Idea,
	@thisException->localGet
	  (attemptToRegisterRedundantDimensionExceptionsRedundandDimA)
      *],
      ^VarDecl
      [*
	@original,
	Idea,
	@thisException->localGet
	  (attemptToRegisterRedundantDimensionExceptionsAlreadyRegisteredDimA)
      *],


      //  "The sp8b attempted to register an instance of a dimension named
      //   <redundant> that is redundant with <original>"

      //  "<redundant>"
      ^VarDecl[* @innerPhraseDS, VectorList, ^^VectorList[**] *],

      @innerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @redundant,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      //  "to register an instance of a dimension named <redundant>"
      ^VarDecl[* @outerPhraseDS, VectorList, ^^VectorList[**] *],

      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    redundant,
		    ^^NatLangRolePhrase
		    [*
		      Dimension,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false,
		      ^^NatLangDeclarativeSentence
		      [*
			toName,
			inGeneralPresentNatLangTense,
			affirmNatLangStatus,
			@innerPhraseDS,
			directObjectNatLangPhraseRole
		      *]
		    *]
		  *]
		),
      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @original,
		    relativeToNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toRegister,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @outerPhraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      //  "The sp8b attempted to register an instance of a dimension named
      //   <redundant>":
      @outerPhraseDS	:= ^^VectorList[**],
      @outerPhraseDS->dataStruct_insertZ(theSpRunSubject),
      @outerPhraseDS->dataStruct_insertZ(@sentence),
      @sentence	:=  ^^NatLangDeclarativeSentence
		    [*
		      toAttempt,
		      inGeneralPastNatLangTense,
		      affirmNatLangStatus,
		      @outerPhraseDS,
		      directObjectNatLangPhraseRole
		    *],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]

    ]*]
  *];	// computeValue

*};


//  PURPOSE:  To map from an 'AttemptToRegisterConflictingOpDimResultException'
//	instance to the 'Operand' instance that yields the conflict.
attemptToRegisterConflictingOpDimResultExceptionsOperatorA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an 'AttemptToRegisterConflictingOpDimResultException'
//	instance to the 'Dimension' instance(s) that yields the conflict.
attemptToRegisterConflictingOpDimResultExceptionsOperandDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an 'AttemptToRegisterConflictingOpDimResultException'
//	instance to the 'Dimension' instance that conflicts with what was
//	recorded earlier.
attemptToRegisterConflictingOpDimResultExceptionsNewResultDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an 'AttemptToRegisterConflictingOpDimResultException'
//	instance to the 'Dimension' instance that conflicts with a newly
//	'Dimension' instance that has been attempted to record.
attemptToRegisterConflictingOpDimResultExceptionsRecordedDimA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent an attempt to a conflicting 'Dimension' instance
//	that results from applying an 'Operator' instance upon a 'Dimension'
//	instance.
AttemptToRegisterConflictingOpDimResultException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [attemptToRegisterConflictingOpDimResultExceptionsOperatorA,
	     Operator
	    ],
	    [attemptToRegisterConflictingOpDimResultExceptionsOperandDimA,
	     Dimension
	    ],
	    [attemptToRegisterConflictingOpDimResultExceptionsNewResultDimA,
	     Dimension
	    ],
	    [attemptToRegisterConflictingOpDimResultExceptionsRecordedDimA,
	     Dimension
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterConflictingOpDimResultException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@operator,
	Operator,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDimResultExceptionsOperatorA)
      *],
      ^VarDecl
      [*
	@operandDim,
	Dimension,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDimResultExceptionsOperandDimA)
      *],
      ^VarDecl
      [*
	@newResultDim,
	Dimension,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDimResultExceptionsNewResultDimA)
      *],
      ^VarDecl
      [*
	@recordedDim,
	Dimension,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDimResultExceptionsRecordedDimA)
      *],


      //  "The sp8b attempted to register an instance of a dimension named
      //   <redundant> that is redundant with <original>"

      //  "The sp8b attempted to register <@operator,@operandDim> ->
      //   <@newResultDim> that conflicts with <@operator,@operandDim> ->
      //   <@recordedDim>."

      //  "<@operator,@operandDim>"
      ^VarDecl
      [*
	@key,
	String,
	"<" +con @operator->toString() +con
	 "," +con @operandDim->toString() +con ">"
      *],

      //  "<@operator,@operandDim> -> <@newResultDim>"
      ^VarDecl
      [*
	@toRegisterString,
	String,
	@key +con " -> " +con @newResultDim->toString()
      *],

      //  "<@operator,@operandDim> -> <@recordedDim>."
      ^VarDecl
      [*
	@conflictWithString,
	String,
	@key +con " -> " +con @recordedDim->toString()
      *],

      // "that conflicts with <@operator,@operandDim> -> <@recordedDim>"

      ^VarDecl[* @innerPhraseDS, VectorList, ^^VectorList[**] *]


    ]*]
  *];
  
*};

//  PURPOSE:  To map from the *class* 'Dimension' to a map that stores the
//	'Dimension' instance that result when two 'Dimension' instances are
//	multiplied together.
dimensionClassesMultiplicativeResultMapA
{*
  instanceOf->assertZ(DimensionA);
*};

//  PURPOSE:  To map from the *class* 'Dimension' to a map that stores the
//	'Dimension' instance that result when an operator operates on a
//	'Dimension' instance.
dimensionClassesUnaryOpResultMapA
{*
  instanceOf->assertZ(DimensionA);
*};

//  PURPOSE:  To represent the class of dimensions used in annotated values.
Dimension
{*
  isA->assertZ(CulturalConvention);

  dimensionClassesNumDimensionsToExponentMapMapA->assert(^Map[**]);

  //  PURPOSE:  To insert composite Dimension '@dimension' in map returned by
  //	'dimensionClassesNumDimensionsToExponentMapMapA'.  Checks to see if
  //	an equivalent dimension has already been registered, and throws
  //	instance of 'AttemptToRegisterRedundantDimensionException' if so.
  //	Returns '@dimension'.
  register	Dimension
  [*
    [ [@dimension,	Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Register '@dimension':
      //  II.A.  Compute '@dimCount' and '@expSum':
      ^VarDecl[* @dimCount, Rational, 0*],
      ^VarDecl[* @expSum, Number, 0 *],
      ^VarDecl[* @iter, Iterator *],
      ^VarDecl[* @lastDimStruct, CompositeDimensionsBasicDimStruct *],

      ^If
      [*
	@dimension->isInstanceOf(ConventionallyFundamentalDimension),

	^Do
	[*[
	  @dimCount	:= 1,
	  @expSum	:= 1
	]*],

	^For
	[*
	  @iter	:=
	      @dimension->
		localProp_iter(compositeDimensionsBasicDimensionCompositionA),

	 !@iter->iter_isAtEnd(),

	  ^Do
	  [*[
	    @lastDimStruct := @iter->iter_value(),
	    @dimCount	   := @dimCount	+ext 1,
	    @expSum	   := @expSum	+ext
	  		      @lastDimStruct->
				localGet
				    (compositeDimensionsBasicDimStructsPowerA)
	  ]*],

	  @iter->iter_advance()
	*]

      *],

      //  II.B.  Get the dimension list to which should (potentially) add
      //  	 '@dimension':
      //  II.B.1.  Attempt to get the map that maps from exponent sums to
      //  	   lists of possible composite dimensions:
      //  II.B.1.a.  Get '@numDimToExpMap':
      ^VarDecl[* @numDimToExpMap, Map *],

      @numDimToExpMap
	:= Dimension->localGet(dimensionClassesNumDimensionsToExponentMapMapA),

      //  II.B.1.b.  Attempt to get the map that maps from exponent sums to
      //	     lists of possible composite dimensions:
      //  II.B.1.b.I.  Look for existing map in '@exponentToDimListMap':
      ^VarDecl[* @exponentToDimListMap, Idea *],

      @exponentToDimListMap := @numDimToExpMap->map_get(@dimCount),

      //  II.B.1.b.II.  If no map exists, then (1) create, and, (2) store:
      ^If
      [*
	@exponentToDimListMap->isNull(),

	^Do
	[*[
	  @exponentToDimListMap := ^^Map[**],
	  @numDimToExpMap->map_put(@dimCount,@exponentToDimListMap)
	]*]
      *],

      //  II.B.2.  Look in '@exponentToDimListMap' for list of dimensions:
      ^VarDecl[* @dimList, Idea *],

      @dimList := @exponentToDimListMap->map_get(@expSum),

      ^If
      [*
	@dimList->isNull(),

	^Do
	[*[
	  @dimList	:= ^^VectorList[**],
	  @exponentToDimListMap->map_put(@expSum,@dimList)
	]*]
      *],

      //  II.C.  Search in '@dimList' for a dimension that matches:
      ^VarDecl[* @dim, ConventionallyCompositeDimension *],
      ^VarDecl[* @compListIter, Iterator *],

      //  For: @dimList
      ^For
      [*
	@iter	:= @dimList->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	^Do
	[*[
	  //  II.C.3.a.  See if '@dim' matches '@dimension':
	  ^VarDecl[* @dimBasicDimIter, Iterator *],
	  ^VarDecl[* @compListStruct, CompositeDimensionsBasicDimStruct *],
	  ^VarDecl[* @dimBasicDimStruct, CompositeDimensionsBasicDimStruct *],
	  ^VarDecl[* @doesDimPossiblyMatch, Boolean *],

	  @dim			:= @iter->iter_value(),
	  @doesDimPossiblyMatch	:= true,

	  //  II.C.3.a.I.  Each iteration looks for a
	  //  		   CompositeDimensionsBasicDimStruct of '@dim' that
	  //		   matches the current '@dimension' entry:

	  //  For: @dimension
	  ^For
	  [*

	    //  II.C.3.a.I.A.  Prepare to iterate thru both lists:
	    ^Do
	    [*[
	      @compListIter	:= @dimension->
		localProp_iter(compositeDimensionsBasicDimensionCompositionA),
	      @dimBasicDimIter	:=
		    @dim->
			localProp_iter
			    (compositeDimensionsBasicDimensionCompositionA)
	    ]*],

	   !@compListIter->iter_isAtEnd(),

	    //  II.C.3.a.I.C.  Look for an entry that matches
	    //		       '@compListStruct':
	    ^Do
	    [*[
	      @compListStruct	:= @compListIter->iter_value(),

	      //  II.C.3.a.I.C.1.  Each iteration looks for a
	      //  		   CompositeDimensionsBasicDimStruct of '@dim'
	      //		   that matches '@compListStruct':

	      //  For: @dim->compositeDimensionsBasicDimStructsToDimensionA
	      ^For
	      [*
		@dimBasicDimIter->iter_reset(),

	       !@dimBasicDimIter->iter_isAtEnd(),

		^Do
		[*[
		  @dimBasicDimStruct	:= @dimBasicDimIter->iter_value(),

		  ^If
		  [*
		    (@compListStruct->
			  localGet
			      (compositeDimensionsBasicDimStructsToDimensionA)
		       =ref
		       @dimBasicDimStruct->
			  localGet
			      (compositeDimensionsBasicDimStructsToDimensionA)
		    ),

		    //  If we get here the dimensions matched,
		    //  If the powers match then this may be the one.
		    //	However, if the powers do NOT match, go on to next
		    //  '@dim':
		    ^Do
		    [*[
		      @doesDimPossiblyMatch	:=
			(@compListStruct->
			  localGet(compositeDimensionsBasicDimStructsPowerA)
			       =num
			 @dimBasicDimStruct->
			  localGet(compositeDimensionsBasicDimStructsPowerA)
			),
		      ^Break[**]
		    ]*]

		  *]
		]*],

		@dimBasicDimIter->iter_advance()
	      *],
	      //  For: @dim->compositeDimensionsBasicDimStructsToDimensionA

	      //  If @dimBasicDimIter is at the end then it did not find
	      //  matching '@compListStruct'.  Therefore, '@dim' does not match:
	      ^If
	      [*
		@dimBasicDimIter->iter_isAtEnd(),
		@doesDimPossiblyMatch	:= false
	      *],

	      //  If '@dim' dies not match then break out of this '@dimension'
	      //  loop to get the next possible '@dim' value:
	      ^If
	      [*
	       !@doesDimPossiblyMatch,
		^Break[**]
	      *]
	    ]*],

	    @compListIter->iter_advance()
	  *],
	  //  For: @dimension

	  //  If '@doesDimPossiblyMatch' still true after going thru all
	  //  '@dimension' values then this must be the match:
	  ^If
	  [*
	    @doesDimPossiblyMatch,
	    ^Throw
	    [*
	      ^^AttemptToRegisterRedundantDimensionException
	      [*
		@dim,
		@dimension
	      *]
	    *]
	  *]
	]*],

	@iter->iter_advance()
      *],
      //  For: @dimList

      //  II.C.4.  Register '@dimension':
      @dimList->dataStruct_insertZ(@dimension),

      //  III.  
      ^Return[* @dimension *]
    ]*]
  *];

  //  PURPOSE:  To return a new or existing Dimension instance corresponding to
  //	the list of 'CompositeDimensionsBasicDimStruct' instances given in
  //	'@compositionList'.
  getDimensionGivenDefn	Dimension
  [*
    [ [@compositionList,	List]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Find or create a dimension matching the
      //       'CompositeDimensionsBasicDimStruct' instances in
      //       '@compositionList':
      //  II.A.  Compute '@dimCount' and '@expSum':
      ^VarDecl[* @dimCount, Rational, 0*],
      ^VarDecl[* @expSum, Number, 0 *],
      ^VarDecl[* @iter, Iterator *],
      ^VarDecl[* @lastDimStruct, CompositeDimensionsBasicDimStruct *],

      ^For
      [*
	@iter	:= @compositionList->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	^Do
	[*[
	  @lastDimStruct := @iter->iter_value(),
	  @dimCount	 := @dimCount	+ext 1,
	  @expSum	 := @expSum	+ext
	  		    @lastDimStruct->
				localGet
				    (compositeDimensionsBasicDimStructsPowerA)
	]*],

	@iter->iter_advance()
      *],

      //  II.B.  Handle 'ConventionallyFundamentalDimension' instances:
      ^If
      [*
	@dimCount->number_isOne()  &&  @expSum->number_isOne(),
	^Return
	[*  @lastDimStruct->
		localGet(compositeDimensionsBasicDimStructsToDimensionA)
	*]	      
      *],

      //  II.C.  Handle 'ConventionallyCompositeDimension' instances:
      //  II.C.1.  Attempt to get the map that maps from exponent sums to
      //  	   lists of possible composite dimensions:
      //  II.C.1.a.  Get '@numDimToExpMap':
      ^VarDecl
      [*
	@numDimToExpMap,
	Map,
	Dimension->localGet(dimensionClassesNumDimensionsToExponentMapMapA)
      *],

      //  II.C.1.b.  Attempt to get the map that maps from exponent sums to
      //	     lists of possible composite dimensions:
      //  II.C.1.b.I.  Look for existing map in '@exponentToDimListMap':
      ^VarDecl
      [*
	@exponentToDimListMap,
	Idea,
	@numDimToExpMap->map_get(@dimCount)
      *],

      //  II.C.1.b.II.  If no map exists, then (1) create, and, (2) store:
      ^If
      [*
	@exponentToDimListMap->isNull(),

	^Do
	[*[
	  @exponentToDimListMap := ^^Map[**],
	  @numDimToExpMap->map_put(@dimCount,@exponentToDimListMap)
	]*]
      *],

      //  II.C.2.  Look in '@exponentToDimListMap' for list of dimensions:
      ^VarDecl[* @dimList, Idea, @exponentToDimListMap->map_get(@expSum) *],

      ^If
      [*
	@dimList->isNull(),

	^Do
	[*[
	  @dimList	:= ^^VectorList[**],
	  @exponentToDimListMap->map_put(@expSum,@dimList)
	]*]
      *],

      //  II.C.3.  Search in '@dimList' for a dimension that matches:
      ^VarDecl[* @dim, ConventionallyCompositeDimension *],
      ^VarDecl[* @compListIter, Iterator *],

      //  For: @dimList
      ^For
      [*
	@iter	:= @dimList->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	^Do
	[*[
	  //  II.C.3.a.  See if '@dim' matches '@compositionList':
	  ^VarDecl[* @dimBasicDimIter, Iterator *],
	  ^VarDecl[* @compListStruct, CompositeDimensionsBasicDimStruct *],
	  ^VarDecl[* @dimBasicDimStruct, CompositeDimensionsBasicDimStruct *],
	  ^VarDecl[* @doesDimPossiblyMatch, Boolean *],

	  @dim			:= @iter->iter_value(),
	  @doesDimPossiblyMatch	:= true,

	  //  II.C.3.a.I.  Each iteration looks for a
	  //  		   CompositeDimensionsBasicDimStruct of '@dim' that
	  //		   matches the current '@compositionList' entry:

	  //  For: @compositionList
	  ^For
	  [*

	    //  II.C.3.a.I.A.  Prepare to iterate thru both lists:
	    ^Do
	    [*[
	      @compListIter	:= @compositionList->dataStruct_iter(),
	      @dimBasicDimIter	:=
		    @dim->
			localProp_iter
			    (compositeDimensionsBasicDimensionCompositionA)
	    ]*],

	   !@compListIter->iter_isAtEnd(),

	    //  II.C.3.a.I.C.  Look for an entry that matches
	    //		       '@compListStruct':
	    ^Do
	    [*[
	      @compListStruct	:= @compListIter->iter_value(),

	      //  II.C.3.a.I.C.1.  Each iteration looks for a
	      //  		   CompositeDimensionsBasicDimStruct of '@dim'
	      //		   that matches '@compListStruct':

	      //  For: @dim->compositeDimensionsBasicDimensionCompositionA
	      ^For
	      [*
		@dimBasicDimIter->iter_reset(),

	       !@dimBasicDimIter->iter_isAtEnd(),

		^Do
		[*[
		  @dimBasicDimStruct	:= @dimBasicDimIter->iter_value(),

		  ^If
		  [*
		    (@compListStruct->
			  localGet
			      (compositeDimensionsBasicDimStructsToDimensionA)
		       =ref
		       @dimBasicDimStruct->
			  localGet
			      (compositeDimensionsBasicDimStructsToDimensionA)
		    ),

		    //  If we get here the dimensions matched,
		    //  If the powers match then this may be the one.
		    //	However, if the powers do NOT match, go on to next
		    //  '@dim':
		    ^Do
		    [*[
		      @doesDimPossiblyMatch	:=
			(@compListStruct->
			  localGet(compositeDimensionsBasicDimStructsPowerA)
			       =num
			 @dimBasicDimStruct->
			  localGet(compositeDimensionsBasicDimStructsPowerA)
			),
		      ^Break[**]
		    ]*]

		  *]
		]*],

		@dimBasicDimIter->iter_advance()
	      *],
	      //  For: @dim->compositeDimensionsBasicDimensionCompositionA

	      //  If @dimBasicDimIter is at the end then it did not find
	      //  matching '@compListStruct'.  Therefore, '@dim' does not match:
	      ^If
	      [*
		@dimBasicDimIter->iter_isAtEnd(),
		@doesDimPossiblyMatch	:= false
	      *],

	      //  If '@dim' dies not match then break out of this
	      //  '@compositionList' loop to get the next possible '@dim' value:
	      ^If
	      [*
	       !@doesDimPossiblyMatch,
		^Break[**]
	      *]
	    ]*],

	    @compListIter->iter_advance()
	  *],
	  //  For: @compositionList

	  //  If '@doesDimPossiblyMatch' still true after going thru all
	  //  '@compositionList' values then this must be the match:
	  ^If
	  [*
	    @doesDimPossiblyMatch,
	    ^Return[* @dim *]
	  *]
	]*],

	@iter->iter_advance()
      *],
      //  For: @dimList

      //  II.C.4.  Create new dimension:
      @dim	:= ^^ConventionallyCompositeDimension[**],

      @dimList->dataStruct_insertZ(@dim),

      ^For
      [*
	@compListIter	:= @compositionList->dataStruct_iter(),
       !@compListIter->iter_isAtEnd(),
        @dim->assertZ
		(compositeDimensionsBasicDimensionCompositionA,
		 @compListIter->iter_value()
		),
	@compListIter->iter_advance()
      *],

      //  III.  Finished:
      ^Return[* @dim *]
    ]*]

  *];
  //  getDimensionGivenDefn


  //  PURPOSE:  To return the 'Dimension' instance that results from
  //	multiplying Dimension '@multiplierDim' with '@multiplicandDim'.
  multiplicativeResult	Dimension
  [*

    [ [@multiplierDim,	Dimension],
      [@multiplicandDim,Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute the dimension that results when Dimension instance
      //       '@multiplierDim' is multiplied by '@multiplicandDim':
      //  II.A.  Handle "easy" cases:
      //  II.A.1.  Handle multiplication by 'dimensionless':
      ^If
      [*
	@multiplierDim =ref dimensionless,
	^Return[* @multiplicandDim *]
      *],

      ^If
      [*
	@multiplicandDim =ref dimensionless,
	^Return[* @multiplierDim *]
      *],

      //  II.A.2.  Handle when result has been cached:
      //  II.A.2.a.  Create bag to look for cached result:
      ^VarDecl
      [*
	@multiplierMultiplicandBag,
	Bag,
	^^Bag[**]
      *],

      @multiplierMultiplicandBag->dataStruct_insert(@multiplierDim),
      @multiplierMultiplicandBag->dataStruct_insert(@multiplicandDim),
      @multiplierMultiplicandBag	:=
	    @multiplierMultiplicandBag->getEquivalentSingleDistinct(),

      //  II.A.2.b.  Get the map that may have the cached answer:
      ^VarDecl
      [*
	@multiplicativeMap,
	Map,
	Dimension->localGet(dimensionClassesMultiplicativeResultMapA)
      *],

      ^If
      [*
	//  I.  Does the map exist?
	@multiplicativeMap->isNull(),

	//  II.  Case it does NOT exist: so create it, and then go on:
	Dimension->
	    assert
		(dimensionClassesMultiplicativeResultMapA,
		 @multiplicativeMap := ^^Map[**]
		),

	//  III.  Case it DOES exist: so look up '@multiplierMultiplicandBag'
	//  	  in it and return the answer if one was found:
	^Do
	[*[
	  ^VarDecl
	  [*
	    @result,
	    Dimension,
	    @multiplicativeMap->map_get(@multiplierMultiplicandBag)
	  *],

	  ^If
	  [*
	    !@result->isNull(),
	    ^Return[* @result *]
	  *]
	]*]
      *],

      //  II.B.  Handle the general case:
      ^VarDecl[* @resultList, VectorList, ^^VectorList[**] *],

      //  II.B.1.  Get the compositions of both '@multiplierDim' and
      //	   '@multiplicandDim':
      //  II.B.1.a.  Prepare an iterator over the
      //	     'CompositeDimensionsBasicDimStruct' instances of
      //	     '@multiplierDim':
      ^VarDecl
      [*
	@multiplierIter,
	Iterator,
	^If
	[*
	  //  II.B.1.a.I.  If '@multiplierDim' conventionally fundamental?
	  @multiplierDim->isInstanceOf(ConventionallyFundamentalDimension),

	  //  II.B.1.a.II.  Case yes: Create a list with a
	  //		    'ConventionallyFundamentalDimension' instance
	  //		    with power '1' and return an iterator over it:
	  ^Do
	  [*[
	    ^VarDecl[* @list, NodeList, ^^NodeList[**] *],

	    @list->dataStruct_insert
		( ^^CompositeDimensionsBasicDimStruct
		  [*
		    @multiplierDim,
		    1
		  *]
		),
	    @list->dataStruct_iter()
	  ]*],

	  //  II.B.1.a.III.  Case no: return an iterator over the locally-
	  //		     listed values of attribute
	  //		     'compositeDimensionsBasicDimensionCompositionA':
	  @multiplierDim->
		localProp_iter(compositeDimensionsBasicDimensionCompositionA)
	*]
      *],

      //  II.B.1.b.  Create a node list with the
      //	     'CompositeDimensionsBasicDimStruct' instances of
      //	     '@multiplicandDim':
      ^VarDecl[* @multiplicandStructList, NodeList, ^^NodeList[**] *],
      ^VarDecl[* @multiplicandIter, Iterator *],

      ^If
      [*
	//  I.B.1.b.I.  If '@multiplicandDim' conventionally fundamental?
	@multiplicandDim->isInstanceOf(ConventionallyFundamentalDimension),

	//  I.B.1.b.II.  Case yes: insert that dimension raise to power of 1:
	@multiplicandStructList->dataStruct_insert
		( ^^CompositeDimensionsBasicDimStruct
		  [*
		    @multiplicandDim,
		    1
		  *]
		),

	//  I.B.1.b.III.  Case no: insert the locally-listed values of attr
	//		  'compositeDimensionsBasicDimStructsToDimensionA':
	^For
	[*
	  @multiplicandIter	:=
	    @multiplicandDim->
		localProp_iter(compositeDimensionsBasicDimensionCompositionA),

	 !@multiplicandIter->iter_isAtEnd(),

	  @multiplicandStructList->
		dataStruct_insertA(@multiplicandIter->iter_value()),

	  @multiplicandIter->iter_advance()
	*]
      *],

      //  II.B.2.  Get the dimensions of '@multiplierDim' and put them in
      //  	   '@resultList' (if when multiplied by the power of the same
      //	   dimension in '@multiplicandDim' yields a non-zero power):
      ^For
      [*
	//  II.B.2.A.  Create iterators over both '@multiplierIter' (already
	//  	        done) and '@multiplicandIter':
	^Do
	[*[
	  //  @multiplierIter is already initialized
	  @multiplicandIter := @multiplicandStructList->dataStruct_iter()
	]*],

	//  II.B.2.B.  Keep on going while not at end of '@multiplierIter':
       !@multiplierIter->iter_isAtEnd(),

	//  II.B.2.C.  Handle current '@multiplierIter' value:
	^Do
	[*[
	  //  II.B.2.C.I.  Get current '@multiplierIter' structure:
	  ^VarDecl
	  [*
	    @currentStruct,
	    CompositeDimensionsBasicDimStruct,
	    @multiplierIter->iter_value()
	  *],
	  ^VarDecl
	  [*
	    @currentDim,
	    Dimension,
	    @currentStruct->
		localGet(compositeDimensionsBasicDimStructsToDimensionA)
	  *],
	  ^VarDecl
	  [*
	    @currentPower,
	    Number,
	    @currentStruct->localGet(compositeDimensionsBasicDimStructsPowerA)
	  *],

	  //  II.B.2.C.II. Look for '@currentDim' in '@multiplicandStructList':
	  ^For
	  [*
	    //  II.B.2.C.II.A.  Initialize search over
	    //			'@multiplicandStructList':
	    @multiplicandIter->iter_reset(),

	    //  II.B.2.C.II.B.  Continue while not at end of
	    //			'@multiplicandStructList':
	   !@multiplicandIter->iter_isAtEnd(),

	    //  II.B.2.C.II.C.  If current 'CompositeDimensionsBasicDimStruct'
	    //			of '@multiplicandStructList' as same dimension
	    //			as '@currentDim' then have found match:
	    //			(1) add its power to '@currentPower',
	    //			(2) remove it from '@multiplicandStructList'
	    //			(3) break inner loop (cannot find dim twice in
	    //			     same '@multiplicandStructList')
	    ^Do
	    [*[
	      ^VarDecl
	      [*
		@innerStruct,
		CompositeDimensionsBasicDimStruct,
		@multiplicandIter->iter_value()
	      *],

	      ^If
	      [*
		@innerStruct->
		    localGet(compositeDimensionsBasicDimStructsToDimensionA)
		=ref @currentDim,
		^Do
		[*[
		  @currentPower :=
			@currentPower +ext
			@innerStruct->
			    localGet(compositeDimensionsBasicDimStructsPowerA),

		  @multiplicandIter->nListIter_didRemoveZ(),
		  ^Break
		]*]
	      *]
	    ]*],

	    //  II.B.2.C.II.D.  Go on to next '@multiplicandStructList':
	    @multiplicandIter->iter_advance()
	  *],

	  //  II.B.2.C.III. Record structure for '@currentDim' in '@resultList'
	  //  		    if corresponding '@currentPower' is non-zero:
	  ^If
	  [*
	   !@currentPower->number_isZero(),
	    @resultList->dataStruct_insert
		( ^^CompositeDimensionsBasicDimStruct
		  [*
		    @currentDim,
		    @currentPower
		  *]
		)
	  *]
	]*],

	//  II.B.2.D.  Go on to next '@multiplierIter' value:
	@multiplierIter->iter_advance()
      *],

      //  II.B.3.  Add on those dimensions in '@multiplicandDim' that are not
      //	   mentioned in '@multiplierDim':
      ^For
      [*
	@multiplicandIter := @multiplicandStructList->dataStruct_iter(),
       !@multiplicandIter->iter_isAtEnd(),
	@resultList->dataStruct_insert
	    ( ^^CompositeDimensionsBasicDimStruct
	      [*
		@multiplicandIter->iter_value()->
		      localGet(compositeDimensionsBasicDimStructsToDimensionA),
		@multiplicandIter->iter_value()->
		      localGet(compositeDimensionsBasicDimStructsPowerA)
	      *]
	    ),
	@multiplicandIter->iter_advance()
      *],

      //  III.  Finished, return value:
      //  III.A.  Get the resulting dimension:
      ^VarDecl
      [*
	@resultDim,
	Dimension,
	^If
	[*
	  @resultList->dataStruct_isEmpty(),

	  //  III.A.1.  Handle 'dimensionless':
	  dimensionless,

	  ^If
	  [*
	    ( @resultList->dataStruct_size()->number_isOne()		&&
	      @resultList->list_firstItem()->
		localGet(compositeDimensionsBasicDimStructsPowerA)->
		number_isOne()
	    ),

	    //  III.A.2.  Handle conventionally fundamental dimensions:
	    @resultList->list_firstItem()->
		localGet(compositeDimensionsBasicDimStructsToDimensionA),

	    //  III.A.3.  Handle composites:
	    Dimension->getDimensionGivenDefn(@resultList)
	  *]
	*]
      *],
      //  III.B.  Cache result:
      @multiplicativeMap->map_put(@multiplierMultiplicandBag,@resultDim),

      //  III.C.  Return result:
      ^Return[* @resultDim *]
    ]*]

  *];	//  multiplicativeResult()


  //  PURPOSE:  To return the 'Dimension' instance that results from computing
  //	the reciprocal Dimension of '@incomingDimension'.
  reciprocalResult Dimension
  [*
 
    [ [@incomingDimension, Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute reciprocal result:
      //  II.A. Handle dimensionless
      ^If
      [*
	@incomingDimension =ref dimensionless,
	^Return[* @incomingDimension *]
      *],
      // end dimensionless inverse

      //  II.B. Handle fundamentals
      ^VarDecl[* @basicDimStructList, List, ^^VectorList[**] *],

      ^If
      [*
	@incomingDimension->isInstanceOf(ConventionallyFundamentalDimension),

	^Do
	[*[
	  @basicDimStructList->dataStruct_insert
		( ^^CompositeDimensionsBasicDimStruct
		  [*
		    @incomingDimension,
		    -1
		  *]
		),
	  ^Return[* Dimension->getDimensionGivenDefn(@basicDimStructList) *]
      	]*]
      *],
      // end fundamental inverse

      //  II.C: handle composites
      ^VarDecl[* @dimListIter, Iterator *],
      ^For
      [*
        @dimListIter :=
	    @incomingDimension->
		localProp_iter(compositeDimensionsBasicDimensionCompositionA),

       !@dimListIter->iter_isAtEnd(),

        ^Do
        [*[
	  ^VarDecl
	  [*
	    @currentDimStruct,
	    CompositeDimensionsBasicDimStruct,
	    @dimListIter->iter_value()
	  *],

	  @basicDimStructList->
	    dataStruct_insert
	    ( ^^CompositeDimensionsBasicDimStruct
              [*
                @currentDimStruct->
                   localGet(compositeDimensionsBasicDimStructsToDimensionA),
                -1
		* @currentDimStruct->
		   localGet(compositeDimensionsBasicDimStructsPowerA)
              *]
            )
        ]*],

        @dimListIter->iter_advance()
      *],
      ^Return [* Dimension->getDimensionGivenDefn(@basicDimStructList) *]
    ]*]
 
  *];
  //  reciprocalResult


  //  PURPOSE:  To return the 'Dimension' instance that results from
  //	dividing Dimension '@dividendDim' by '@divisorDim'.
  quotientResult Dimension
  [*

    [ [@dividendDim, Dimension],
      [@divisorDim, Dimension]
    ],
  
    ^Do
    [*[
      ^Return
      [*
        Dimension->
	  multiplicativeResult
		( @dividendDim,
		  Dimension->reciprocalResult(@divisorDim)
		)
      *]
    ]*]
  *];
  //  quotientResult


  //  PURPOSE:  To register the operator '@operator', when given a value in
  //	'Dimension' instance '@operandDim', results in an AnnotatedValue with
  //	resulting 'Dimension' instance '@resultDim'.  Returns '@resultDim'.
  registerUnaryOperatorResult	Dimension
  [*
    [ [@operator,	Operator],
      [@operandDim,	Dimension],
      [@resultDim,	Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check (done below):

      //  II.  Record applying '@operator' on 'Dimension' instance
      //       '@operandDim' results in 'Dimension' instance '@resultDim':
      //  II.A.  Create bag to use as key to cache result:
      ^VarDecl[* @opDimBag, Bag, ^^Bag[**] *],

      @opDimBag->dataStruct_insert(@operator),
      @opDimBag->dataStruct_insert(@operandDim),
      @opDimBag	:= @opDimBag->getEquivalentSingleDistinct(),

      //  II.B.  Get the map that may have the cached answer:
      //  II.B.1.  Look for map if already exists:
      ^VarDecl
      [*
	@opDimMap,
	Map,
	Dimension->localGet(dimensionClassesUnaryOpResultMapA)
      *],

      //  II.B.2.  Create map if does not exist:
      ^If
      [*
	//  I.  Does the map exist?
	@opDimMap->isNull(),

	//  II.  Case it does NOT exist: so create it, and then go on:
	Dimension->
		assert(dimensionClassesUnaryOpResultMapA,@opDimMap := ^^Map[**])
      *],

      //  II.C.  Look in map to see if an answer already exists:
      ^VarDecl[* @recordedDim, Dimension, @opDimMap->map_get(@opDimBag) *],

      ^If
      [*
	!@recordedDim->isNull(),

	^If
	[*
	  (@recordedDim =ref @resultDim),

	  //  Ignore redundant registeries:
	  ^Return[* @resultDim *],

	  //  Complain about conflicting registeries:
	  ^Throw
	  [*
	    ^^AttemptToRegisterConflictingOpDimResultException
	    [*
	      @operator,
	      @operandDim,
	      @resultDim,
	      @recordedDim
	    *]
	  *]
	*]
      *],

      //  II.D.  Record answer:
      @opDimMap->map_put(@opDimBag,@resultDim),

      //  III.  Finished:
      ^Return[* @resultDim *]
    ]*]
  *];
  //  registerUnaryOperatorResult


  //  PURPOSE:  To return the 'Dimension' instance that results from applying
  //	unary 'Operator' instance '@operator' on 'Dimension' instance 
  //	'@operandDim'.
  unaryOperatorResult	Dimension
  [*
    [ [@operator,	Operator],
      [@operandDim,	Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute the 'Dimension' instance that results when applying
      //       'Operator' instance '@operator' upon 'Dimension' instance
      //       '@operandDim':
      //  II.A.  Handle when result has been cached:
      //  II.A.1.  Create bag to look for cached result:
      ^VarDecl[* @opDimBag, Bag, ^^Bag[**] *],

      @opDimBag->dataStruct_insert(@operator),
      @opDimBag->dataStruct_insert(@operandDim),
      @opDimBag	:= @opDimBag->getEquivalentSingleDistinct(),

      //  II.A.2.  Get the map that may have the cached answer:
      ^VarDecl
      [*
	@opDimMap,
	Map,
	Dimension->localGet(dimensionClassesUnaryOpResultMapA)
      *],

      ^If
      [*
	@opDimMap->isNull(),
	^Throw[* *]
      *],

      //  III.  Return result:
      ^Return[* @opDimMap->map_get(@opDimBag) *]
    ]*]
  *];
  //  unaryOperatorResult

*};


  //  PURPOSE:  To represent the class of attributes whose domain is class
  //	'Dimension'.
  DimensionA
  {*
    isA->assertZ(CulturalConventionA);

    attrsDomainA->subAssertZ(Dimension);
  *};


  //  PURPOSE:  To represent the attribute the maps from the *class*
  //	'Dimension' to a map that, given the number of fundamental dimensions,
  //	potentially maps to another map that, given the sum of all dimension
  //	exponents, maps to a list of composite dimensions that match those
  //	two criteria.
  dimensionClassesNumDimensionsToExponentMapMapA
  {*
    instanceOf->assertZ(DimensionA);
  *};



    //  PURPOSE:  To map from instances of 'Dimension' to the domain to use for
    //	  that dimension by default.
    dimensionsDefaultDomainA
    {*
      instanceOf->assertZ(DimensionA);
    *};


    //  PURPOSE:  To map from instances of 'Dimension' to the units to use for
    //	  that dimension by default.
    dimensionsPrimaryUnitsA
    {*
      instanceOf->assertZ(DimensionA);
    *};


    //  PURPOSE:  To map from instances of 'Dimension' to 'true' if the
    //	  dimension is conventionally considered to be fundamental, or 'false'
    //	  if it is conventionally considered to be composite.
    isDimensionConventionallyFundamentalA
    {*
      instanceOf->assertZ(DimensionA);
    *};


  //  PURPOSE:  To encompass the set of dimensions which are conventionally
  //  	thought of as being fundamental (ie. non-composite).
  ConventionallyFundamentalDimension
  {*
    isA->assertZ(Dimension);

    isDimensionConventionallyFundamentalA->subAssert(true);
  *};

  //  PURPOSE:  To encompass the set of dimensions which are conventionally
  //  	thought of as being composite (ie. non-fundamental).
  ConventionallyCompositeDimension
  {*
    isA->assertZ(Dimension);

    isDimensionConventionallyFundamentalA->subAssert(false);
  *};

    //  PURPOSE:  To map from instances of 'ConventionallyCompositeDimension'
    //	  to one or more instances of 'CompositeDimensionsBasicDimStruct' that
    //	  tell how that composite dimension is partially composed of a
    //	  'ConventionallyFundamentalDimension' instance.
    compositeDimensionsBasicDimStructsToDimensionA
    {*
      instanceOf->assertZ(DimensionA);
    *};


    //  PURPOSE:  To encompass the set of structures that tell, in part,
    //	  how something (e.g. a composite dimension) is partially composed of
    //	  a more basic dimension.  Attribute 
    //	  'compositeDimensionsBasicDimStructsToDimensionA' maps from instances
    //	  of this set to a basic dimension.  Attribute
    //	  'compositeDimensionsBasicDimStructsPowerA' maps from instances of
    //	  this set to the power to which the basic dimension is raised.
    CompositeDimensionsBasicDimStruct
    {*
      isA->assert(CulturalConvention);

      ideasImplicitConstructorA->subAssert
	( ^ImplicitConstructor
	  [*
	    [compositeDimensionsBasicDimStructsToDimensionA,
	     compositeDimensionsBasicDimStructsPowerA
	    ]
	  *]
	);
    *};


    //  PURPOSE:  To map from a 'CompositeDimensionsBasicDimStruct' instance
    //	  to the Rational power that the fundamental dimension is raised to
    //	  inside of the composite dimension that is the subject of an assertion.
    compositeDimensionsBasicDimStructsPowerA
    {*
      instanceOf->assertZ(CulturalConventionA);
    *};

    //  PURPOSE:  To map from a 'CompositeDimensionsBasicDimStruct' instance
    //	  to a fundamental dimension used in the composite dimension that is
    //	  the subject of an assertion.
    compositeDimensionsBasicDimensionCompositionA
    {*
      instanceOf->assertZ(CulturalConventionA);
    *};



//									//
//				Units					//
//									//

//  PURPOSE:  To map from an 'AttemptToRegisterRedundantUnitsException'
//	instance to the already registered units.
attemptToRegisterRedundantUnitsExceptionsAlreadyRegisteredUnitsA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an 'AttemptToRegisterRedundantUnitsException'
//	instance to the Units that was redundantly attempted to register.
attemptToRegisterRedundantUnitsExceptionsRedundandUnitsA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent an attempt to register a redundant units.
AttemptToRegisterRedundantUnitsException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [attemptToRegisterRedundantUnitsExceptionsAlreadyRegisteredUnitsA,
	     Idea
	    ],
	    [attemptToRegisterRedundantUnitsExceptionsRedundandUnitsA,
	     Idea
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantUnitsException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@redundant,
	Idea,
	@thisException->localGet
	  (attemptToRegisterRedundantUnitsExceptionsRedundandUnitsA)
      *],
      ^VarDecl
      [*
	@original,
	Idea,
	@thisException->localGet
	  (attemptToRegisterRedundantUnitsExceptionsAlreadyRegisteredUnitsA)
      *],


      //  "The sp8b attempted to register an instance of a units named
      //   <redundant> that is redundant with <original>"

      //  "<redundant>"
      ^VarDecl[* @innerPhraseDS, VectorList, ^^VectorList[**] *],

      @innerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @redundant,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      //  "to register an instance of a units named <redundant>"
      ^VarDecl[* @outerPhraseDS, VectorList, ^^VectorList[**] *],

      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    redundant,
		    ^^NatLangRolePhrase
		    [*
		      Units,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false,
		      ^^NatLangDeclarativeSentence
		      [*
			toName,
			inGeneralPresentNatLangTense,
			affirmNatLangStatus,
			@innerPhraseDS,
			directObjectNatLangPhraseRole
		      *]
		    *]
		  *]
		),
      @outerPhraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @original,
		    relativeToNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toRegister,
	  timelessNatLangTense,
	  affirmNatLangStatus,
	  @outerPhraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      //  "The sp8b attempted to register an instance of a units named
      //   <redundant>":
      @outerPhraseDS	:= ^^VectorList[**],
      @outerPhraseDS->dataStruct_insertZ(theSpRunSubject),
      @outerPhraseDS->dataStruct_insertZ(@sentence),
      @sentence	:=  ^^NatLangDeclarativeSentence
		    [*
		      toAttempt,
		      inGeneralPastNatLangTense,
		      affirmNatLangStatus,
		      @outerPhraseDS,
		      directObjectNatLangPhraseRole
		    *],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]

    ]*]
  *];	// computeValue

*};


//  PURPOSE:  To map from the *class* 'Units' to a map that maps from the
//	number of basic units a composite Unit has to another map that
//	holds instances of matching composite Units.
unitsClassesNumUnitsToExponentMapMapA
{*
  instanceOf->assertZ(DimensionA);
*};

//  PURPOSE:  To represent the class of units
Units
{*
  isA->assertZ(CulturalConvention);

  unitsClassesNumUnitsToExponentMapMapA->assert(^Map[**]);
  unitsClassesPairToConversionMapA->assert(^Map[* *]);

  //  PURPOSE:  To insert Units instance '@units' in map returned by
  //	'unitsClassesNumUnitsToExponentMapMapA'.  Checks to see if
  //	an equivalent units has already been registered, and throws
  //	instance of 'AttemptToRegisterRedundantUnitsException' if so.
  //	Returns '@units'.
  register	Units
  [*
    [ [@units,	Units]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Register '@units':
      //  II.A.  Compute '@unitCount' and '@expSum':
      ^VarDecl[* @unitCount, Rational, 0*],
      ^VarDecl[* @expSum, Number, 0 *],
      ^VarDecl[* @iter, Iterator *],
      ^VarDecl[* @lastUnitsStruct, CompositeUnitsBasicUnitStruct *],

      ^If
      [*
	@units->localGet(compositeUnitsBasicUnitA)->isNull(),

	^Do
	[*[
	  @unitCount	:= 1,
	  @expSum	:= 1
	]*],

	^For
	[*
	  @iter	:= @units->localProp_iter(compositeUnitsBasicUnitA),

	 !@iter->iter_isAtEnd(),

	  ^Do
	  [*[
	    @lastUnitsStruct:= @iter->iter_value(),
	    @unitCount	    := @unitCount	+ext 1,
	    @expSum	    := @expSum		+ext
	  		       @lastUnitsStruct->
				 localGet(compositeUnitsBasicUnitStructsPowerA)
	  ]*],

	  @iter->iter_advance()
	*]

      *] ,

      //  II.B.  Get the units list to which should (potentially) add '@units':
      //  II.B.1.  Attempt to get the map that maps from exponent sums to
      //  	   lists of possible composite units:
      //  II.B.1.a.  Get '@numUnitsToExpMap':
      ^VarDecl[* @numUnitsToExpMap, Map *],

      @numUnitsToExpMap
	:= Units->localGet(unitsClassesNumUnitsToExponentMapMapA),

      //  II.B.1.b.  Attempt to get the map that maps from exponent sums to
      //	     lists of possible composite units:
      //  II.B.1.b.I.  Look for existing map in '@exponentToUnitsListMap':
      ^VarDecl[* @exponentToUnitsListMap, Idea *],

      @exponentToUnitsListMap := @numUnitsToExpMap->map_get(@unitCount),

      //  II.B.1.b.II.  If no map exists, then (1) create, and, (2) store:
      ^If
      [*
	@exponentToUnitsListMap->isNull(),

	^Do
	[*[
	  @exponentToUnitsListMap := ^^Map[**],
	  @numUnitsToExpMap->map_put(@unitCount,@exponentToUnitsListMap)
	]*]
      *],

      //  II.B.2.  Look in '@exponentToUnitsListMap' for list of units:
      ^VarDecl[* @unitsList, Idea *],

      @unitsList := @exponentToUnitsListMap->map_get(@expSum),

      ^If
      [*
	@unitsList->isNull(),

	^Do
	[*[
	  @unitsList	:= ^^VectorList[**],
	  @exponentToUnitsListMap->map_put(@expSum,@unitsList)
	]*]
      *],

      //  II.C.  Search in '@unitsList' for a Units instance that matches:
      ^VarDecl[* @u, Units *],
      ^VarDecl[* @compListIter, Iterator *],

      //  For: @unitsList
      ^For
      [*
	@iter	:= @unitsList->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	^Do
	[*[
	  //  II.C.3.a.  See if '@u' matches '@units':
	  ^VarDecl[* @uBasicDimIter,	Iterator *],
	  ^VarDecl[* @compListStruct,	CompositeUnitsBasicUnitStruct *],
	  ^VarDecl[* @uBasicDimStruct,	CompositeUnitsBasicUnitStruct *],
	  ^VarDecl[* @doesUnitsPossiblyMatch, Boolean *],

	  @u			 := @iter->iter_value(),
	  @doesUnitsPossiblyMatch:= true,

	  //  II.C.3.a.I.  Each iteration looks for a
	  //  		   CompositeUnitsBasicUnitStruct of '@u' that
	  //		   matches the current '@units' entry:

	  //  For: @units
	  ^For
	  [*

	    //  II.C.3.a.I.A.  Prepare to iterate thru both lists:
	    ^Do
	    [*[
	      @compListIter  := @units->
				      localProp_iter(compositeUnitsBasicUnitA),
	      @uBasicDimIter := @u->localProp_iter(compositeUnitsBasicUnitA)
	    ]*],

	   !@compListIter->iter_isAtEnd(),

	    //  II.C.3.a.I.C.  Look for an entry that matches
	    //		       '@compListStruct':
	    ^Do
	    [*[
	      @compListStruct	:= @compListIter->iter_value(),

	      //  II.C.3.a.I.C.1.  Each iteration looks for a
	      //  		   CompositeUnitsBasicUnitStruct of '@u'
	      //		   that matches '@compListStruct':

	      //  For: @u->compositeDimensionsBasicDimStructsToDimensionA
	      ^For
	      [*
		@uBasicDimIter->iter_reset(),

	       !@uBasicDimIter->iter_isAtEnd(),

		^Do
		[*[
		  @uBasicDimStruct	:= @uBasicDimIter->iter_value(),

		  ^If
		  [*
		    (@compListStruct->
				localGet(compositeUnitsBasicUnitStructsUnitA)
			=ref
		     @uBasicDimStruct->
				localGet(compositeUnitsBasicUnitStructsUnitA)
		    ),

		    //  If we get here the basic units matched,
		    //  If the powers match then this may be the one.
		    //	However, if the powers do NOT match, go on to next
		    //  '@u':
		    ^Do
		    [*[
		      @doesUnitsPossiblyMatch	:=
			(@compListStruct->
			  localGet(compositeUnitsBasicUnitStructsPowerA)
			       =num
			 @uBasicDimStruct->
			  localGet(compositeUnitsBasicUnitStructsPowerA)
			),
		      ^Break[**]
		    ]*]

		  *]
		]*],

		@uBasicDimIter->iter_advance()
	      *],
	      //  For: @u->compositeUnitsBasicUnitStructsUnitA

	      //  If @uBasicDimIter is at the end then it did not find
	      //  matching '@compListStruct'.  Therefore, '@u' does not match:
	      ^If
	      [*
		@uBasicDimIter->iter_isAtEnd(),
		@doesUnitsPossiblyMatch	:= false
	      *],

	      //  If '@u' dies not match then break out of this '@units'
	      //  loop to get the next possible '@u' value:
	      ^If
	      [*
	       !@doesUnitsPossiblyMatch,
		^Break[**]
	      *]
	    ]*],

	    @compListIter->iter_advance()
	  *],
	  //  For: @units

	  //  If '@doesUnitsPossiblyMatch' still true after going thru all
	  //  '@units' values then this must be the match:
	  ^If
	  [*
	    @doesUnitsPossiblyMatch,
	    ^Throw
	    [*
	      ^^AttemptToRegisterRedundantUnitsException[*@u,@units*]
	    *]
	  *]
	]*],

	@iter->iter_advance()
      *],
      //  For: @unitsList

      //  II.C.4.  Register '@units':
      @unitsList->dataStruct_insertZ(@units),

      //  III.  
      ^Return[* @units *]
    ]*]
  *];
  //  register()


  //  PURPOSE:  To return a new or existing Units instance corresponding to
  //	the list of 'CompositeUnitsBasicUnitStruct' instances given in
  //	'@compositionList'.
  getUnitsGivenDefn	Units
  [*
    [ [@compositionList,	List]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Find or create a dimension matching the
      //       'CompositeUnitsBasicUnitStruct' instances in
      //       '@compositionList':
      //  II.A.  Compute '@unitCount' and '@expSum':
      ^VarDecl[* @unitCount, Rational, 0*],
      ^VarDecl[* @expSum, Number, 0 *],
      ^VarDecl[* @iter, Iterator *],
      ^VarDecl[* @lastUnitsStruct, CompositeUnitsBasicUnitStruct *],

      ^For
      [*
	@iter	:= @compositionList->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	^Do
	[*[
	  @lastUnitsStruct := @iter->iter_value(),
	  @unitCount	 := @unitCount	+ext 1,
	  @expSum	 := @expSum	+ext
	  		    @lastUnitsStruct->
				localGet
				    (compositeUnitsBasicUnitStructsPowerA)
	]*],

	@iter->iter_advance()
      *],

      //  II.B.  Handle 'ConventionallyFundamentalDimension' instances:
      ^If
      [*
	@unitCount->number_isOne()  &&  @expSum->number_isOne(),
	^Return
	[*  @lastUnitsStruct->
		localGet(compositeUnitsBasicUnitStructsUnitA)
	*]	      
      *],

      //  II.C.  Handle 'ConventionallyCompositeDimension' instances:
      //  II.C.1.  Attempt to get the map that maps from exponent sums to
      //  	   lists of possible composite dimensions:
      //  II.C.1.a.  Get '@numUnitsToExpMap':
      ^VarDecl
      [*
	@numUnitsToExpMap,
	Map,
	Dimension->localGet(unitsClassesNumUnitsToExponentMapMapA)
      *],

      //  II.C.1.b.  Attempt to get the map that maps from exponent sums to
      //	     lists of possible composite dimensions:
      //  II.C.1.b.I.  Look for existing map in '@exponentToUnitsListMap':
      ^VarDecl
      [*
	@exponentToUnitsListMap,
	Idea,
	@numUnitsToExpMap->map_get(@unitCount)
      *],

      //  II.C.1.b.II.  If no map exists, then (1) create, and, (2) store:
      ^If
      [*
	@exponentToUnitsListMap->isNull(),

	^Do
	[*[
	  @exponentToUnitsListMap := ^^Map[**],
	  @numUnitsToExpMap->map_put(@unitCount,@exponentToUnitsListMap)
	]*]
      *],

      //  II.C.2.  Look in '@exponentToUnitsListMap' for list of dimensions:
      ^VarDecl[* @dimList, Idea, @exponentToUnitsListMap->map_get(@expSum) *],

      ^If
      [*
	@dimList->isNull(),

	^Do
	[*[
	  @dimList	:= ^^VectorList[**],
	  @exponentToUnitsListMap->map_put(@expSum,@dimList)
	]*]
      *],

      //  II.C.3.  Search in '@dimList' for a dimension that matches:
      ^VarDecl[* @dim, ConventionallyCompositeDimension *],
      ^VarDecl[* @compListIter, Iterator *],

      //  For: @dimList
      ^For
      [*
	@iter	:= @dimList->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	^Do
	[*[
	  //  II.C.3.a.  See if '@dim' matches '@compositionList':
	  ^VarDecl[* @uBasicDimIter, Iterator *],
	  ^VarDecl[* @compListStruct, CompositeUnitsBasicUnitStruct *],
	  ^VarDecl[* @uBasicDimStruct, CompositeUnitsBasicUnitStruct *],
	  ^VarDecl[* @doesUnitsPossiblyMatch, Boolean *],

	  @dim			:= @iter->iter_value(),
	  @doesUnitsPossiblyMatch	:= true,

	  //  II.C.3.a.I.  Each iteration looks for a
	  //  		   CompositeUnitsBasicUnitStruct of '@dim' that
	  //		   matches the current '@compositionList' entry:

	  //  For: @compositionList
	  ^For
	  [*

	    //  II.C.3.a.I.A.  Prepare to iterate thru both lists:
	    ^Do
	    [*[
	      @compListIter	:= @compositionList->dataStruct_iter(),
	      @uBasicDimIter	:=
		    @dim->
			localProp_iter
			    (compositeUnitsBasicUnitA)
	    ]*],

	   !@compListIter->iter_isAtEnd(),

	    //  II.C.3.a.I.C.  Look for an entry that matches
	    //		       '@compListStruct':
	    ^Do
	    [*[
	      @compListStruct	:= @compListIter->iter_value(),

	      //  II.C.3.a.I.C.1.  Each iteration looks for a
	      //  		   CompositeUnitsBasicUnitStruct of '@dim'
	      //		   that matches '@compListStruct':

	      //  For: @dim->compositeUnitsBasicUnitA
	      ^For
	      [*
		@uBasicDimIter->iter_reset(),

	       !@uBasicDimIter->iter_isAtEnd(),

		^Do
		[*[
		  @uBasicDimStruct	:= @uBasicDimIter->iter_value(),

		  ^If
		  [*
		    (@compListStruct->
			  localGet(compositeUnitsBasicUnitStructsUnitA)
		       =ref
		       @uBasicDimStruct->
			  localGet(compositeUnitsBasicUnitStructsUnitA)
		    ),

		    //  If we get here the dimensions matched,
		    //  If the powers match then this may be the one.
		    //	However, if the powers do NOT match, go on to next
		    //  '@dim':
		    ^Do
		    [*[
		      @doesUnitsPossiblyMatch	:=
			(@compListStruct->
			  localGet(compositeUnitsBasicUnitStructsPowerA)
			       =num
			 @uBasicDimStruct->
			  localGet(compositeUnitsBasicUnitStructsPowerA)
			),
		      ^Break[**]
		    ]*]

		  *]
		]*],

		@uBasicDimIter->iter_advance()
	      *],
	      //  For: @dim->compositeUnitsBasicUnitA

	      //  If @uBasicDimIter is at the end then it did not find
	      //  matching '@compListStruct'.  Therefore, '@dim' does not match:
	      ^If
	      [*
		@uBasicDimIter->iter_isAtEnd(),
		@doesUnitsPossiblyMatch	:= false
	      *],

	      //  If '@dim' dies not match then break out of this
	      //  '@compositionList' loop to get the next possible '@dim' value:
	      ^If
	      [*
	       !@doesUnitsPossiblyMatch,
		^Break[**]
	      *]
	    ]*],

	    @compListIter->iter_advance()
	  *],
	  //  For: @compositionList

	  //  If '@doesUnitsPossiblyMatch' still true after going thru all
	  //  '@compositionList' values then this must be the match:
	  ^If
	  [*
	    @doesUnitsPossiblyMatch,
	    ^Return[* @dim *]
	  *]
	]*],

	@iter->iter_advance()
      *],
      //  For: @dimList

      //  II.C.4.  Create new dimension:
      @dim	:= ^^ConventionallyCompositeDimension[**],

      @dimList->dataStruct_insertZ(@dim),

      ^For
      [*
	@compListIter	:= @compositionList->dataStruct_iter(),
       !@compListIter->iter_isAtEnd(),
        @dim->assertZ
		(compositeUnitsBasicUnitA,
		 @compListIter->iter_value()
		),
	@compListIter->iter_advance()
      *],

      //  III.  Finished:
      ^Return[* @dim *]
    ]*]

  *];
  //  getDimensionGivenDefn

*};

  //  PURPOSE:  To represent the class of attributes with 'Units' as a their
  //	exclusive domain.
  UnitsA
  {*
    isA->assertZ(CulturalConventionA);

    attrsDomainA->subAssertZ(Dimension);
  *};

  //  PURPOSE:  To represent the attribute the maps from the *class* 'Units'
  //	to a map that, given a SingleDistinctPair consisting of a first and
  //	second unit, potentially maps to a 'UnitsToUnitsStruct' instance that
  //	can convert numbers from the first into the second.
  unitsClassesPairToConversionMapA
  {*
    instanceOf->assertZ(UnitsA);
  *};

  //  PURPOSE:  To map from units to their dimensions.
  unitsDimensionA
  {*
    instanceOf->assertZ(UnitsA);
  *};

  //  PURPOSE:  To represent the class of attributes of 'Units' that tell how
  //	a composite unit is composed of a basic unit.
  CompositeUnitsA
  {*
    isA->assertZ(UnitsA);
  *};

  //  PURPOSE:  To map from a composite unit to a
  //	'CompositeUnitsBasicUnitStruct' that tells about one of the units of a
  //	basic dimension from which the composite unit is multiplicatively
  //	composed.
  compositeUnitsBasicUnitA
  {*
    instanceOf->assert(CompositeUnitsA);
  *};


  //  PURPOSE:  To encompass the set of structures that tell about one of the
  //	units of a basic dimension from which the composite unit is
  //	multiplicatively composed.  'compositeUnitsBasicUnitStructsUnitA' maps
  //	from each of these structures to the unit of basic dimension.
  //	'compositeUnitsBasicUnitStructsPowerA' maps from each of these
  //	structures to the power to which the basic dimension is raised.
  CompositeUnitsBasicUnitStruct
  {*
    isA->assert(CulturalConvention);

    ideasImplicitConstructorA->subAssert
      ( ^ImplicitConstructor
	[* [ [compositeUnitsBasicUnitStructsUnitA, Units],
	     [compositeUnitsBasicUnitStructsPowerA,Number]
	   ]
	*]
      );
  *};


  //  PURPOSE:  To encompass the set of attributes used to convert between
  //	units.
  UnitConvertingRelatedA
  {*
    isA->assertZ(ProgramObjectA);
  *};


  //  PURPOSE:  To serve as a class of attributes that are parameterized by
  //	the unit to convert from to a UnitsToUnitsStruct units that tells how
  //	to convert from the subject units to the parameterized units.
  UnitsToUnitsConvertA
  {*
    isA->assertZ(UnitConvertingRelatedA);

    ideasImmutableSingleDistinctA->subAssert(true);
    ideasImplicitConstructorA->subAssert
      (^ImplicitConstructor
	[*
	  [unitsToUnitsConvertStructsToUnitsA
	  ]
	*]
      );
  *};

    //  PURPOSE:  To map from a 'UnitsToUnitsConvertA' instance to the parameter
    //	units.
    unitsToUnitsConvertStructsToUnitsA
    {*
      isA->assertZ(UnitConvertingRelatedA);
    *};


  //  PURPOSE:  To map from a 'UnhandledConversionException' instance to the
  //	alleged conversion that is, for whatever reason, unusable.
  unhandledConversionExceptionsConversionA
  {*
    instanceOf->assertZ(ExceptionA);
  *};


  //  PURPOSE:  To map from a 'UnhandledConversionException' instance to the
  //	name of the function that cannot use the alleged conversion.
  unhandledConversionExceptionsMethodNameA
  {*
    instanceOf->assertZ(ExceptionA);
  *};


  //  PURPOSE:  To implement a class derived from SPDefinedException that
  //	represents the error of a particular methods being unable to use
  //	a particular alleged 'UnhandledConversionException' instance.
  UnhandledConversionException
  {*
    isA->assertZ(SPDefinedException);

    ideasImplicitConstructorA->
      subAssert
	( ^ImplicitConstructor
	  [*  [ [unhandledConversionExceptionsConversionA,	Idea],
	      	[unhandledConversionExceptionsMethodNameA,	String]
	      ]
	  *]
	);

    //  PURPOSE:  To compute, store, and return the value for attribute
    //	    'exceptionsValueA' corresponding to '@this'
    //	    'UnhandledConversionException'.
    sub computeValue Idea
    [*
      [],

      ^Do
      [*[
	//  I.  Application validity check:

	//  II.  Compute 'exceptionsValueA' value:
	//  II.A.  Define sentence roles:
        ^VarDecl[* @phraseDS,	VectorList *],
	^VarDecl[* @conversion, Idea *],
	^VarDecl[* @methodName, String *],
	^VarDecl[* @sentence, 	NatLangDeclarativeSentence *],

	@phraseDS
		:= ^^VectorList[**],
	@conversion
		:= @this->localGet(unhandledConversionExceptionsConversionA),
	@methodName
		:= @this->localGet(unhandledConversionExceptionsMethodNameA),

	//  "<conversion> is an unusable instance of 'UnitsToUnitsStruct'
	//   for <name>."
	@phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @conversion,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		),
	@phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    anInstance,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false,
		    unusable,
		    ^^NatLangRolePhrase
		    [*
		      UnitsToUnitsStruct,
		      directObjectNatLangPhraseRole,
		      thirdPerson,
		      singularPlurality,
		      false
		    *]
		  *]
		),
	@phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @methodName,
		    forThePurposeOfNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

	//  II.B.  Define sentence:
	@sentence
		:=  ^^NatLangDeclarativeSentence
		    [*
		      toBeAs,
		      inGeneralPresentNatLangTense,
		      affirmNatLangStatus,
		      @phraseDS
		    *],
	@this->assertZ( exceptionsValueA,@sentence),

	//  III.  Finished:
	^Return[* @sentence *]
      ]*]
    *];
  *};


  //  PURPOSE:  To encompass the set of structures that tell how to convert
  //	from one unit of a given dimension to another unit of the same
  //	dimension.  This should be an abstract set.  Actual instances should
  //	be instances of subsets, like 'LinearUnitsToUnitsStruct'.
  UnitsToUnitsStruct
  {*
    isA->assertZ(CulturalConvention);
  *};


    //  PURPOSE:  To encompass the set of structures that tell how to convert
    //	  from one unit of a given dimension to another unit of the same
    //	  dimension by means of a linear transformation.  The attribute
    //	  linearUnitsToUnitsStructsMultiplierA maps from instances of this set
    //	  to a number 'm', and, the attribute linearUnitsToUnitsStructsOffsetA
    //	  maps from instances of this set to a number 'b' such that for a
    //	  number 'x' in the "from" units the formula 'm*x + b' computes the
    //	  number in the "to" units.
    LinearUnitsToUnitsStruct
    {*
      isA->assertZ(UnitsToUnitsStruct);


      //  The default offset is 0
      linearUnitsToUnitsStructsOffsetA->subAssert(0);
      ideasImplicitConstructorA->subAssert
        ( ^ImplicitConstructor
	  [*[ [linearUnitsToUnitsStructsFromUnitsA,	Units],
	      [linearUnitsToUnitsStructsToUnitsA,	Units],
	      [linearUnitsToUnitsStructsMultiplierA,	Number],
	      [linearUnitsToUnitsStructsOffsetA,    	Number]
	    ]
	  *]
	);


      //  PURPOSE:  To return the 'Number' instance corresponding to converting
      //      '@number' of units '@this->linearUnitsToUnitsStructsFromUnitsA' to
      //      units '@this->linearUnitsToUnitsStructsToUnitsA'.
      sub  forwardConvert  Number
      [*
	[ [@number, Number]
	],

	^Do
	[*[
	  ^VarDecl[* @offset, Idea *],
	  ^VarDecl[* @scale, Idea *],

	  @offset := @this->localGet(linearUnitsToUnitsStructsOffsetA),
	  @scale  := @this->localGet(linearUnitsToUnitsStructsMultiplierA),

	  ^If
	  [*
	    @scale->isInstanceOf(Number),
	    @number	:= @number * @scale
	  *],

	  ^If
	  [*
	    @offset->isInstanceOf(Number),
	    @number	:= @number +ext @offset
	  *],

	  ^Return[* @number *]
	]*]
      *];


      //  PURPOSE:  To return the 'Number' instance corresponding to converting
      //      '@number' of units '@this->linearUnitsToUnitsStructsToUnitsA' to
      //      units '@this->linearUnitsToUnitsStructsFromUnitsA'.
      sub  reverseConvert  Number
      [*
	[ [@number, Number]
	],

	^Do
	[*[
	  ^VarDecl[* @offset, Idea *],
	  ^VarDecl[* @scale, Idea *],

	  @offset := @this->localGet(linearUnitsToUnitsStructsOffsetA),
	  @scale  := @this->localGet(linearUnitsToUnitsStructsMultiplierA),

	  ^If
	  [*
	    @offset->isInstanceOf(Number),
	    @number	:= @number -ext @offset
	  *],

	  ^If
	  [*
	    @scale->isInstanceOf(Number),
	    @number	:= @number / @scale
	  *],

	  ^Return[* @number *]
	]*]
      *];


      //  PURPOSE:  To create and return a 'UnitsToUnitsStruct' instance that
      //	is equivalent to conversion '@prev' followed by '@this'
      //	conversion.
      sub	createForwardConverter	UnitsToUnitsStruct
      [*
	[ [@prev,	UnitsToUnitsStruct]
	],

	^Do
	[*[
	  //  I.  Application validity check:

	  //  II.  Attempt to create a composite conversion:
	  //  II.A.  Handle when '@prev' is instance of
	  //  	     'LinearUnitsToUnitsStruct':
	  ^If
	  [*
	    @prev->isInstanceOf(LinearUnitsToUnitsStruct),

	    ^Do
	    [*[
	      ^VarDecl
	      [*
		@prevScale,
		Number,
		@prev->localGet(linearUnitsToUnitsStructsMultiplierA)
	      *],
	      ^VarDecl
	      [*
		@prevOffset,
		Number,
		@prev->localGet(linearUnitsToUnitsStructsOffsetA)
	      *],
	      ^VarDecl[* @thisObj, LinearUnitsToUnitsStruct *],
	      @thisObj := @this,
	      ^VarDecl
	      [*
		@thisScale,
		Number,
		@thisObj->localGet(linearUnitsToUnitsStructsMultiplierA)
	      *],
	      ^VarDecl
	      [*
		@thisOffset,
		Number,
		@thisObj->localGet(linearUnitsToUnitsStructsOffsetA)
	      *],

	      ^If
	      [*
	        @prevScale->isNull(),
		@prevScale := 1
	      *],

	      ^If
	      [*
	        @prevOffset->isNull(),
		@prevOffset := 0
	      *],

	      ^If
	      [*
	        @thisScale->isNull(),
		@thisScale := 1
	      *],

	      ^If
	      [*
	        @thisOffset->isNull(),
		@thisOffset := 0
	      *],

	      ^Return
	      [*
		^^LinearUnitsToUnitsStruct
		[*
		  @prev->localGet(linearUnitsToUnitsStructsFromUnitsA),
		  @this->localGet(linearUnitsToUnitsStructsToUnitsA),
		  @prevScale * @thisScale,
		  @thisScale * @prevOffset +ext @thisOffset
		*]
	      *]
	    ]*]
	  *],

	  //  III.  If get here then '@prev' is an unhandled conversion:
	  ^Throw
	  [*
	    ^^UnhandledConversionException
	    [*
	      @prev,
	      "LinearUnitsToUnitsStruct's createForwardConverter()"
	    *]
	  *]
	]*]
      *];
      //  End createForwardConverter


      //  PURPOSE:  To create and return a 'UnitsToUnitsStruct' instance that
      //	is equivalent to conversion '@prev' followed by the opposite
      //	of '@this' conversion.
      sub	createReverseConverter	UnitsToUnitsStruct
      [*
	[ [@prev,	UnitsToUnitsStruct]
	],

	^Do
	[*[
	  //  I.  Application validity check:

	  //  II.  Attempt to create a composite conversion:
	  //  II.A.  Handle when '@prev' is instance of
	  //  	     'LinearUnitsToUnitsStruct':
	  ^If
	  [*
	    @prev->isInstanceOf(LinearUnitsToUnitsStruct),

	    ^Do
	    [*[
	      ^VarDecl
	      [*
		@prevScale,
		Number,
		@prev->localGet(linearUnitsToUnitsStructsMultiplierA)
	     *],
	      ^VarDecl
	      [*
		@prevOffset,
		Number,
		@prev->localGet(linearUnitsToUnitsStructsOffsetA)
	      *],
	      ^VarDecl[* @thisObj, LinearUnitsToUnitsStruct *],
	      @thisObj := @this,
	      ^VarDecl
	      [*
		@thisScale,
		Number,
		@thisObj->localGet(linearUnitsToUnitsStructsMultiplierA)
	      *],
	      ^VarDecl
	      [*
		@thisOffset,
		Number,
		@thisObj->localGet(linearUnitsToUnitsStructsOffsetA)
	      *],

	      ^If
	      [*
	        @prevScale->isNull(),
		@prevScale := 1
	      *],

	      ^If
	      [*
	        @prevOffset->isNull(),
		@prevOffset := 0
	      *],

	      ^If
	      [*
	        @thisScale->isNull(),
		@thisScale := 1
	      *],

	      ^If
	      [*
	        @thisOffset->isNull(),
		@thisOffset := 0
	      *],

	      ^Return
	      [*
		^^LinearUnitsToUnitsStruct
		[*
		  @prev->localGet(linearUnitsToUnitsStructsFromUnitsA),
		  @this->localGet(linearUnitsToUnitsStructsFromUnitsA),
		  @prevScale / @thisScale,
		  (@prevOffset -ext @thisOffset) / @thisScale
		*]
	      *]
	    ]*]
	  *],

	  //  III.  If get here then '@prev' is an unhandled conversion:
	  ^Throw
	  [*
	    ^^UnhandledConversionException
	    [*
	      @prev,
	      "LinearUnitsToUnitsStruct's createForwardConverter()"
	    *]
	  *]
	]*]
      *];
      //  End createReverseConverter

    *};


    //  PURPOSE:  To map from 'LinearUnitsToUnitsStruct' instances to the
    //	  units from which the conversion goes.
    linearUnitsToUnitsStructsFromUnitsA
    {*
      instanceOf->assertZ(UnitConvertingRelatedA);
    *};

    //  PURPOSE:  To map from 'LinearUnitsToUnitsStruct' instances to the
    //	  units to which the conversion goes.
    linearUnitsToUnitsStructsToUnitsA
    {*
      instanceOf->assertZ(UnitConvertingRelatedA);
    *};

    //  PURPOSE:  To map from 'LinearUnitsToUnitsStruct' instances to the
    //	  number to multiply from units to obtain the correct value in the to
    //	  units.
    linearUnitsToUnitsStructsMultiplierA
    {*
      instanceOf->assertZ(UnitConvertingRelatedA);
    *};

    //  PURPOSE:  To map from 'LinearUnitsToUnitsStruct' instances to the
    //	  number to add from units to obtain the correct value in the to
    //	  units.
    linearUnitsToUnitsStructsOffsetA
    {*
      instanceOf->assertZ(UnitConvertingRelatedA);
    *};


  //  PURPOSE: To encompass the set of attributes used to convert between
  //	units of different dimensions.
  DiffDimensionUnitConvertingRelatedA
  {*
    isA->assertZ(UnitConvertingRelatedA);
  *};

  //  PURPOSE: To encompass a set of attributes that map from sets to
  //	DiffDimensionalUnitConversionStruct instances
  //	that tells how to convert a value from one dimension to another.
  //	The instance is parameterized by:
  //	'diffDimensionalUnitConversionAttrsFromAttrA' (which from attr)
  //	'diffDimensionalUnitConversionAttrsFromDimA' (which from dim)
  //	'diffDimensionalUnitConversionAttrsToAttrA' (which to attr)
  //	'diffDimensionalUnitConversionAttrsToDimA' (which to dim)
  //
  //	An example of when one would want to do this is with:
  //	^DiffDimensionalUnitConversionA
  //		[*waveNumberA,inverseDistance,frequencyA,inverseTime*]->
  //	    assert(  ^DiffDimensionalUnitConversionStruct
  //		     [*	wavenumbers,		// from units (e.g. IR spectro)
  //		     	hertz,			// to units (conventional
  //						//  measure for photons)
  //			29979245800,		// speed of light (c) in cm/sec
  //			[einsteinianWorldView]	// assumptions
  //		     *]
  //		  );
  DiffDimensionalUnitConversionA
  {*
    isA->assertZ(DiffDimensionUnitConvertingRelatedA);

    ideasImmutableSingleDistinctA->subAssert(true);
    ideasImplicitConstructorA->
      subAssert
	(^ImplicitConstructor
	    [*
	      [diffDimensionalUnitConversionAttrsFromAttrA,
	       diffDimensionalUnitConversionAttrsFromDimA,
	       diffDimensionalUnitConversionAttrsToAttrA,
	       diffDimensionalUnitConversionAttrsToDimA
	      ]
	    *]
	);
  *};

    //  PURPOSE: To map from a DiffDimensionalUnitConversionA instace to the
    //	  attribute that the corresponding different dimensional conversion
    //	  maps from.
    diffDimensionalUnitConversionAttrsFromAttrA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};

    //  PURPOSE: To map from a DiffDimensionalUnitConversionA instance to the
    //	  dimension that the corresponding different dimensional conversion
    //	  maps from.
    diffDimensionalUnitConversionAttrsFromDimA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};

    //  PURPOSE: To map from a DiffDimensionalUnitConversionA instance to the
    //	  attribute that the corresponding different dimensional conversion
    //	  maps to.
    diffDimensionalUnitConversionAttrsToAttrA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};

    //  PURPOSE: To map from a DiffDimensionalUnitConversionA instance to the
    //	  dimension that the corresponding different dimensional conversion
    //	  maps to.
    diffDimensionalUnitConversionAttrsToDimA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};


  //  PURPOSE:  To tell how to convert to from one value of one attribute,
  //	dimension and units to another of another attribute, dimension
  //	and units.
  DiffDimensionalUnitConversionStruct
  {*
    isA->assertZ(ProgramObject);

    ideasImplicitConstructorA->
      subAssert
	(^ImplicitConstructor
	    [*
	      [diffDimensionalUnitConversionStructsFromUnitA,
	       diffDimensionalUnitConversionStructsToUnitA,
	       diffDimensionalUnitConversionStructsExprA,
	       diffDimensionalUnitConversionStructsAssmptnA
	      ]
	    *]
	);
  *};

    //  PURPOSE:  To map from a DiffDimensionalUnitConversionStruct instance
    //	  to the units that the conversion expression expects.
    diffDimensionalUnitConversionStructsFromUnitA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};

    //  PURPOSE:  To map from a DiffDimensionalUnitConversionStruct instance
    //	  to the units that the conversion expression generates.
    diffDimensionalUnitConversionStructsToUnitA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};

    //  PURPOSE:  To map from a DiffDimensionalUnitConversionStruct instance
    //	  to the expression that does the conversion.
    diffDimensionalUnitConversionStructsExprA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};

    //  PURPOSE:  To map from a DiffDimensionalUnitConversionStruct instance
    //	to the list of assumptions that must be made.
    diffDimensionalUnitConversionStructsAssmptnA
    {*
      instanceOf->assertZ(DiffDimensionUnitConvertingRelatedA);
    *};



//									//
//				Domains					//
//									//

//  PURPOSE:  To map from 'AnnotatedValueOutsideOfRangeException' instances to
//	the AnnotatedValue with the illegal value.
annotatedValueOutsideOfRangeExceptionsAnnotatedValueA
{*
   instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from 'AnnotatedValueOutsideOfRangeException' instances to
//	the attribute of the domain that has been violated
annotatedValueOutsideOfRangeExceptionsAttrA
{*
   instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent the creation of an AnnotatedValue with a value that
//	is outside of a semantic domain boundary.
AnnotatedValueOutsideOfRangeException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [annotatedValueOutsideOfRangeExceptionsAnnotatedValueA,
	     AnnotatedValue
	    ],
	    [annotatedValueOutsideOfRangeExceptionsAttrA,
	     Attribute
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantUnitsException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@annotatedValue,
	AnnotatedValue,
	@thisException->
		localGet(annotatedValueOutsideOfRangeExceptionsAnnotatedValueA)
      *],
      ^VarDecl
      [*
	@attr,
	Idea,
	@thisException->localGet(annotatedValueOutsideOfRangeExceptionsAttrA)
      *],
      ^VarDecl[* @domain, Domain, @annotatedValue->localGet(valuesDomainA) *],

      //  II.B.  Build natural language expression:
      //  "'@annotatedValue' violates an instance of a semantic constraint
      //  "'@annotatedValue' violates an instance of an attribute named '@attr'
      //   of the instance of domain named '@domain'":
      ^VarDecl
      [*
      	@anInstanceOfAnAttr,
	NatLangExpr,
	^^NatLangRolePhrase
	[*
	  Attribute,
	  directObjectNatLangPhraseRole,
	  thirdPerson,
	  singularPlurality,
	  false,
	  ^^NatLangRolePhrase
	  [*
	    Domain,
	    directObjectNatLangPhraseRole,
	    thirdPerson,
	    singularPlurality,
	    false,
	    ^^NatLangDeclarativeSentence
	    [*
	      toName,
	      inGeneralPastNatLangTense,
	      affirmNatLangStatus,
	      ^^VectorList[**]->dataStruct_insert
				( ^^NatLangRolePhrase
				  [*
				    @domain,
				    directObjectNatLangPhraseRole,
				    thirdPerson,
				    singularPlurality
				  *]
				),
	      directObjectNatLangPhraseRole
	    *]
	  *],
	  ^^NatLangDeclarativeSentence
	  [*
	    toName,
	    inGeneralPastNatLangTense,
	    affirmNatLangStatus,
	    ^^VectorList[**]->dataStruct_insert
				( ^^NatLangRolePhrase
				  [*
				    @attr,
				    directObjectNatLangPhraseRole,
				    thirdPerson,
				    singularPlurality
				  *]
				),
	    directObjectNatLangPhraseRole
	  *]
	*]
      *],

      ^VarDecl[* @phraseDS, VectorList, ^^VectorList[**] *],

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @annotatedValue,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		),
      @phraseDS->
	    dataStruct_insertZ
		(@anInstanceOfAnAttr
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toViolate,
	  inGeneralPastNatLangTense,
	  affirmNatLangStatus,
	  @phraseDS,
	  directObjectNatLangPhraseRole
	*]
      *],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
  //  computeValue()

*};


//  PURPOSE:  To map from an
//	'AttemptToRegisterConflictingOpDomainResultException' instance to a
//	'List' instance that tells the operation with conflicting results.
attemptToRegisterConflictingOpDomainResultExceptionsOperationA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an
//	'AttemptToRegisterConflictingOpDomainResultException' instance to the
//	'Domain' instance that conflicts with what was recorded earlier.
attemptToRegisterConflictingOpDomainResultExceptionsNewResultDomainA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To map from an
//	'AttemptToRegisterConflictingOpDomainResultException' instance to the
//	'Domain' instance that conflicts with a newly 'Domain' instance
//	that has been attempted to record.
attemptToRegisterConflictingOpDomainResultExceptionsRecordedDomainA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent an attempt to a conflicting 'Domain' instance
//	that results from applying an 'Operator' instance upon a 'Domain'
//	instance.
AttemptToRegisterConflictingOpDomainResultException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [attemptToRegisterConflictingOpDomainResultExceptionsOperationA,
	     Idea
	    ],
	    [
	   attemptToRegisterConflictingOpDomainResultExceptionsNewResultDomainA,
	     Domain
	    ],
	    [
	   attemptToRegisterConflictingOpDomainResultExceptionsRecordedDomainA,
	     Domain
	    ]
	  ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantUnitsException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compute 'exceptionsValueA' value:
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@operation,
	Idea,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDomainResultExceptionsOperationA)
      *],
      ^VarDecl
      [*
	@newResultDomain,
	Domain,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDomainResultExceptionsNewResultDomainA)
      *],
      ^VarDecl
      [*
	@recordedDomain,
	Dimension,
	@thisException->localGet
	  (attemptToRegisterConflictingOpDomainResultExceptionsRecordedDomainA)
      *],


      //  "The sp8b cannot register '@operation' -> '@newResultDomain'
      //    because the sp8b registered '@operation' -> '@recordedDomain'."

      //  '@operation'
      ^VarDecl
      [*
	@key,
	String,
	@operation->toString()
      *],

      //  "'@operation' -> '@newResultDomain'"
      ^VarDecl
      [*
	@toRegisterString,
	String,
	@key +con " -> " +con @newResultDomain->toString()
      *],

      //  "'@operation' -> '@recordedDomain'."
      ^VarDecl
      [*
	@conflictWithString,
	String,
	@key +con " -> " +con @recordedDomain->toString()
      *],

      // "that conflicts with '@operator' -> '@recordedDomain'"

      ^VarDecl[* @innerPhraseDS, VectorList, ^^VectorList[**] *]


    ]*]
  *];
  
*};


domainWithOutDimensionExceptionsDomainA
{*
  instanceOf->assertZ(ExceptionA);
*};

DomainWithOutDimensionException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [domainWithOutDimensionExceptionsDomainA
	    ]
          ]
	*]
      );

  //  PURPOSE:  To compute, store, and return the value for attribute
  //	'exceptionsValueA' corresponding to '@this'
  //	'AttemptToRegisterRedundantUnitsException'.
  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  "<domain> does not have a value for the attribute named <attr>"
      //  II.A.  Define sentence roles:
      ^VarDecl[* @thisException,	SPDefinedException, @this *],
      ^VarDecl
      [*
	@domain,
	Idea,
	@thisException->localGet(domainWithOutDimensionExceptionsDomainA)
      *],
      
      ^VarDecl[* @phraseDS, VectorList, ^^VectorList[**] *],

      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    @domain,
		    subjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    true
		  *]
		),
      @phraseDS->
	    dataStruct_insertZ
		( ^^NatLangRolePhrase
		  [*
		    domainsDimensionA,
		    directObjectNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),

      ^VarDecl
      [*
	@sentence,
	NatLangDeclarativeSentence,
	^^NatLangDeclarativeSentence
	[*
	  toOwn,
	  inGeneralPresentNatLangTense,
	  negateNatLangStatus,
	  @phraseDS
	*]
      *],

      //  III.  Finished:
      @this->assertZ(exceptionsValueA,@sentence),
      ^Return[* @sentence *]
    ]*]
  *];
*};


DomainWithOutUnitsException
{*
*};


//  PURPOSE:  To map from instances of 'DomainsRangeConstraint' to their more
//	general domain instance.
domainsRangeConstraintsMoreGeneralDomainA
{*
  instanceOf->assertZ(CulturalConventionA);
*};

//  PURPOSE:  To map from instances of 'DomainsRangeConstraint' to their more
//	specific domain instance.
domainsRangeConstraintsMoreSpecificDomainA
{*
  instanceOf->assertZ(CulturalConventionA);
*};

//  PURPOSE:  To represent meaningful ranges that may be defined for Domain
//	instances.
DomainSemanticRange
{*
  isA->assertZ(CulturalConvention);
*};

//  PURPOSE:  To map from 'DomainSemanticRange' instances to the attribute
//	that tells the high limit of that semantic range for a 'Domain'
//	instance.
domainSemanticRangesHiAttrA
{*
  instanceOf->assertZ(CulturalConventionA);
*};


//  PURPOSE:  To map from 'DomainSemanticRange' instances to the attribute
//	that tells the low limit of that semantic range for a 'Domain'
//	instance.
domainSemanticRangesLoAttrA
{*
  instanceOf->assertZ(CulturalConventionA);
*};


//  DELETE ???
domainSemanticRangesAttrCA
{*
  isA->assertZ(CulturalConventionA);
*};

//  PURPOSE:  To represent the range imposed on 'Domain' instances by the
//	definition of the 'Domain'.
definitionalDomainSemanticRange
{*
  instanceOf->assertZ(DomainSemanticRange);
  domainSemanticRangesHiAttrA->assertZ(domainsHiRangeDefineLimitA);
  domainSemanticRangesLoAttrA->assertZ(domainsLoRangeDefineLimitA);
  domainSemanticRangesAttrCA->assertZ(DomainsRangeDefinitionLimitA);
*};

//  PURPOSE:  To represent the range imposed on 'Domain' instances by the
//	system the Domain helps to measure.
systemDomainSemanticRange
{*
  instanceOf->assertZ(DomainSemanticRange);
  domainSemanticRangesHiAttrA->assertZ(domainsHiSystemLimitA);
  domainSemanticRangesLoAttrA->assertZ(domainsLoSystemLimitA);
  domainSemanticRangesAttrCA->assertZ(DomainsSystemLimitA);
*};

//  PURPOSE:  To represent the range imposed on 'Domain' instances by the
//	ability to detect values with the technology used to measure.
detectionDomainSemanticRange
{*
  instanceOf->assertZ(DomainSemanticRange);
  domainSemanticRangesHiAttrA->assertZ(domainsHiDetectionLimitA);
  domainSemanticRangesLoAttrA->assertZ(domainsLoDetectionLimitA);
  domainSemanticRangesAttrCA->assertZ(DomainsDetectionLimitA);
*};

//  PURPOSE:  To represent the range imposed on 'Domain' instances by the
//	system the Domain helps to measure when the system empirical saturates
//	at some extreme value.
saturationDomainSemanticRange
{*
  instanceOf->assertZ(DomainSemanticRange);
  domainSemanticRangesHiAttrA->assertZ(domainsHiSaturationLimitA);
  domainSemanticRangesLoAttrA->assertZ(domainsLoSaturationLimitA);
  domainSemanticRangesAttrCA->assertZ(DomainsSaturationLimitA);
*};

//  PURPOSE:  To represent the range imposed on 'Domain' instances by the
//	ability to detect values with the technology used to measure when the
//	technology cannot be relied upon to register more extreme values.
reliabilityDomainSemanticRange
{*
  instanceOf->assertZ(DomainSemanticRange);
  domainSemanticRangesHiAttrA->assertZ(domainsHiReliabilityLimitA);
  domainSemanticRangesLoAttrA->assertZ(domainsLoReliabilityLimitA);
  domainSemanticRangesAttrCA->assertZ(DomainsReliabilityLimitA);
*};

//  PURPOSE:  To represent the range on 'Domain' instances that empirically
//	occur.
observedDomainSemanticRange
{*
  instanceOf->assertZ(DomainSemanticRange);
  domainSemanticRangesHiAttrA->assertZ(domainsHiObservedLimitA);
  domainSemanticRangesLoAttrA->assertZ(domainsLoObservedLimitA);
*};


//  PURPOSE:  To represent a constraint between ranges of a Domain.
DomainsRangeConstraint
{*
  isA->assertZ(CulturalConvention);

  ideasImplicitConstructorA->
    subAssert
      ( ^ImplicitConstructor
	[*
	  [ [domainsRangeConstraintsMoreGeneralRangeA,	DomainSemanticRange],
	    [domainsRangeConstraintsMoreSpecificRangeA, DomainSemanticRange]
          ]
	*]
      );


  //  PURPOSE: To return 'true' if '@this' Constraint holds for Domain
  //	 '@domain' between the two 'DomainSemanticRange' instances.
  sub check Idea
  [*
    [ [@domain, Domain]
    ],

    ^Do
    [*[
      //  I.  Applicability validity check:

      //  II.  Ensure that '@this' constraint is followed by '@domain':
      //  II.A.  Get the more general and more specific ranges:
      ^VarDecl[* @thisConstraint, DomainsRangeConstraint, @this *],
      ^VarDecl
      [*
        @generalRange,
	DomainSemanticRange,
	@thisConstraint->localGet(domainsRangeConstraintsMoreGeneralRangeA)
      *],
      ^VarDecl
      [*
        @specificRange,
	DomainSemanticRange,
	@thisConstraint->localGet(domainsRangeConstraintsMoreSpecificRangeA)
      *],

      //  II.B.  Check the hi values of the ranges:
      ^VarDecl
      [*
        @generalHiAttr,
	Attribute,
	@generalRange->localGet(domainSemanticRangesHiAttrA)
      *],

      ^VarDecl[* @genNum, Number, @domain->localGet(@generalHiAttr) *],
      ^VarDecl[* @specNum, Number *],

      ^If
      [*
	!@genNum->isNull(),

	^Do
	[*[
	  ^VarDecl
	  [*
	    @specificHiAttr,
	    Attribute,
	    @specificRange->localGet(domainSemanticRangesHiAttrA)
	  *],
	  @specNum := @domain->localGet(@specificHiAttr),

	  ^If
	  [*
	    @specNum->isNull(),

	    @domain->assert(@specificHiAttr,@genNum),

	    ^If
	    [*
	      (@specNum > @genNum),
	      ^Throw[* ^^NonCompliantDomainException[* *] *]
	    *]
	  *]
	]*]
      *],

      //  II.C.  Check the lo values of the ranges:
      ^VarDecl
      [*
        @generalLoAttr,
	Attribute,
	@generalRange->localGet(domainSemanticRangesLoAttrA)
      *],

      @genNum := @domain->localGet(@generalLoAttr),

      ^If
      [*
	!@genNum->isNull(),

	^Do
	[*[
	  ^VarDecl
	  [*
	    @specificLoAttr,
	    Attribute,
	    @specificRange->localGet(domainSemanticRangesLoAttrA)
	  *],
	  @specNum := @domain->localGet(@specificLoAttr),

	  ^If
	  [*
	    @specNum->isNull(),

	    @domain->assert(@specificLoAttr,@genNum),

	    ^If
	    [*
	      (@specNum < @genNum),
	      ^Throw[* ^^NonCompliantDomainException[* *] *]
	    *]
	  *]	  
	]*]
      *]

      //  III.  Finished:
    ]*]
  *];
*};

//  PURPOSE:  To represent the class of domains of attributes used in
//	annotated values.
Domain
{*
  isA->assertZ(CulturalConvention);

//ideasIsSingleDistinctA->subAssert(true);

//domainClassesHashMapA->assert(^^Map[**]);
  domainClassesOperationResultMapA->assert(^Map[**]);

  domainClassesDomainRangeConstraintLA->
	assert
	( [ ^DomainsRangeConstraint
	    [*
	      definitionalDomainSemanticRange,
	      systemDomainSemanticRange
	    *],
	    ^DomainsRangeConstraint
	    [*
	      systemDomainSemanticRange,
	      saturationDomainSemanticRange
	    *],
	    ^DomainsRangeConstraint
	    [*
	      definitionalDomainSemanticRange,
	      detectionDomainSemanticRange
	    *],
	    ^DomainsRangeConstraint
	    [*
	      detectionDomainSemanticRange,
	      reliabilityDomainSemanticRange
	    *],
	    ^DomainsRangeConstraint
	    [*
	      systemDomainSemanticRange,
	      observedDomainSemanticRange
	    *],
	    ^DomainsRangeConstraint
	    [*
	      detectionDomainSemanticRange,
	      observedDomainSemanticRange
	    *]
	  ]
	);

  //  PURPOSE:  To return a Domain equivalent to '@domain'.  If no domain
  //	equivalent to '@domain' has been seen before then '@domain' will be
  //	noted as an immutable single distinct instance, and '@domain' will
  //	itself be returned.
  register Domain
  [*
    [ [@domain, Domain]
    ],
 
    ^Do
    [*[
      //  I.  Application validity check:
      //  I.A.  Ensure have dimension and units:
      ^If
      [*
	@domain->localGet(domainsDimensionA)->isNull(),
	^Throw[* ^^DomainWithOutDimensionException[*@domain*] *]
      *],

      ^If
      [*
	@domain->localGet(domainsUnitsA)->isNull(),
	^Throw[* ^^DomainWithOutUnitsException[*@domain*] *]
      *],

      //  I.B.  Ensure hi/lo value constraints:
      ^VarDecl[* @iter, Iterator *],
      ^For
      [*
	//  I.B.1.  Create iterator over ranges:
	@iter := DomainSemanticRange->prop_iter(hasInstance),

	//  I.B.2.  Stop when at end:
       !@iter->iter_isAtEnd(),

	//  I.B.3.  Do check:
	^Do
	[*[
	  //  I.B.3.a.  Get upper attribute and value:
	  ^VarDecl[* @range,  DomainSemanticRange,   @iter->iter_value() *],
	  ^VarDecl
	  [*
	    @hiAttr,
	    DomainsSemanticRangeA,
	    @range->localGet(domainSemanticRangesHiAttrA)
	  *],
	  ^VarDecl[* @hiBound, Number, @domain->localGet(@hiAttr) *],

	  ^VarDecl[* @loAttr,  DomainsSemanticRangeA *],
	  ^VarDecl[* @loBound, Number *],

	  //  I.B.3.b.  Continue with check if an upper bound exists:
	  ^If
	  [*
	    !@hiBound->isNull(),

	    ^Do
	    [*[
	      //  I.B.3.c.  Get lower attribute and value:
	      @loAttr	:= @range->localGet(domainSemanticRangesLoAttrA),
	      @loBound	:= @domain->localGet(@loAttr),

	      //  I.B.3.d.  Do if have both upper and lower bound:
	      ^If
	      [*
		!@loBound->isNull() && (@loBound > @hiBound),
		^Throw[* ^^SomeTypeOfException[**] *]
	      *]
	    ]*]
	  *]
	]*],

	//  I.B.4.  Go on to next upper limit attribute:
	@iter->iter_advance()
      *],

      //  I.C.  Check to ensure compliance with constraints:
      ^For
      [*
        @iter :=
	  Domain->
	    localGet(domainClassesDomainRangeConstraintLA)->dataStruct_iter(),

       !@iter->iter_isAtEnd(),

	@iter->iter_value()->check(@domain),

	@iter->iter_advance() 
      *],

      //  II.  Register the domain:
      //  II.A.  Look for pre-existing equivalent Domain instance:
      @domain := @domain->getEquivalentSingleDistinct(),

      //  III.  Finished:
      ^Return[* @domain *]
    ]*]
  *];
  //  End register()


  //  PURPOSE:  To register that Operator instance '@operator' operating on
  //	operands with 'Domain' instances '@domain0' and '@domain1' results in
  //	an operand with 'Domain' instance '@resultingDomain'.  Returns
  //	'@resultingDomain'.
  registerOperationResult Domain
  [*
    [ [@operator, Operator],
      [@domain0, Domain],
      [@domain1, Domain],
      [@resultingDomain, Domain]
    ],
 
    ^Do
    [*[
      //  I.  Application validity check:

      //  Be sure to use getEquivalentSingleDistinct() to make ensure we use the exact same list key.

      //  II.  Register that Operator instance '@operator' operating on
      //       operands with 'Domain' instances '@domain0' and '@domain1'
      //       results in an operand with 'Domain' instance '@resultingDomain':
      //  II.A.  Construct '@key':
      ^VarDecl[* @key, VectorList, ^^VectorList[**] *],
      @key->dataStruct_insertZ(@operator),
      @key->dataStruct_insertZ(@domain0),
      @key->dataStruct_insertZ(@domain1),
      @key := @key->getEquivalentSingleDistinct(),

      //  II.B.  Get map that holds results:
      ^VarDecl[*@map, Map, Domain->localGet(domainClassesOperationResultMapA)*],

      //  II.C.  See what is already recorded at '@key':
      ^VarDecl[* @recordedDom, Domain, @map->map_get(@key) *],
      ^If
      [*
	@recordedDom->isNull(),

	//  II.C.1.  Nothing is recorded at '@key', insert '@resultingDomain':
	@map->map_put(@key,@resultingDomain),

	//  II.C.2.  else something is already recorded:
	//  II.C.2.a.  Complain if what is already recorded disagrees with
	//	       '@resultingDomain':
	^If
	[*
	  (@recordedDom !=ref @resultingDomain),

	  ^Throw
	  [*
	    ^^AttemptToRegisterConflictingOpDomainResultException
	    [*
	      @key,
	      @resultingDomain,
	      @recordedDom
	    *]
	  *]
	*]
      *],

      //  III.  Finished:
      ^Return[* @resultingDomain *]
    ]*]
 
  *];
  //  End registerOperationResult()
 
 
  //  PURPOSE:  To look up and return the 'Domain' instance that results when
  //	'Operator' instance '@operator' operates on operands with 'Domain'
  //	instances '@domain0' and '@domain1'.  Returns 'null' if no such
  //	'Domain' instance is known.
  operationResult  Domain
  [*
    [ [@operator,	Operator],
      [@domain0,	Domain],
      [@domain1,	Domain]
    ],
 
    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Attempt to look up the resulting 'Domain' instance:
      //  II.A.  Construct '@key':
      ^VarDecl[* @key, VectorList, ^^VectorList[**] *],
      @key->dataStruct_insertZ(@operator),
      @key->dataStruct_insertZ(@domain0),
      @key->dataStruct_insertZ(@domain1),
      @key := @key->getEquivalentSingleDistinct(),

      //  II.B.  See if we already have an answer inside our map:
      ^VarDecl[*@map, Map, Domain->localGet(domainClassesOperationResultMapA)*],
      ^VarDecl[* @recordedDom, Domain, @map->map_get(@key) *],

      ^If
      [*
	!@recordedDom->isNull(),
	^Return[* @recordedDom *]
      *],


      //  III.  Return value:
      ^Return
      [*
        Domain->localGet(domainClassesOperationResultMapA)->map_get(@key)
      *]
    ]*]
  *];
  //  End operationResult()

*};

  //  PURPOSE:  To represent the class of attributes whose domain is class
  //	'Domain'.
  DomainA
  {*
    isA->assertZ(CulturalConventionA);

    attrsDomainA->subAssertZ(Domain);
  *};

  //  PURPOSE:  To map from the *class* Domain to the static map that maps
  //	from hash Rational instances to domain instances.
  domainClassesHashMapA
  {*
    instanceOf->assertZ(DomainA);
  *};

  //  PURPOSE:  To map from the *class* Domain to the static map that maps
  //	from [operator,domain0,domain1] lists to domains that result from
  //	applying Operator 'operator' on domains 'domain0' and 'domain1'.
  domainClassesOperationResultMapA
  {*
    instanceOf->assertZ(DomainA);
  *};

  //  PURPOSE:  To represent the class of attributes of attributes of Domain
  //	instances.
  DomainAttrA
  {*
    isA->assertZ(CulturalConventionA);
    attrsDomainA->subAssertZ(DomainA);
  *};


    //  PURPOSE:  To map from instances of 'Domain' to the dimension of that
    //	  domain.
    domainsDimensionA
    {*
      instanceOf->assert(DomainA);
    *};


    //  PURPOSE:  To map from instances of 'Domain' to the units used in that
    //	  domain.
    domainsUnitsA
    {*
      instanceOf->assert(DomainA);
    *};

    //  PURPOSE:  To represent the class of range-related attributes of Domain
    //	  instances.
    DomainsRangeA
    {*
      isA->assert(DomainA);
    *};

    //  PURPOSE:  To represent the class of attributes of Domains defined
    //	  pragmatically by extremities.
    DomainsPragmaticExtremeRangeA
    {*
      isA->assert(DomainsRangeA);
    *};

    //  PURPOSE:  To represent the class of attributes giving lower limits on
    //	  the values in 'Domain' instances.
    DomainsLowerLimitA
    {*
      isA->assert(DomainsPragmaticExtremeRangeA);
    *};

    //  PURPOSE:  To represent the class of attributes giving upper limits on
    //	  the values in 'Domain' instances.
    DomainsUpperLimitA
    {*
      isA->assert(DomainsPragmaticExtremeRangeA);
    *};

    //  PURPOSE:  To represent the class of attributes of Domains defined
    //	  semantically.
    DomainsSemanticRangeA
    {*
      isA->assert(DomainsRangeA);
    *};

    //  PURPOSE:  To represent the attribute that maps from subclasses of
    //	  'DomainsSemanticRangeA' to the attribute that tells the lower bound
    //	  of that class.
    domainsSemanticRangeAttrClassesLowerBoundAttrA
    {*
      instanceOf->assertZ(DomainAttrA);
    *};

    //  PURPOSE:  To represent the attribute that maps from subclasses of
    //	  'DomainsSemanticRangeA' to the attribute that tells the upper bound
    //	  of that class.
    domainsSemanticRangeAttrClassesUpperBoundAttrA
    {*
      instanceOf->assertZ(DomainAttrA);
    *};

    domainsSemanticRangeAttrClassesRangeA
    {*
      isA->assertZ(CulturalConventionA);
    *};

    //  PURPOSE:  To represent the class of attributes giving the defined
    //	  limits of 'Domain' instances.
    DomainsRangeDefinitionLimitA
    {*
      isA->assert(DomainsSemanticRangeA);
      domainsSemanticRangeAttrClassesRangeA->
				assertZ(definitionalDomainSemanticRange);
      domainsSemanticRangeAttrClassesLowerBoundAttrA->
				assertZ(domainsLoRangeDefineLimitA);
      domainsSemanticRangeAttrClassesUpperBoundAttrA->
				assertZ(domainsHiRangeDefineLimitA);
    *};

    //  PURPOSE:  To represent the class of attributes giving the limits
    //	  imposed on 'Domain' instances by the system being described.
    DomainsSystemLimitA
    {*
      isA->assert(DomainsSemanticRangeA);
      domainsSemanticRangeAttrClassesRangeA->
				assertZ(systemDomainSemanticRange);
      domainsSemanticRangeAttrClassesLowerBoundAttrA->
				assertZ(domainsLoSystemLimitA);
      domainsSemanticRangeAttrClassesUpperBoundAttrA->
				assertZ(domainsHiSystemLimitA);
    *};

    //  PURPOSE:  To represent the class of attributes giving the limits
    //	  imposed on 'Domain' instances by the absolute ability to detect
    //	  phenomena.
    DomainsDetectionLimitA
    {*
      isA->assert(DomainsSemanticRangeA);
      domainsSemanticRangeAttrClassesRangeA->
				assertZ(detectionDomainSemanticRange);
      domainsSemanticRangeAttrClassesLowerBoundAttrA->
				assertZ(domainsLoDetectionLimitA);
      domainsSemanticRangeAttrClassesUpperBoundAttrA->
				assertZ(domainsHiDetectionLimitA);
    *};

    //  PURPOSE:  To represent the class of attributes giving the limits
    //	  imposed on 'Domain' instances by the saturation inherent in the
    //	  phenomena being described.
    DomainsSaturationLimitA
    {*
      isA->assert(DomainsSemanticRangeA);
      domainsSemanticRangeAttrClassesRangeA->
				assertZ(saturationDomainSemanticRange);
      domainsSemanticRangeAttrClassesLowerBoundAttrA->
				assertZ(domainsLoSaturationLimitA);
      domainsSemanticRangeAttrClassesUpperBoundAttrA->
				assertZ(domainsHiSaturationLimitA);
    *};

    //  PURPOSE:  To represent the class of attributes giving the limits
    //	  imposed on 'Domain' instances by the reliability in the ability to
    //	  detect phenomena being described.
    DomainsReliabilityLimitA
    {*
      isA->assert(DomainsSemanticRangeA);
      domainsSemanticRangeAttrClassesRangeA->
				assertZ(reliabilityDomainSemanticRange);
      domainsSemanticRangeAttrClassesLowerBoundAttrA->
				assertZ(domainsLoReliabilityLimitA);
      domainsSemanticRangeAttrClassesUpperBoundAttrA->
				assertZ(domainsHiReliabilityLimitA);
    *};

    //  PURPOSE:  To represent the class of attributes giving the limits
    //	  of 'Domain' instances by the extremes actually observed.
    DomainsObservedLimitA
    {*
      isA->assert(DomainsSemanticRangeA);
      domainsSemanticRangeAttrClassesRangeA->
				assertZ(observedDomainSemanticRange);
      domainsSemanticRangeAttrClassesLowerBoundAttrA->
				assertZ(domainsLoObservedLimitA);
      domainsSemanticRangeAttrClassesUpperBoundAttrA->
				assertZ(domainsHiObservedLimitA);
    *};

      //  PURPOSE:  To map from instances of 'Domain' to the lowest value
      //    defined to be in the corresponding domain.
      domainsLoRangeDefineLimitA
      {*
	instanceOf->assertZ(DomainsLowerLimitA);
	instanceOf->assertZ(DomainsRangeDefinitionLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the highest value
      //    defined to be in the corresponding domain.
      domainsHiRangeDefineLimitA
      {*
	instanceOf->assertZ(DomainsUpperLimitA);
	instanceOf->assertZ(DomainsRangeDefinitionLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the lowest value
      //    imposed by the system being described.
      domainsLoSystemLimitA
      {*
	instanceOf->assertZ(DomainsLowerLimitA);
	instanceOf->assertZ(DomainsSystemLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the highest value
      //    imposed by the system being described.
      domainsHiSystemLimitA
      {*
	instanceOf->assertZ(DomainsUpperLimitA);
	instanceOf->assertZ(DomainsSystemLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the lowest value
      //    absolutely detectable for the phenomena being described.
      domainsLoDetectionLimitA
      {*
	instanceOf->assertZ(DomainsLowerLimitA);
	instanceOf->assertZ(DomainsDetectionLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the highest value
      //    absolutely detectable for the phenomena being described.
      domainsHiDetectionLimitA
      {*
	instanceOf->assertZ(DomainsUpperLimitA);
	instanceOf->assertZ(DomainsDetectionLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the lowest value
      //    at which the phenomena being described saturates.
      domainsLoSaturationLimitA
      {*
	instanceOf->assertZ(DomainsLowerLimitA);
	instanceOf->assertZ(DomainsSaturationLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the highest value
      //    at which the phenomena being described saturates.
      domainsHiSaturationLimitA
      {*
	instanceOf->assertZ(DomainsUpperLimitA);
	instanceOf->assertZ(DomainsSaturationLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the lowest value
      //    for which the phenomena being described can reliably be detected.
      domainsLoReliabilityLimitA
      {*
	instanceOf->assertZ(DomainsLowerLimitA);
	instanceOf->assertZ(DomainsReliabilityLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the highest value
      //    for which the phenomena being described can reliably be detected.
      domainsHiReliabilityLimitA
      {*
	instanceOf->assertZ(DomainsUpperLimitA);
	instanceOf->assertZ(DomainsReliabilityLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the lowest observed
      //    value.
      domainsLoObservedLimitA
      {*
	instanceOf->assertZ(DomainsLowerLimitA);
	instanceOf->assertZ(DomainsObservedLimitA);
      *};

      //  PURPOSE:  To map from instances of 'Domain' to the highest observed
      //    value.
      domainsHiObservedLimitA
      {*
	instanceOf->assertZ(DomainsUpperLimitA);
	instanceOf->assertZ(DomainsObservedLimitA);
      *};


//									//
//				Dimensionless				//
//									//

//  PURPOSE:  To represent the 'dimensionless' dimension.
dimensionless
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(unitless);
*};


//  PURPOSE:  To represent the class of units that have no dimensions.
DimensionlessUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(dimensionless);
*};


//  PURPOSE:  To represent the units for an annotated value with no dimensions.
unitless
{*
  instanceOf->assertZ(DimensionlessUnits);

  unitsDefaultDomainA->assert(limitlessDimensionlessDomain);
*};


//  PURPOSE:  To represent the default dimensionless domain.  It has no a priori limits.
limitlessDimensionlessDomain
{*
  instanceOf->assert(Domain);
  domainsDimensionA->assert(dimensionless);
  domainsUnitsA->assert(unitless);
*};

//  PURPOSE:  To represent the domain of dimensionless non-negative values.
nonNegativeDimensionlessDomain
{*
  instanceOf->assert(Domain);
  domainsDimensionA->assert(dimensionless);
  domainsUnitsA->assert(unitless);
  domainsLoRangeDefineLimitA->assert(0);
*};

//  PURPOSE:  To represent the domain of dimensionless numbers in [-1,+1]
negOneToPosOneDimensionlessDomain
{*
  instanceOf->assert(Domain);
  domainsDimensionA->assert(dimensionless);  
  domainsUnitsA->assert(unitless);
  domainsLoRangeDefineLimitA->assert(-1);
  domainsHiRangeDefineLimitA->assert(+1);
*};

//  PURPOSE:  To represent the domain of dimensionless numbers in [-pi,+pi]
negPiToPosPiRadiansDomain
{*
  instanceOf->assert(Domain);
  domainsDimensionA->assert(angle);  
  domainsUnitsA->assert(radians);
  domainsLoRangeDefineLimitA->assert(-(pi));
  domainsHiRangeDefineLimitA->assert(pi);
*};

//  PURPOSE:  To represent the domain of dimensionless numbers in [-pi/2,+pi/2]
negHalfPiToPosHalfPiRadiansDomain
{*
  instanceOf->assert(Domain);
  domainsDimensionA->assert(angle);  
  domainsUnitsA->assert(radians);
  domainsLoRangeDefineLimitA->assert(-(pi/2));
  domainsHiRangeDefineLimitA->assert(pi / 2);
*};

//  PURPOSE:  To represent the domain of dimensionless numbers in [0,+pi]
zeroToPiRadiansDomain
{*
  instanceOf->assert(Domain);
  domainsDimensionA->assert(angle);  
  domainsUnitsA->assert(radians);
  domainsLoRangeDefineLimitA->assert(0);
  domainsHiRangeDefineLimitA->assert(pi);
*};


//									//
//				Counts					//
//									//

//  PURPOSE:  To represent the default domain of countable things.
countDomain
{*
  instanceOf->assertZ(Domain);
  domainsDimensionA->assert(dimensionless);
  domainsUnitsA->assert(unitless);
  domainsLoRangeDefineLimitA->assert(0);
*};



//									//
//				distance:				//
//									//

//			    distance Dimension:				//
distance
{*
  instanceOf->assertZ(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(meters);
*};


//			    distance Units:				//
DistanceUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(distance);
*};

meters
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultMetersDomain);
*};


centimeters
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultCmDomain);
*};


millimeters
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultMmDomain);
*};


microns
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultMicronDomain);
*};


nanometers
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultNmDomain);
*};

 
angstroms
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultNmDomain);
  ^UnitsToUnitsConvertA[*meters*]->
	assert(^LinearUnitsToUnitsStruct[*nanometers,meters,(1\10000000000)*]);
*};


kilometers
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultKmDomain);
*};


lightYears
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultLightYearsDomain);
*};


parsecs
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultParsecsDomain);
  ^UnitsToUnitsConvertA[*meters*]->
	assert(^LinearUnitsToUnitsStruct[*parsecs,meters,3.24077649e-17*]);
*};


//  PURPOSE:  To serve as a dummy test case of an unconvertable unit to
//	the throwing of InsufficientUnitConversionInfoException.
feet
{*
  instanceOf->assertZ(DistanceUnits);

  unitsDefaultDomainA->assert(defaultFeetDomain);
*};


Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*meters,centimeters*],
		  ^LinearUnitsToUnitsStruct[*meters,centimeters,100*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*meters,millimeters*],
		  ^LinearUnitsToUnitsStruct[*meters,millimeters,1000*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*meters,microns*],
		  ^LinearUnitsToUnitsStruct[*meters,microns,1000000*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*meters,nanometers*],
		  ^LinearUnitsToUnitsStruct[*meters,nanometers,1000000000*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*meters,kilometers*],
		  ^LinearUnitsToUnitsStruct[*meters,kilometers,(1\1000)*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*meters,lightYears*],
		  ^LinearUnitsToUnitsStruct[*meters,lightYears,
					     9.46073047258E+15
					   *]
		);



//			    distance Domains:				//
SignedDistanceDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(distance);
*};


distanceDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);
*};


AbsoluteDistanceDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(distance);
*};

lengthDomain
{*
  instanceOf->assertZ(AbsoluteDistanceDomain);
*};



defaultMetersDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(meters);
*};


defaultCmDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(centimeters);
*};


defaultMmDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(millimeters);
*};


defaultMicronDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(microns);
*};


defaultNmDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(nanometers);
*};


defaultAngDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(angstroms);
*};


defaultKmDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(kilometers);
*};


defaultLightYearsDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(lightYears);
*};


defaultParsecsDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(parsecs);
*};

//  PURPOSE:  To serve as a dummy test case of an unconvertable unit to
//	the throwing of InsufficientUnitConversionInfoException.
defaultFeetDomain
{*
  instanceOf->assertZ(SignedDistanceDomain);

  domainsUnitsA->assert(feet);
*};


//									//
//				angle					//
//									//

//			    angle Dimension				//
angle
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(degrees);
*};


//				angle Units				//
AngleUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(angle);
*};

degrees
{*
  instanceOf->assertZ(AngleUnits);
  unitsDefaultDomainA->assert(degreesDomain);
*};

radians
{*
  instanceOf->assertZ(AngleUnits);
  unitsDefaultDomainA->assert(radiansDomain);
*};

Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*radians,degrees*],
		  ^LinearUnitsToUnitsStruct[*radians,degrees,180 / pi*]
		);

//				angle Domains:				//
SignedAngleDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(angle);
*};


radiansDomain
{*
  instanceOf->assertZ(SignedAngleDomain);
  domainsUnitsA->assert(radians);
*};

degreesDomain
{*
  instanceOf->assertZ(SignedAngleDomain);
  domainsUnitsA->assert(degrees);
*};

Dimension->registerUnaryOperatorResult(`sin`,angle,dimensionless);
Dimension->registerUnaryOperatorResult(`cos`,angle,dimensionless);
Dimension->registerUnaryOperatorResult(`tan`,angle,dimensionless);
Dimension->registerUnaryOperatorResult(`asin`,dimensionless,angle);
Dimension->registerUnaryOperatorResult(`acos`,dimensionless,angle);
Dimension->registerUnaryOperatorResult(`atan`,dimensionless,angle);


//									//
//				Time					//
//									//

//			    Time Dimension:				//
time
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(seconds);  
*};


//				Time Units:				//
TimeUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(time);
*};

seconds
{*
  instanceOf->assertZ(TimeUnits);

  unitsDefaultDomainA->assert(defaultSecondsDomain);
*};

msecs
{*
  instanceOf->assertZ(TimeUnits);

  unitsDefaultDomainA->assert(defaultMsecsDomain);
*};


microsecs
{*
   instanceOf->assertZ(TimeUnits);

   unitsDefaultDomainA->assert(defaultMicrosecsDomain);
*};


nanosecs
{*
  instanceOf->assertZ(TimeUnits);

  unitsDefaultDomainA->assert(defaultNanosecsDomain);
*};


minutes
{*
  instanceOf->assertZ(TimeUnits);

  unitsDefaultDomainA->assert(defaultMinutesDomain);
*};


hours
{*
  instanceOf->assertZ(TimeUnits);

  unitsDefaultDomainA->assert(defaultHoursDomain);
*};

Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*msecs,seconds*],
		  ^LinearUnitsToUnitsStruct[*msecs,seconds,1\1000*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*microsecs,seconds*],
		  ^LinearUnitsToUnitsStruct[*microsecs,seconds,1\1000000*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*nanosecs,seconds*],
		  ^LinearUnitsToUnitsStruct[*nanosecs,seconds,1\1000000000*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*minutes,seconds*],
		  ^LinearUnitsToUnitsStruct[*minutes,seconds,60*]
		);
Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*hours,seconds*],
		  ^LinearUnitsToUnitsStruct[*hours,seconds,3600*]
		);

//				Time Domains:				//

TimeDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(time);
*};

DurationDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(time);
*};


defaultSecondsDomain
{*
  instanceOf->assertZ(TimeDomain);

  domainsUnitsA->assert(seconds);
*};

defaultMsecsDomain
{*
  instanceOf->assertZ(TimeDomain);
  domainsUnitsA->assert(msecs);
*};

defaultMicrosecsDomain
{*
  instanceOf->assertZ(TimeDomain);

  domainsUnitsA->assert(microsecs);
*};

defaultNanosecsDomain
{*
  instanceOf->assertZ(TimeDomain);

  domainsUnitsA->assert(nanosecs);
*};


defaultMinutesDomain
{*
  instanceOf->assertZ(TimeDomain);

  domainsUnitsA->assert(minutes);
*};


defaultHoursDomain
{*
  instanceOf->assertZ(TimeDomain);

  domainsUnitsA->assert(hours);
*};



//									//
//				Mass					//
//									//

//			    Mass Dimension:				//

mass
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(grams);
*};


//				Mass Units:				//

MassUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(mass);
*};

grams
{*
  instanceOf->assertZ(MassUnits);

  unitsDefaultDomainA->assert(defaultGramsDomain);
*};

kilograms
{*
  instanceOf->assertZ(MassUnits);

  unitsDefaultDomainA->assert(defaultKilogramsDomain);
*};

Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*kilograms,grams*],
		  ^LinearUnitsToUnitsStruct[*kilograms,grams,1000*]
		);


//			Mass Domains:				//

SignedMassDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(mass);
*};


AbsoluteMassDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(distance);
*};


defaultGramsDomain
{*
  instanceOf->assertZ(SignedMassDomain);

  domainsUnitsA->assert(grams);
*};


defaultKilogramsDomain
{*
  instanceOf->assertZ(SignedMassDomain);

  domainsUnitsA->assert(kilograms);
*};


//									//
//				Charge					//
//									//

//			    Charge Dimension:				//

charge
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(coulombs);
*};


//			    Charge Units:				//

ChargeDomain
{*
  isA->assertZ(Domain);
*};

ChargeUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(charge);
*};

coulombs
{*
  instanceOf->assertZ(ChargeUnits);

  unitsDefaultDomainA->assert(defaultCoulombsDomain);
*};


//				Charge Domains:				//

defaultCoulombsDomain
{*
  instanceOf->assertZ(ChargeDomain);

  domainsUnitsA->assert(coulombs);
*};




//									//
//			    MagneticDimension?				//
//									//

//			MagneticDimension Dimension?			//

//			MagneticDimension Units?			//

//			MagneticDimension Domains?			//


//			Temperature Dimension:			//
temperature
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
  dimensionsPrimaryUnitsA->assert(kelvin);
*};

//			Temperature Units:			//
TemperatureUnits
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(temperature);
*};

kelvin
{*
  instanceOf->assertZ(TemperatureUnits);

  unitsDefaultDomainA->assert(defaultKelvinDomain);
*};

celsius
{*
  instanceOf->assertZ(TemperatureUnits);

  unitsDefaultDomainA->assert(defaultCelsiusDomain);
*};

Units->localGet(unitsClassesPairToConversionMapA)->
	map_put	( ^SingleDistinctPair[*kelvin,celsius*],
		  ^LinearUnitsToUnitsStruct[*kelvin,celsius,1,273.15*]
		);


//			Temperature Domains:			//
TemperatureDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(temperature);
*};

defaultKelvinDomain
{*
  instanceOf->assertZ(TemperatureDomain);

  domainsUnitsA->assert(kelvin);
*};

defaultCelsiusDomain
{*
  instanceOf->assertZ(TemperatureDomain);

  domainsUnitsA->assert(celsius);
*};


//									//
//				NuclearColor:				//
//									//

//			    NuclearColor Dimension:			//

nuclearColor
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
*};


//			    NuclearColor Units:				//

//			    NuclearColor Domains:			//




//									//
//				NuclearSpin:				//
//									//

nuclearSpin
{*
  instanceOf->assert(ConventionallyFundamentalDimension);
*};

//			    NuclearSpin Dimension:			//

//			    NuclearSpin Units:				//

//			    NuclearSpin Domains:			//


//									//
//				Area:					//
//									//

//			    Area Dimension:				//
area
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+2*]);
*};
Dimension->register(area);

//			    Area Units:					//

//			    Area Domains:				//


//									//
//				Volume:					//
//									//

//			    Volume Dimension:				//
volume
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+3*]);
*};
Dimension->register(volume);

//			    Volume Units:				//

//			    Volume Domains:				//

//									//
//			    inverseDistance:				//
//									//

//			inverseDistance Dimension:			//
inverseDistance
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,-1*]);
*};
Dimension->register(inverseDistance);

//			inverseDistance Units:				//

//			inverseDistance Domains:			//


InverseLinearPositionDomain
{*
  isA->assert(Domain);

  domainsDimensionA->subAssert(inverseDistance);
*};


InverseLinearPositionUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(inverseDistance);
*};

defaultWavenumbersDomain
{*
  instanceOf->assertZ(InverseLinearPositionDomain);

  domainsUnitsA->assertZ(wavenumbers);
*};

wavenumbers
{*
  instanceOf->assertZ(InverseLinearPositionUnit);

  unitsDefaultDomainA->assert(defaultWavenumbersDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*centimeters,-1*]);
*};


//			inverseDistance Attributes:		//

waveNumberA
{*
  instanceOf->assertZ(NumericEmpiricalEntityA);
*};




//									//
//				InverseTime:				//
//									//

//			    InverseTime Dimension:			//

//			    InverseTime Units:				//

//			    InverseTime Domains:			//

inverseTime
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-1*]);
*};
Dimension->register(inverseTime);

//	Inverse time
InverseTimeDomain
{*
  isA->assert(Domain);

  domainsDimensionA->subAssert(inverseTime);
*};


InverseTimeUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(inverseTime);
*};


defaultHertzDomain
{*
  instanceOf->assertZ(InverseTimeDomain);

  domainsUnitsA->assertZ(hertz);
*};


hertz
{*
  instanceOf->assertZ(InverseTimeUnit);

  unitsDefaultDomainA->assert(defaultHertzDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-1*]);
*};


defaultKhzDomain
{*
  instanceOf->assertZ(InverseTimeDomain);

  domainsUnitsA->assertZ(khz);
*};


khz
{*
  instanceOf->assertZ(InverseTimeUnit);

  unitsDefaultDomainA->assert(defaultKhzDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*msecs,-1*]);
*};


defaultMhzDomain
{*
  instanceOf->assertZ(InverseTimeDomain);

  domainsUnitsA->assertZ(mhz);
*};


mhz
{*
  instanceOf->assertZ(InverseTimeUnit);

  unitsDefaultDomainA->assert(defaultMhzDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*microsecs,-1*]);
*};


defaultGhzDomain
{*
  instanceOf->assertZ(InverseTimeDomain);

  domainsUnitsA->assertZ(ghz);
*};


ghz
{*
  instanceOf->assertZ(InverseTimeUnit);

  unitsDefaultDomainA->assert(defaultGhzDomain);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*nanosecs,-1*]);
*};



//									//
//			    DistanceOverTimeDimension:			//
//									//

//			DistanceOverTimeDimension Dimension:		//
velocity
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-1*]);
*};
Dimension->register(velocity);

//			DistanceOverTimeDimension Units:		//

//			DistanceOverTimeDimension Domains:		//


nonNumericEmpiricalEntityAS
{*
  isA->assertZ(EmpiricalEntityA);
*};

VelocityDimensionDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(velocity);
*};


defaultKmPerHourDomain
{*
  instanceOf->assert(VelocityDimensionDomain);

  domainsUnitsA->assert(`km/h`);
*};

`default m/s domain`
{*
  instanceOf->assert(VelocityDimensionDomain);

  domainsUnitsA->assert(`m/s`);
*};

VelocityUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(velocity);
*};

`m/s`
{*
  instanceOf->assertZ(VelocityUnit);

  unitsDefaultDomainA->assert(`default m/s domain`);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*meters,+1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-1*]);
*};


`km/h`
{*
  instanceOf->assertZ(VelocityUnit);

  unitsDefaultDomainA->assert(defaultKmPerHourDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*kilometers,+1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*hours,-1*]);
*};


//									//
//				Acceleration:				//
//									//

//			    Acceleration Dimension:			//
acceleration
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-2*]);
*};
Dimension->register(acceleration);


//			    Acceleration Units:				//

AccelerationUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(acceleration);
*};

`m/s^2`
{*
  instanceOf->assertZ(AccelerationUnit);

  unitsDefaultDomainA->assert(`default m/s^2 domain`);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*meters,+1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-2*]);
*};


//			    Acceleration Domains:			//
AccelerationDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(acceleration);
*};

`default m/s^2 domain`
{*
  instanceOf->assertZ(AccelerationDomain);
*};


//									//
//			    Volumetric Flow Rate:			//
//									//

//			Volumetric Flow Rate Dimension:			//
volumetricFlowRate
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+3*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-1*]);
*};
Dimension->register(volumetricFlowRate);


//			Volumetric Flow Rate Units:			//

VolumetricFlowRateUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(volumetricFlowRate);
*};

`m^3/s`
{*
  instanceOf->assertZ(VolumetricFlowRateUnit);

  unitsDefaultDomainA->assert(`default m^3/s domain`);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*meters,+3*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-1*]);
*};


//		    Volumetric Flow Rate Domains:			//
VolumetricFlowRateDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(volumetricFlowRate);
*};

`default m^3/s domain`
{*
  instanceOf->assertZ(VolumetricFlowRateDomain);
*};


//									//
//				Momentum:				//
//									//

//			    Momentum Dimension:				//
momentum
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*mass,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-1*]);
*};
Dimension->register(momentum);

//			    Momentum Units:				//

//			    Momentum Domains:				//


//									//
//			    ForceDimension:				//
//									//

//			    Force Dimension:				//
force
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*mass,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-2*]);
*};
Dimension->register(force);


//			    Force Units:				//

//			    Force Domains:				//


//	Force
ForceDomain
{*
  isA->assert(Domain);

  domainsDimensionA->subAssert(force);
*};

ForceUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(force);
*};


defaultNewtonsDomain
{*
  instanceOf->assertZ(ForceDomain);

  domainsUnitsA->assert(newtons);
*};


newtons
{*
  instanceOf->assertZ(ForceUnit);
  unitsDefaultDomainA->assert(defaultNewtonsDomain);

   compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*kilograms,1*]);
   compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*meters,1*]);
   compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-2*]);
*};



//									//
//				Energy:					//
//									//

//			    Energy Dimension:				//
energy
{*
  instanceOf->assert(ConventionallyCompositeDimension);

  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*mass,+1*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*distance,+2*]);
  compositeDimensionsBasicDimensionCompositionA->
	assertZ(^CompositeDimensionsBasicDimStruct[*time,-2*]);
  dimensionsPrimaryUnitsA->assert(joules);
*};
Dimension->register(energy);


//			    Energy Units:				//

//			    Energy Domains:				//


//	Energy
EnergyDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(energy);
*};

WorkDomain
{*
  isA->assertZ(Domain);

  domainsDimensionA->subAssert(energy);
*};

EnergyUnit
{*
  isA->assertZ(Units);

  unitsDimensionA->subAssertZ(energy);
*};

defaultJoulesDomain
{*
  instanceOf->assertZ(EnergyDomain);
  domainsUnitsA->assert(joules);
*};

joules
{*
  instanceOf->assertZ(EnergyUnit);

  unitsDefaultDomainA->assert(defaultJoulesDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*kilograms,1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*meters,2*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-2*]);

  ^UnitsToUnitsConvertA[*calories*]->
	assert(^LinearUnitsToUnitsStruct[*joules,calories,0.2388459*]);

   ^UnitsToUnitsConvertA[*electronVolts*]->
	assert(^LinearUnitsToUnitsStruct[*joules, electronVolts, 6.2415097e+18*]
	      );

   ^UnitsToUnitsConvertA[*kilotonsTNT*]->
	assert(^LinearUnitsToUnitsStruct[*joules, kilotonsTNT, 2.3900574e-13*]
	      );
*};


defaultDynesDomain
{*
  instanceOf->assertZ(EnergyDomain);

  domainsUnitsA->assert(dynes);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*grams,1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*centimeters,2*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-2*]);
*};


dynes
{*
  instanceOf->assertZ(EnergyUnit);
  unitsDefaultDomainA->assert(defaultDynesDomain);
*};


defaultCaloriesDomain
{*
  instanceOf->assertZ(EnergyDomain);

  domainsUnitsA->assert(calories);
*};

calories
{*
  instanceOf->assertZ(EnergyUnit);

  unitsDefaultDomainA->assert(defaultCaloriesDomain);
  ^UnitsToUnitsConvertA[*joules*]->
		assert(^LinearUnitsToUnitsStruct[*calories, joules, 4.1868*]);
*};


defaultElectronVoltsDomain
{*
  instanceOf->assertZ(EnergyDomain);

  domainsUnitsA->assert(electronVolts);
*};


electronVolts
{*
  instanceOf->assertZ(EnergyUnit);

  unitsDefaultDomainA->assert(defaultElectronVoltsDomain);

  ^UnitsToUnitsConvertA[*joules*]->
	assert(^LinearUnitsToUnitsStruct[*electronVolts, joules, 1.6021765e-19*]
	      );
*};


defaultKilowattHoursDomain
{*
  instanceOf->assertZ(EnergyDomain);

  domainsUnitsA->assert(kilowattHours);
*};


kilowattHours
{*
  instanceOf->assert(EnergyUnit);

  unitsDefaultDomainA->assert(defaultKilowattHoursDomain);

  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*kilograms,1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*meters,1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*kilometers,1*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*seconds,-3*]);
  compositeUnitsBasicUnitA->
	assertZ(^CompositeUnitsBasicUnitStruct[*hours,1*]);
*};


defaultKilotonsTNTDomain
{*
  instanceOf->assertZ(EnergyDomain);

  domainsUnitsA->assert(kilotonsTNT);
*};


kilotonsTNT
{*
  instanceOf->assert(EnergyUnit);

  unitsDefaultDomainA->assert(defaultKilotonsTNTDomain);
  ^UnitsToUnitsConvertA[*joules*]->
	assert(^LinearUnitsToUnitsStruct[*kilotonsTNT,joules,4.184e+12*]);
*};



Domain->register(limitlessDimensionlessDomain);
Domain->register(nonNegativeDimensionlessDomain);
Domain->register(negOneToPosOneDimensionlessDomain);
Domain->register(negPiToPosPiRadiansDomain);
Domain->register(negHalfPiToPosHalfPiRadiansDomain);
Domain->register(zeroToPiRadiansDomain);
Domain->register(countDomain);

Domain->registerOperationResult
		('+grp,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain
		);
Domain->registerOperationResult
		('-grp,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain
		);
Domain->registerOperationResult
		('+ext,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain
		);
Domain->registerOperationResult
		('-ext,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain,
		 limitlessDimensionlessDomain
		);

Domain->registerOperationResult
		('+grp,
		 nonNegativeDimensionlessDomain,
		 nonNegativeDimensionlessDomain,
		 nonNegativeDimensionlessDomain
		);
Domain->registerOperationResult
		('-grp,
		 nonNegativeDimensionlessDomain,
		 nonNegativeDimensionlessDomain,
		 limitlessDimensionlessDomain
		);
Domain->registerOperationResult
		('+ext,
		 nonNegativeDimensionlessDomain,
		 nonNegativeDimensionlessDomain,
		 nonNegativeDimensionlessDomain
		);
Domain->registerOperationResult
		('-ext,
		 nonNegativeDimensionlessDomain,
		 nonNegativeDimensionlessDomain,
		 limitlessDimensionlessDomain
		);
Domain->localGet(domainClassesOperationResultMapA);
/? --- end of file --- ?/

thisSE->parseFile("CoordinateAxisSystem.som8");
/?
 ?  This file section defines knowledge of coordinate and axis systems:
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/

CoordinateSystem
{*
  isA->assertZ(CulturalConvention);
*};

CoordinateSystemA
{*
  isA->assertZ(CulturalConventionA);
*};

AxisSystem
{*
  isA->assertZ(CulturalConvention);
*};

AxisSystemA
{*
  isA->assertZ(CulturalConventionA);
*};

axesDefaultCoordinateSystemA
{*
  instanceOf->assertZ(AxisSystemA);
*};
/? --- end of file --- ?/

thisSE->parseFile("SpaceTime.som8");
/?
 ?  This file section defines knowledge of space and time.
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/


Location
{*
  isA->assertZ(EmpiricalEntity);
*};
/? --- end of file --- ?/



thisSE->parseFile("ActionCapableAgent.som8");
/?
 ?  This file section defines knowledge of agents capable of doing scientific
 ?  actions:
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/

ActionCapableAgent
{*
  isA->assertZ(EmpiricalEntity);
*};

  Organism
  {*
    isA->assertZ(ActionCapableAgent);
  *};

    Human
    {*
      isA->assertZ(EmpiricalEntity);
    *};


  ProgrammableMachine
  {*
    isA->assertZ(ActionCapableAgent);
  *};


  Organization
  {*
    isA->assertZ(ActionCapableAgent);
  *};

    State_asInPoliticalSpatialOrganization
    {*
      isA->assertZ(Organization);
    *};

      Nation
      {*
        isA->assertZ(State_asInPoliticalSpatialOrganization);
      *};

    TeachingOrResearchInstitution
    {*
      isA->assertZ(Organization);
    *};

      University
      {*
        isA->assertZ(TeachingOrResearchInstitution);
      *};

    GovernmentAgency
    {*
      isA->assertZ(Organization);
    *};

    Company
    {*
      isA->assertZ(Organization);
    *};
/? --- end of file --- ?/


thisSE->parseFile("Reason.som8");
/?
 ?  This file section defines knowledge of scientific reasons.
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/


Reason
{*
  isA->assertZ(CulturalConvention);
*};
/? --- end of file --- ?/


thisSE->parseFile("Device.som8");
/?
 ?  This file section defines knowledge of scientific devices.
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/

Device
{*
  isA->assertZ(EmpiricalEntity);
*};
/? --- end of file --- ?/


thisSE->parseFile("Method.som8");
/?
 ?  This file section defines knowledge of scientific methods.
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/


Method
{*
  isA->assertZ(EmpiricalEntity);
*};
/? --- end of file --- ?/



thisSE->parseFile("AcademicReference.som8");
/?
 ?  This file section defines knowledge of scientific academic references.
 ?
 ?	Version 8b		2014 September 26	Joseph Phillips
 ?/



AcademicReference
{*
  isA->assertZ(EmpiricalEntity);
*};

  AcademicReferenceA
  {*
    isA->assertZ(EmpiricalEntityA);

    attrsDomainA->subAssertZ(AcademicReference);
  *};

    academicReferencesTitleA
    {*
      instanceOf->assertZ(AcademicReferenceA);
      attrsRangeA->assertZ(String);
    *};

    academicReferencesLocatorA
    {*
      instanceOf->assertZ(AcademicReferenceA);
      attrsRangeA->assertZ(String);
    *};

    academicReferencesTextA
    {*
      instanceOf->assertZ(AcademicReferenceA);
      attrsRangeA->assertZ(String);
    *};

  PrintedReference
  {*
    isA->assertZ(AcademicReference);

    ideasImplicitConstructorA->
      subAssert
	(^ImplicitConstructor
	 [* [ [academicReferencesTitleA,	String],
	      [academicReferencesLocatorA,	String],
	      [academicReferencesTextA,		String]
	    ]
	 *]
	);
  *};

  InternetReference
  {*
    isA->assertZ(AcademicReference);
  *};
/? --- end of file --- ?/


thisSE->parseFile("AnnotatedValue.som8");
/?
 ?  This file section defines knowledge of how to manipulate annotated values:
 ?
 ?	Version 8b		2013 February 16	Joseph Phillips
 ?/

//
//	This section defines annotated value metadata attributes:
//

//  PURPOSE:  To represent the class of attributes of annotated values
ValueMetadataA
{*
  isA->assertZ(CulturalConventionA);

  ideasImplicitConstructorA->subAssert
    (^ImplicitConstructor
	[*
	  [ [valueMetadataAttrsCategoryA,	Idea],
	    [valueMetadataAttrsValA, 		Idea],
	    [valueMetadataAttrsSpecificUseA,	Idea]
	  ]
	*]
    );
*};


MetadataRelatedFncsFamily
{*
  isA->assertZ(FncsFamily);
*};

symbolListCombine
{*
  instanceOf->assertZ(MetadataRelatedFncsFamily);
*};

matchSym
{*
  instanceOf->assertZ(MetadataRelatedFncsFamily);
*};


IntersectionValueMetadataA
{*
  isA->assertZ(ValueMetadataA);

  //  PURPOSE:  To compute and return a list of IntersectionValueMetadataA
  //	instances to be combined by intersection.
  sub symbolListCombine Idea
  [*
    [[@symList1,Idea],
     [@symList2,Idea]
    ],

    ^Do
    [*[
      //  I.  Applicability validity check:

      //  II.  Combine lists:
      ^VarDecl[* @retList,Idea,^^VectorList[**] *],
      ^VarDecl[* @commonSym,Idea *],
      ^VarDecl[* @iter,Iterator *],

      //  II.A.  Make local copy of '@symList2' so
      //  	 don't mess up the one passed to us:
      @symList2 := @symList2->dataStruct_copy(),

      //  II.B.  Each iteration gets another symbol from '@symList1', tries
      //  	 to find an appropriate match in '@symList2', and acts
      //	 accordingly:
      ^For
      [*
        @iter := @symList1->dataStruct_iter(),
	!@iter->iter_isAtEnd(),
	^Do
	[*[
	  ^VarDecl[* @sym,Idea *],

	  @sym	    := @iter->iter_value(),

	  //  II.B.1.  Look for intersection:
	  @commonSym := @this->matchSym(@sym,@symList2,true),

	  //  II.B.2.  Do nothing if no intersection,
	  //  	       otherwise add intersection:
	  ^If
	  [*
	    @commonSym =ref null,
	    null,
	    @retList->dataStruct_insertZ(@commonSym)
	  *]

	]*],
	@iter->iter_advance()
      *],

      //  III.  Finished:
      ^Return[* @retList *]
    ]*]
  *];

*};


UnionValueMetadataA
{*
  isA->assertZ(ValueMetadataA);

  //  PURPOSE:  To compute and return a list of UnionValueMetadataA
  //	instances to be combined by union.
  sub symbolListCombine Idea
  [*
    [[@symList1,Idea],
     [@symList2,Idea]
    ],

    ^Do
    [*[
      //  I.  Applicability validity check:

      //  II.  Combine lists:
      ^VarDecl[* @retList,Idea, ^^VectorList[**] *],
      ^VarDecl[* @commonSym,Idea *],
      ^VarDecl[* @iter,Iterator *],

      //  II.A.  Make local copy of '@symList2' so
      //  	 don't mess up the one passed to us:
      @symList2 := @symList2->dataStruct_copy(),

      //  II.B.  Each iteration gets another symbol from '@symList1', tries
      //  	 to find an appropriate match in '@symList2', and acts
      //	 accordingly:
      ^For
      [*
        @iter := @symList1->dataStruct_iter(),
	!@iter->iter_isAtEnd(),
	^Do
	[*[
	  ^VarDecl[* @sym,Idea *],

	  @sym	    := @iter->iter_value(),

	  //  II.B.1.  Look for intersection:
	  @commonSym := @this->matchSym(@sym,@symList2,true),

	  //  II.B.2.  Add either '@sym' if no match or '@commonSym' if match:
	  ^If
	  [*
	    @commonSym =ref null,
	    @retList->dataStruct_insertZ(@sym),
	    @retList->dataStruct_insertZ(@commonSym)
	  *]

	]*],
	@iter->iter_advance()
      *],

      //  II.C.  Add remaining items from '@symList2' to '@retList':
      ^For
      [*
        @iter := @symList2->dataStruct_iter(),
	!@iter->iter_isAtEnd(),
	^Do
	[*[
	  @retList->dataStruct_insertZ(@iter->iter_value())
	]*],
	@iter->iter_advance()
      *],

      //  III.  Finished:
      ^Return[* @retList *]
    ]*]
  *];

*};


GeneralizationValueMetadataA
{*
  isA->assertZ(ValueMetadataA);

  //  PURPOSE:  To compute and return a list of GeneralizationValueMetadataA
  //	instances to be combined by generalization.
  sub symbolListCombine Idea
  [*
    [[@symList1,Idea],
     [@symList2,Idea]
    ],

    ^Do
    [*[
      ^VarDecl[* @retList,Idea,^^VectorList[**] *],
      ^VarDecl[* @commonSym,Idea *],
      ^VarDecl[* @iter,Iterator *],

      @symList2 := @symList2->dataStruct_copy(),

      ^For
      [*
        @iter := @symList1->dataStruct_iter(),
	!@iter->iter_isAtEnd(),
	^Do
	[*[
	  ^VarDecl[* @sym,Idea *],

	  @sym := @iter->iter_value(),

	  ^If
	  [*
	    @this->matchSym(@sym,@retList,false) =ref null,
	    ^Do
	    [*[
	      @commonSym := @this->matchSym(@sym,@symList2,true),

	      ^If
	      [*
		@commonSym =ref null,
		@retList->dataStruct_insertZ(@sym),
		@retList->dataStruct_insertZ(@commonSym)
	      *]
	    ]*]
	  *]

	]*],
	@iter->iter_advance()
      *],

      ^Return[* @retList *]
    ]*]
  *];

*};


//
//	This subsection defines annotated value metadata attributes:
//

//  PURPOSE:  To represent the class of attributes of annotated value attributes
ValueMetadataAttrA
{*
  isA->assertZ(CulturalConventionA);
*};

valueMetadataAttrsCategoryA
{*
  instanceOf->assertZ(ValueMetadataAttrA);
*};

valueMetadataAttrsValA
{*
  instanceOf->assertZ(ValueMetadataAttrA);
*};

valueMetadataAttrsSpecificUseA
{*
  instanceOf->assertZ(ValueMetadataAttrA);
*};



//  PURPOSE:  To represent the class of coordinate
//  	      system-telling metadata attributes:
CoordinateSystemValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell the units of an annotated value:
//  	At its most informative it is meant to imply a particular coordinate
//	system, and a particular axis on that coordinate system.
valuesAxisA
{*
  instanceOf->assertZ(CoordinateSystemValueMetadataA);
*};





//  PURPOSE:  To represent the class of state-telling metadata states:
StateValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell the state of an annotated value.
//	Meant as a single-value encoding of both 'valuesLocationA' and
//	'valuesTimeA':
valuesStateA
{*
  instanceOf->assertZ(StateValueMetadataA);
*};

//  PURPOSE:  To tell the location of an annotated value:
valuesLocationA
{*
  instanceOf->assertZ(StateValueMetadataA);
*};




//  PURPOSE:  To represent the class of subject-telling metadata attributes:
SubjectValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell the subject of an annotated value:
valuesSubjectA
{*
  instanceOf->assertZ(SubjectValueMetadataA);
*};



//  PURPOSE:  To represent the class of attribute-telling metadata attributes:
AttributeValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell the attribute of an annotated value:
valuesAttributeA
{*
  instanceOf->assertZ(AttributeValueMetadataA);
*};



//  PURPOSE:  To represent the class of domain-telling metadata attributes:
DomainValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell the domain of an annotated value:
//	      Meant to imply a particular 'valuesUnitsA' value.
valuesDomainA
{*
  instanceOf->assertZ(DomainValueMetadataA);
*};

//  PURPOSE:  To tell the units of an annotated value:
//  	      Meant to be more open ended about the particular domain
valuesUnitsA
{*
  instanceOf->assertZ(DomainValueMetadataA);
*};



//  PURPOSE:  To tell the time of an annotated value:
valuesTimeA
{*
  instanceOf->assertZ(StateValueMetadataA);
*};


//  PURPOSE:  To map from instances of 'Units' to the 'Domain' instance to use
//	for an AnnotatedValue if only the units are given, but not the Domain.
unitsDefaultDomainA
{*
  instanceOf->assertZ(UnitsA);
*};





//  PURPOSE:  To represent the class of agent-telling metadata attributes:
AgentValueMetadataA
{*
  isA->assertZ(UnionValueMetadataA);
*};

//  PURPOSE:  To tell the agent of an annotated value:
//	      Meant to be a gross stand-in for 'valuesResearcherA',
valuesAgentA
{*
  instanceOf->assertZ(AgentValueMetadataA);
*};

//  PURPOSE:  To tell a human who actually did the work of an annotated value.
//	Meant to be more specific than 'valuesAgentA'.
valuesResearcherA
{*
  instanceOf->assertZ(AgentValueMetadataA);
*};

//  PURPOSE:  To map from a researcher to organization(s) with which the
//	researcher was affliated with when they did the research.  
researchersAffiliationA
{*
  instanceOf->assertZ(AgentValueMetadataA);
*};

//  PURPOSE:  To tell an entity that helped to pay for the value.
//  	      Meant to be more specific than 'valuesAgentA'.
valuesFunderA
{*
  instanceOf->assertZ(AgentValueMetadataA);
*};



//  PURPOSE:  To represent the class of reason-telling metadata attributes:
ReasonValueMetadataA
{*
  isA->assertZ(UnionValueMetadataA);
*};

//  PURPOSE:  To tell the reason annotated value was created:
valuesReasonA
{*
  instanceOf->assertZ(ReasonValueMetadataA);
*};



//  PURPOSE:  To represent the class of device-telling metadata attributes:
DeviceValueMetadataA
{*
  isA->assertZ(UnionValueMetadataA);
*};

//  PURPOSE:  To tell the device (e.g. specific software package or lab
//	      equipment) that helped to create the annotated value.
valuesDeviceA
{*
  instanceOf->assertZ(DeviceValueMetadataA);
*};



//  PURPOSE:  To represent the class of methodology-telling metadata attributes:
MethodologyValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell the method (e.g. algorithm or approach)
//	       that helped to create the annotated value.
valuesMethodA
{*
  instanceOf->assertZ(MethodologyValueMetadataA);
*};



//  PURPOSE:  To represent the class of reference-telling metadata attributes:
ReferenceValueMetadataA
{*
  isA->assertZ(ValueMetadataA);
*};

//  PURPOSE:  To tell a reference telling about the creation of the value.
//	      Meant to be the least specific member of
//	      'ReferenceValueMetadataA', and to be able to refer to any
//	      reference (broadly defined)
valuesReferenceA
{*
  instanceOf->assertZ(MethodologyValueMetadataA);
*};



//
//	This subsection defines knowledge on how to
//	manipulate annotated value metadata attributes:
//

Idea
{*

  //  PURPOSE:  To return an instance of AnnotatedValue in which the value
  //  		'@this' has been annotated by the metadata of '@argList'.
  sub parsedValueFactory AnnotatedValue
  [*
    [[@argList, VectorList]
    ],

    ^Do
    [*[

      //  I.  Applicability validity check:
      ^If
      [*
        @this->isInstanceOf(String),
	^Return[* @this *]
      *],

      //  II.  Create AnnotatedValue instance and annotate it with metadata:
      ^VarDecl[* @hasDomainBeenDeclared,Boolean, false *],
      ^VarDecl[* @thing,		Idea, @this *],
      ^VarDecl[* @type,			Idea, @thing->localGet(instanceOf) *],

      //  II.A.  Create instance:
      ^VarDecl[* @value, AnnotatedValue, ^^AnnotatedValue[**] *],
						// value to annotate & return

      //  II.B.  Annotate it with metadata:
      //  II.B.1.  Give it its value:
      @value->assert(annotatedValuesValueA,@thing),
      @value->assert(annotatedValuesTypeA, @type),

      ^VarDecl[* @datumIter, Iterator *],	// iterates thru metadata
      // @datumIter := @argList->dataStruct_iter(),

      //  II.B.2.  Annotate it with explicitly-stated metadata:
      ^For
      [*
	 @datumIter := @argList->dataStruct_iter(), // @datumIter->iter_reset(),

	!@datumIter->iter_isAtEnd(),

	^Do
	[*[
	  ^VarDecl[* @datum, Idea, @datumIter->iter_value() *],

	  ^If
	  [*
	    @datum->isInstanceOf(VectorList),

	    ^Do
	    [*[
	      ^VarDecl[* @metadataAttr, Attribute, @datum->list_firstItem() *],
	      @value->assertZ(@metadataAttr ,@datum->list_secondItem()),

	      ^If
	      [*
	        (@metadataAttr =ref valuesUnitsA)
		|| (@metadataAttr =ref valuesDomainA),
		@hasDomainBeenDeclared := true
	      *]

	    ]*]
	  *]

	]*],

	 @datumIter->iter_advance()
      *],

      //  II.B.3.  Annotate it with implicitly-stated metadata:
      ^VarDecl[* @specIter, Iterator *],	// Iterates over
      		 	    	     		// valueMetadataChoiceA values.
      ^VarDecl[* @spec, ValMetadataChoice *],	// Particular
      		 	     			// valueMetadataChoiceA value.
      ^VarDecl[* @specAttr, Attribute *],
      ^VarDecl[* @datumAttr,Idea *],
      ^VarDecl[* @attr2,    Idea *],

      @specIter := thisSE->prop_iter(valueMetadataChoiceA),

      ^For
      [*
	 @datumIter := @argList->dataStruct_iter(),//@datumIter->iter_reset(),

	!@datumIter->iter_isAtEnd(),

	^Do
	[*[
	  ^VarDecl[* @datum, Idea,  @datumIter->iter_value() *],

	  ^If
	  [*
	    //  Only handle individual Identities
	    //	(no lists or other datastructures)
	    !@datum->isInstanceOf(VectorList),

	    ^For
	    [*
	       @specIter->iter_reset(),

	      !@specIter->iter_isAtEnd(),

	      ^Do
	      [*[
	        @spec	  := @specIter->iter_value(),
		@specAttr := @spec->localGet(valMetadataChoicesAssertedAttrA),

		^If
		[*
		  //  See if @datum is in @spec's class AND if the
		  //  corresponding metadata attr of @value not yet defined
		  @datum->
		    isInstanceOf
			(@spec->localGet(valMetadataChoicesMatchingClassA))
		  &&
		  @value->localGet(@specAttr)->isNull(),


		  //  Assign metadatum(a)
		  ^Do
		  [*[
		    //  This one is straight-forward:
		    @value->assertZ(@specAttr,@datum),

		    ^If
	      	    [*
		      (@specAttr =ref valuesDomainA),
		      @hasDomainBeenDeclared := true
		    *],

		    //  Now see if should define 2nd metadatum:
		    @datumAttr :=
		      @spec->
			localGet
			  (valMetadataChoicesSecondaryMetadataMappingAttrA),

		    ^If
		    [*
		      //  An attr of the metadatum has been defined
		      @datumAttr !=ref null,

		      //  Assign 2nd metadatum:
		      ^Do
		      [*[
			^VarDecl[* @metaVal2, Idea, @datum->get(@datumAttr) *],

			^If
			[*
			  !@metaVal2->isNull(),
			  ^Do
			  [*[
			    ^VarDecl
			    [*
			      @metaAttr2,
			      Attribute,
			      @spec->
				  localGet
				    (valMetadataChoicesSecondaryMetadataAttrA)
			    *],

			    @value->assertZ(@metaAttr2,@metaVal2),

			    ^If
			    [*
			      (@metaAttr2 =ref valuesDomainA),
			      @hasDomainBeenDeclared := true
			    *]
			  ]*]
			*]
		      
		      ]*]
		    *],

		    ^Break[**]
		  ]*]
		*]
	      ]*],

	       @specIter->iter_advance()
	    *]
	  *]
	]*],

	 @datumIter->iter_advance()
      *],

      //  II.B.4.  Annotate with any still missing metadata:
      ^If
      [*
        !@hasDomainBeenDeclared  &&  @type->isSubclassOf(Number),
	@value->assert(valuesDomainA,limitlessDimensionlessDomain)
      *],

      //  II.C.  Check value:
      @value->checkAgainstDomainConstraints(),

      //  III.  Return value:
      ^Return[* @value *]
    ]*]
  *];
  //  parsedValueFactory

*};



//  PURPOSE:  To represent the class of attributes of 'ValMetadataChoice'.
ValMetadataChoiceA
{*
  isA->assertZ(ProgramObjectA);

  attrsDomainA->subAssertZ(ValMetadataChoice);
*};

//  PURPOSE:  To map from 'ValMetadataChoice' instances to the class that a
//	      particular metadatum should be in for the 'ValMetadataChoice'
//	      to be applicable.
valMetadataChoicesMatchingClassA
{*
  isA->assertZ(ValMetadataChoiceA);

  attrsRangeA->assertZ(Idea);
*};


//  PURPOSE:  To map from 'ValMetadataChoice' instances to an attribute where
//	      the value to annotate should have as its property that attribute
//	      and the matching metadatum.
valMetadataChoicesAssertedAttrA
{*
  isA->assertZ(ValMetadataChoiceA);

  attrsRangeA->assertZ(Attribute);
*};


//  PURPOSE:  To map from 'ValMetadataChoice' instances to an attribute that,
//	      if it is defined on the metadatum, tells of a secondary metadatum
//	      value that can also be defined.
valMetadataChoicesSecondaryMetadataMappingAttrA
{*
  isA->assertZ(ValMetadataChoiceA);

  attrsRangeA->assertZ(Idea);
*};


//  PURPOSE:  To map from 'ValMetadataChoice' instances to an attribute that,
//	      if 'valMetadataChoicesSecondaryMetadataValA' is defined on the
//	      metadatum, is the attribute of the property along with the
//	      secondary metadatum for the value to annotate.
valMetadataChoicesSecondaryMetadataAttrA
{*
  isA->assertZ(ValMetadataChoiceA);

  attrsRangeA->assertZ(Attribute);
*};


//  PURPOSE:  To tell how to annotate a value with a metadatum, if it
//	      matches.  Each instance means:
//	      "If the metadata value is inside class
//	         '@this->valMetadataChoicesMatchingClassA'
//	       then assign:
//	       	 valueToAnnotate->
//		    assert(@this->valMetadataChoicesAssertedAttrA,metadatum)
//	       Further, if a value for
//	       	 'metadatum->valMetadataChoicesSecondaryMetadataMappingAttrA'
//	       is given then assign:
//	       	 valueToAnnotate->
//		    assert(@this->valMetadataChoicesSecondaryMetadataAttrA,
//			   metadatum->
//			      valMetadataChoicesSecondaryMetadataMappingAttrA
//			  )
ValMetadataChoice
{*
  isA->assertZ(ProgramObject);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [[valMetadataChoicesMatchingClassA,		Idea],
	       [valMetadataChoicesAssertedAttrA,		Attribute],
	       [valMetadataChoicesSecondaryMetadataMappingAttrA,Attribute],
	       [valMetadataChoicesSecondaryMetadataAttrA,	Attribute]
	      ]
	    *]
	);
		 
*};



//  PURPOSE:  To state the list that tells, for unspecified metadata values,
//  	      which metadata attributes to associate them with.
thisSE
{*
  //  Unspecified metadata values are assigned according to the first
  //  matching valueMetadataChoiceA value.
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Attribute,valuesAttributeA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Domain,valuesDomainA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice
		[*Units,
		  valuesUnitsA,
		  unitsDefaultDomainA,
		  valuesDomainA
		*]
	       );
//valueMetadataChoiceA->
//	assertZ(^ValMetadataChoice[*CoordinateSystem,valuesCoordinateSystemA*]);
//valueMetadataChoiceA->
//	assertZ(^ValMetadataChoice
//		[*AxisSystem,
//		  valuesAxisSystemA,
//		  axesDefaultCoordinateSystemA,
//		  valuesCoordinateSystemA
//		*]
//	       );
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Location,valuesLocationA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Time,valuesTimeA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*ActionCapableAgent,	valuesResearcherA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*ActionCapableAgent,	valuesFunderA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Reason,valuesReasonA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Device,valuesDeviceA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Method,valuesMethodA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*PrintedReference,valuesReferenceA*]);
  valueMetadataChoiceA->
	assertZ(^ValMetadataChoice[*Idea,valuesSubjectA*]);
*};


//  PURPOSE:  To serve as a class of attributes that map from 'AnnotatedValue'
//	instances to 'MetadataCalculatingFncsFamily' that compute metadata
//	that result from a particular binary operator and a particular
//	metadata attribute.
AnnotatedValuesBinaryOpMetadataComboFncA
{*
  isA->assertZ(ProgramObjectA);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [*
	      [ [annotatedValuesBinaryOpMetadataComboFncOpA,	NumericOp],
	        [annotatedValuesBinaryOpMetadataComboFncAttrA,	ValueMetadataA]
	      ]
	    *]
	);
  ideasIsImmutableA->subAssert(true);
  ideasIsSingleDistinctA->subAssert(true);
*};

  //  PURPOSE:  To map from 'AnnotatedValuesBinaryOpMetadataComboFncA'
  //	instances to the 'NumericOp' for which they exist.
  annotatedValuesBinaryOpMetadataComboFncOpA
  {*
    instanceOf->assertZ(ProgramObjectA);
  *};

  //  PURPOSE:  To map from 'AnnotatedValuesBinaryOpMetadataComboFncA'
  //	instances to the 'ValueMetadataA' for which they exist.
  annotatedValuesBinaryOpMetadataComboFncAttrA
  {*
    instanceOf->assertZ(ProgramObjectA);
  *};


DeltaAdditiveOp
{*
//^OperatorsFncFamilyA[*valuesSubjectA*]->subAssertZ(deltaAddSubjMetadataCalc);
*};

GroupingAdditiveOp
{*
//^OperatorsFncFamilyA[*valuesSubjectA*]->subAssertZ(groupAddSubjMetadataCalc);
*};

AdditiveOp
{*
//^OperatorsFncFamilyA[*valuesAttributeA*]->assertZ(addAttrMetadataCalc);
*};

NumericOp
{*
//^OperatorsFncFamilyA[*valuesUnitsA*]->assertZ(numericUnitsMetadataCalc);
*};


//									//
//   Definition of exceptions related to AnnotatedValue instances.	//
//									//

//  PURPOSE:  To map from 'IncompatibleDomainsException' instances to the
//	the domains which is noted to be incompatible.
incompatibleDomainsExceptionDomainA
{*
  instanceOf->assertZ(ExceptionA);
*};

//  PURPOSE:  To represent exception for attempting to do a binary operation
//	on two AnnotatedValue instances with incompatible domains.
IncompatibleDomainsException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [incompatibleDomainsExceptionDomainA, Idea],
		     [incompatibleDomainsExceptionDomainA, Idea]
		   ]
		*]
	);

  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Compose sentence:
      ^VarDecl[* @phraseDS, VectorList *],
      ^VarDecl[* @domain0, Idea *],
      ^VarDecl[* @domain1, Idea *],
      ^VarDecl[* @iter,  Iterator *],
      ^VarDecl[* @sentence, NatLangDeclarativeSentence *],

      @phraseDS	:= ^^VectorList[**],
      @iter	:= @this->localProp_iter(incompatibleDomainsExceptionDomainA),
      @domain0	:= @iter->iter_value(),
      @iter->iter_advance(),
      @domain1	:= @iter->iter_value(),
      @phraseDS->dataStruct_insertZ
		(  ^^NatLangConjunctiveAndNounPhrase
		   [*@domain0,
		     @domain1,
		     subjectNatLangPhraseRole,
		     thirdPerson,
		     moreThanOnePlurality,
		     true
		   *]
		),
      @phraseDS->dataStruct_insertZ
		(  ^^NatLangRolePhrase
		   [*anInstance,
		     directObjectNatLangPhraseRole,
		     thirdPerson,
		     moreThanOnePlurality,
		     false,
		     incompatible,
		     ^^NatLangRolePhrase
		     [*Domain,
		       directObjectNatLangPhraseRole,
		       thirdPerson,
		       moreThanOnePlurality,
		       false
		     *]
		   *]
		),

      @sentence	:=
      		^^NatLangDeclarativeSentence
		  [*toBeAs,
		    inGeneralPresentNatLangTense,
		    affirmNatLangStatus,
		    @phraseDS
		  *],

      @this->assertZ(exceptionsValueA,@sentence),

      //  III.  Finished:
      ^Return[* @sentence *]
    ]*]
  *];

*};


//  PURPOSE:  To map from 'InsufficientUnitConversionInfoException' instances
//	to the units which is noted cannot be converted.
insufficientUnitConversionInfoExceptionUnitA
{*
  instanceOf->assertZ(ProgramObjectA);
*};

//  PURPOSE:  To represent exception for attempting to convert from one unit
//	to another when there is insufficient information.
InsufficientUnitConversionInfoException
{*
  isA->assertZ(SPDefinedException);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
		[* [ [insufficientUnitConversionInfoExceptionUnitA, Idea],
		     [insufficientUnitConversionInfoExceptionUnitA, Idea]
		   ]
		*]
	);

  sub computeValue Idea
  [*
    [],

    ^Do
    [*[
      ^VarDecl[* @innerPhraseDS, VectorList *],
      ^VarDecl[* @outerPhraseDS, VectorList *],
      ^VarDecl[* @unit0, Idea *],
      ^VarDecl[* @unit1, Idea *],
      ^VarDecl[* @iter,  Iterator *],

      //  The SpRun cannot convert from 'unit0' to 'unit1'.
      @innerPhraseDS	:= ^^VectorList[**],
      @outerPhraseDS	:= ^^VectorList[**],
      @iter		:= @this->
			     localProp_iter
				(insufficientUnitConversionInfoExceptionUnitA),
      @unit0		:= @iter->iter_value(),
      @iter->iter_advance(),
      @unit1		:= @iter->iter_value(),
      @innerPhraseDS->dataStruct_insertA
		( ^^NatLangRolePhrase
		  [*@unit0,
		    awayFromNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),
      @innerPhraseDS->dataStruct_insertA
		( ^^NatLangRolePhrase
		  [*@unit1,
		    towardNatLangPhraseRole,
		    thirdPerson,
		    singularPlurality,
		    false
		  *]
		),
      @outerPhraseDS->dataStruct_insertA
		( ^^NatLangDeclarativeSentence
		  [*toConvert,
		    timelessNatLangTense,
		    affirmNatLangStatus,
		    @innerPhraseDS,
		    directObjectNatLangPhraseRole
		  *]
		),
      @outerPhraseDS->dataStruct_insertA(theSpRunSubject),
      @this->assertZ
		( exceptionsValueA,
		  ^^NatLangDeclarativeSentence
		  [*toBeAbleTo,
		    inGeneralPresentNatLangTense,
		    negateNatLangStatus,
		    @outerPhraseDS
		  *]
		)
    ]*]
  *];
*};


//									//
//				AnnotatedValue				//
//									//

//  PURPOSE:  To map from 'AnnotatedValue' to the unannotated value.
annotatedValuesValueA
{*
  instanceOf->assertZ(AnnotatedValueA);
*};

//  PURPOSE:  To map from 'AnnotatedValue' to the type of the unannotated value:
//	either Rational, FloatingPt or Concept
annotatedValuesTypeA
{*
  instanceOf->assertZ(AnnotatedValueA);
*};

//  PURPOSE:  To map from 'AnnotatedValue' to the operator or function that
//	created it.
annotatedValuesOperatorA
{*
  instanceOf->assertZ(AnnotatedValueA);
*};

//  PURPOSE:  To map from 'AnnotatedValue' to a list of the operands that went
//	into creating that value.
annotatedValuesOperandListA
{*
  instanceOf->assertZ(AnnotatedValueA);
*};

MetadataCalculatingFncsFamily
{*
  isA->assertZ(FncsFamily);
*};

lhsSubjMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};

addDomainMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};

groupAddSubjMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};

addAttrMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};

numericUnitsMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};

divideUnitsMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};

numericRefMetadataCalc
{*
  instanceOf->assertZ(MetadataCalculatingFncsFamily);
*};


AnnotatedValue
{*

  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'+grp,valuesSubjectA*]->
	subAssertA(groupAddSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'-grp,valuesSubjectA*]->
	subAssertA(groupAddSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'+dGrp,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'-dGrp,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'+dExt,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'-dExt,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'+grp,valuesDomainA*]->
	subAssertA(addDomainMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'-grp,valuesDomainA*]->
	subAssertA(addDomainMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'+ext,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'+ext,valuesDomainA*]->
	subAssertA(addDomainMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'-ext,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'-ext,valuesDomainA*]->
	subAssertA(addDomainMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'**,valuesSubjectA*]->
	subAssertA(lhsSubjMetadataCalc);
  ^AnnotatedValuesBinaryOpMetadataComboFncA[*'**,valuesDomainA*]->
	subAssertA(exponentDomainMetadataCalc);


  //  PURPOSE:  To generate the error message of '@this' AnnotatedValue
  //  	having a value beyond semantic domain constraint '@attr'.  This message
  //	is either printed as a warning message if
  //	'@action' == 'warnErrorAction', or is thrown as an exception if
  //	'@action' == 'exceptionErrorAction'.  Returns '@this'.
  sub  takeErrorAction  AnnotatedValue
  [*
    [ [@attr,	Attribute],
      [@action,	ErrorAction]
    ],

    ^Do
    [*[
      ^VarDecl
      [*
	@error,
	Exception,
      	^^AnnotatedValueOutsideOfRangeException[* @this,@attr *]
      *],

      ^Test
      [*
        @action,

	[ [ '=ref, warnErrorAction,
	    stdErr->print("WARNING: ")->printLn(@error->toNatLang())
	  ],
	  [ '=ref, exceptionErrorAction,
	    ^Throw[* @error *]
	  ],
	  [ true,  true,
	    ^Throw[* @error *]
	  ]
	]
      *],

      //  III.  Finished: 
      ^Return[* @this *]
    ]*]
  *];
  //  takeErrorAction


  //  PURPOSE:  To see if the value ('@value') of '@this' AnnotatedValue
  //	instance violates the constraints of its Domain '@domain' mentioned
  //	as values for attribute '@spEnvA' of 'thisSE'.  If violations are
  //	found then the action as specified by '@action' will be done.
  sub  checkAgainstDomainConstraintsOfSpecificSeverity  AnnotatedValue
  [*
    [ [@spEnvA,	Attribute],
      [@action,	ErrorAction],
      [@number,	Number],
      [@domain,	Domain]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Check for violations:
      //  II.A.  Each iteration checks for violations of another semantic
      //  	 constraint class mentioned as a value of attribute '@spEnvA':
      ^VarDecl[* @iter, Iterator *],

      ^For
      [*
	//  II.A.1.  Initialize iterator:
	@iter	:= thisSE->localProp_iter(@spEnvA),

	//  II.A.2.  Continue while not at end:
       !@iter->iter_isAtEnd(),

	//  II.A.3.  Check for violations of current class:
	^Do
	[*[
	  //  II.A.3.a.  Get '@semanticClass':
	  ^VarDecl[* @semanticClass, Idea, @iter->iter_value() *],

	  //  II.A.3.b.  Get attributes of semantic class:
	  ^VarDecl
	  [*
	    @loBoundAttr,
	    Attribute,
	    @semanticClass->get(domainsSemanticRangeAttrClassesLowerBoundAttrA)
	  *],
	  ^VarDecl
	  [*
	    @hiBoundAttr,
	    Attribute,
	    @semanticClass->get(domainsSemanticRangeAttrClassesUpperBoundAttrA)
	  *],

	  //  II.A.3.c.  Get corresponding lower and upper numeric boundaries
	  //		 from 'domain':
	  ^VarDecl[* @loBound, Number, @domain->localGet(@loBoundAttr) *],
	  ^VarDecl[* @hiBound, Number, @domain->localGet(@hiBoundAttr) *],

	  //  II.A.3.d.  Complain if 'number' is not in ['@loBound','@hiBound']:
	  ^If
	  [*
	    (@loBound->isNumber() && (@number < @loBound) ),
	    @this->takeErrorAction(@loBoundAttr,@action),
	    ^If
	    [*
	      (@hiBound->isNumber() && (@number > @hiBound) ),
	      @this->takeErrorAction(@hiBoundAttr,@action)
	    *]
	  *]
	]*],

	//  II.A.4.  Advance to next semantic class:
	@iter->iter_advance()
      *],

      //  III.  Finished:
      ^Return[* @this *]
    ]*]
  *];
  //  checkAgainstDomainConstraintsOfSpecificSeverity


  //  PURPOSE:  To see if '@this' AnnotatedValue instance violates any
  //	the constraints of its Domain instance.  Returns '@this'.
  sub checkAgainstDomainConstraints Idea
  [*
    [],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Check '@this' against domain constraints:
      //  II.A.  Get preparatory information:
      ^VarDecl[* @thisAV, AnnotatedValue *],
      @thisAV := @this,
      ^VarDecl[* @number, Number, @thisAV->localGet(annotatedValuesValueA) *],
      ^VarDecl[* @domain, Domain, @thisAV->localGet(valuesDomainA) *],

      //  II.B.  Do the checks by severity:
      @this->checkAgainstDomainConstraintsOfSpecificSeverity
		(spEnvsWarningGeneratingSemanticDomainClassA,
		 warnErrorAction,
		 @number,
		 @domain
		),
      @this->checkAgainstDomainConstraintsOfSpecificSeverity
		(spEnvsErrorGeneratingSemanticDomainClassA,
		 exceptionErrorAction,
		 @number,
		 @domain
		),

      //  III.  Finished:
      ^Return[* @this *]
    ]*]
  *];
  //  checkAgainstDomainConstraints

  sub findMetadataFncFamily MetadataCalculatingFncsFamily
  [*
    [ [@op,Operator],
      [@metadataAttr,ValueMetadataA]
    ],

    ^Do
    [*[

      ^If
      [* @op->isInstanceOf(DeltaAdditiveOp),
        ^If
	[* @metadataAttr =ref valuesSubjectA,
	 ^Return[* lhsSubjMetadataCalc *]
	*]
      *],

      ^If
      [* @op->isInstanceOf(GroupingAdditiveOp),
        ^If
	[* @metadataAttr =ref valuesSubjectA,
	  ^Return[* groupAddSubjMetadataCalc *]
	*]
      *],

      ^If
      [* @op->isInstanceOf(AdditiveOp),
        ^If
	[* @metadataAttr =ref valuesAttributeA,
	   ^Return[* addAttrMetadataCalc *]
	*]
      *],

      ^If
      [* @op->isInstanceOf(DividingOp),
      	 ^If
	 [* @metadataAttr =ref valuesUnitsA,
	    ^Return[* divideUnitsMetadataCalc *]
	 *]
      *],

      ^If
      [* @op->isInstanceOf(NumericOp),
        ^If
	[* @metadataAttr =ref valuesUnitsA,
	   ^Return[* numericUnitsMetadataCalc *]
	*]
      *],

      ^If
      [* @op->isInstanceOf(NumericOp),
        ^If
	[* @metadataAttr =ref valuesReferenceA,
	   ^Return[* numericRefMetadataCalc *]
	*]
      *],

      ^Return[* null *]
    ]*]
  *];

  
  //  PURPOSE:  To be a metadata calculating method that computes the subject
  //	of operator '@op' by returning the subject of the first operand,
  //	'@lhsSubj'.  Ignores '@op', '@attr' and '@rhsSubj'.
  sub lhsSubjMetadataCalc Idea
  [*
    [ [@op,		NumericOp],
      [@attr,		ValueMetadataA],
      [@lhsSubj,	Idea],
      [@rhsSubj,	Idea]
    ],

    ^Do
    [*[
      ^Return[* @lhsSubj *]
    ]*]
  *];


  //  PURPOSE:  To compute the subject that results when one AnnotatedValue
  //	instance is group-added to another.
  sub groupAddSubjMetadataCalc Idea
  [*
    [ [@op,		NumericOp],
      [@attr,		ValueMetadataA],
      [@lhsSubj,	Idea],
      [@rhsSubj,	Idea]
    ],

    ^Do
    [*[
      //  Handle case where already have same subject:
      ^If
      [*
        @lhsSubj =ref @rhsSubj,
	^Return[* @lhsSubj *]
      *],

      //  Handle case where one is a class and it already subsumes the other:
      ^If
      [*
        @lhsSubj->isInstanceOf(@rhsSubj) || @lhsSubj->isSubclassOf(@rhsSubj),
	^Return[* @rhsSubj *]
      *],
      ^If
      [*
        @rhsSubj->isInstanceOf(@lhsSubj) || @rhsSubj->isSubclassOf(@lhsSubj),
	^Return[* @lhsSubj *]
      *],

      //  Have to look for a class that subsumes both:
      //  (1) Turn both into classes (if not already):
      ^If
      [*
        (@lhsSubj->localGet(isA) =ref null) &&
	(@lhsSubj->localGet(hasSubclass) =ref null),
	@lhsSubj := @lhsSubj->localGet(instanceOf)
      *],
      ^If
      [*
        (@rhsSubj->localGet(isA) =ref null) &&
	(@rhsSubj->localGet(hasSubclass) =ref null),
	@rhsSubj := @rhsSubj->localGet(instanceOf)
      *],

      //  (2) Handle when have same class:
      ^If[*  @lhsSubj =ref @rhsSubj, ^Return[*@lhsSubj*]  *],

      //  (3) Search for subsuming set:
      ^VarDecl[* @iter, Iterator *],
      ^For
      [*
        @iter := @lhsSubj->prop_iter(isA),
       !@iter->iter_isAtEnd(),
        ^If
	[*
	  @rhsSubj->isSubclassOf(@iter->iter_value()),
	  ^Return[* @iter->iter_value() *]
	*],
	@iter->iter_advance()
      *],

      //  (4) Give up:
      ^Return[* Idea *]
    ]*]
  *];
  //  groupAddSubjMetadataCalc


  //  PURPOSE:  To compute the domain that results when one AnnotatedValue
  //	instance is added to another.
  sub addDomainMetadataCalc Idea
  [*
    [ [@op,		NumericOp],
      [@attr,		ValueMetadataA],
      [@lhsDomain,	Idea],
      [@rhsDomain,	Idea]
    ],

    ^Do
    [*[
      //  I.  Application validity check:
      //  I.A.  Check dimension compatibility:
      ^VarDecl[*@lhsDimension, Dimension, @lhsDomain->get(domainsDimensionA)*],
      ^VarDecl[*@rhsDimension, Dimension, @rhsDomain->get(domainsDimensionA)*],

      ^If
      [*
	@lhsDimension !=ref @rhsDimension,
	^Throw[* ^^IncompatibleDomainsException[*@lhsDomain,@rhsDomain*] *]
      *],

      //  I.B.  Check units:
      ^VarDecl[* @lhsUnits, Units, @lhsDomain->get(domainsUnitsA) *],

      ^If
      [*
        @lhsUnits->isNull(),
	^Throw[* ^^MissingValueException[* @lhsDomain, domainsUnitsA *] *]
      *],

      ^VarDecl[* @rhsUnits, Units, @rhsDomain->get(domainsUnitsA) *],

      ^If
      [*
        @rhsUnits->isNull(),
	^Throw[* ^^MissingValueException[* @rhsDomain, domainsUnitsA *] *]
      *],

      //  II.  Compute resulting domain:
      //  II.A.  Handle when units are the same:
      ^If
      [*
        @lhsUnits =ref @rhsUnits,
	^Return[* @lhsDomain *]
      *],

      //  II.B.  Handle general case of different units:
      ^VarDecl
      [*
	@operandList,
	List,
	@this->localGet(annotatedValuesOperandListA)
      *],
      ^VarDecl
      [*
	@rhsNum,
	Number,
	@this->numberConvertedToRequestedUnits
		(@operandList->list_secondItem(),
		 @rhsUnits,
		 @lhsUnits,
		 @lhsDimension
		)
      *],

      @operandList->vList_didPut(1,@rhsNum),

      //  III.  Finished:
      ^Return[* @lhsDomain *]
    ]*]
  *];
  //  addDomainMetadataCalc


  //  PURPOSE:  To 
  sub addAttrMetadataCalc Idea
  [*
    [[@lhsAttr,	Idea],
     [@rhsAttr,	Idea]
    ],

    ^Do
    [*[
      ^If
      [*
        @lhsAttr =ref @rhsAttr,
	@lhsAttr,
	null
      *]
    ]*]
  *];
  //  addAttrMetadataCalc


  //  PURPOSE:  To compute and return the 'Domain' instance that results when
  //	'@op' (assumed to be exponentiation: **) is applied to 'this'
  //	'AnnotatedValue' instance which results from raising a base number
  //	whose 'Domain' instance is '@lhsDomain' to a power whose 'Domain'
  //	instance is '@rhsDomain'.  Ignores '@attr'.
  sub exponentDomainMetadataCalc Idea
  [*
    [ [@op,		NumericOp],
      [@attr,		ValueMetadataA],
      [@lhsDomain,	Idea],
      [@rhsDomain,	Idea]
    ],

    ^Do
    [*[
      //  I.  Application validity check:
      ^If
      [*
	@lhsDomain->isNull(),
	^Throw
	[*
	  ^^ArgumentInWrongDimensionException[* `**`,dimensionless,null *]
	*]
      *],

      //  II.  Compute resulting domain:
      //  II.A.  Get and check dimension of 'lhsDomain':
      //  II.A.1.  Get dimension:
      ^VarDecl[* @lhsDim, Dimension, @lhsDomain->get(domainsDimensionA) *],

      //  II.A.2.  If '@lhsDim' is 'dimensionless' then have same domain:
      ^If[* (@lhsDim =ref dimensionless), ^Return[* @lhsDomain *] *],

      //  II.A.3.  Check '@lhsDim' in a manner that depends whether or not
      //  	   it is fundamental:
      ^VarDecl[* @thisVal, AnnotatedValue *],
      @thisVal := @this,

      ^VarDecl[*@opList,List,@thisVal->localGet(annotatedValuesOperandListA)*],
      ^VarDecl[*@newDomain, Domain, ^^Domain[**] *],

      ^If
      [*
	@lhsDim->isInstanceOf(ConventionallyFundamentalDimension),

	^Do
	[*[
	  //  II.A.3.a.  'lhsDimension' is itself fundamental (power == 1).
	  //		  It suffices to see if 'rhs' is an integer:
	  ^VarDecl[* @power, Number, @opList->list_secondItem() *],

	  ^If
	  [*
	    !@power->isRationalInteger(),
	    ^Throw
	    [*
	      ^^ExpectedDimensionRaisedToIntegerPowerException
	      [*
		@lhsDim,
		@opList->list_firstItem(),
		@power
	      *]
	    *]
	  *],

	  @newDomain->
		assertZ
		    (domainsDimensionA,
		     Dimension->getDimensionGivenDefn
			(^^VectorList[**]->
			    dataStruct_insert
				(^^CompositeDimensionsBasicDimStruct
				    [*
				      @lhsDim,
				      @power
				    *]
				)
			)
		    ),
	  @newDomain->
		assertZ
		    (domainsUnitsA,
		     Units->getUnitsGivenDefn
			(^^VectorList[**]->
			    dataStruct_insert
				(^^CompositeUnitsBasicUnitStruct
				 [*
				   @lhsDomain->localGet(domainsUnitsA),
				   @power
				 *]
				)
			)
		    ),
	  ^Return[*@newDomain*]
	]*],

	^Do
	[*[
	]*]
      *],

      //  III.  Finished:
      ^Return[* @lhsDomain *]
    ]*]
  *];
  //  exponentDomainMetadataCalc

  sub numericUnitsMetadataCalc Idea
  [*
    [[@lhsUnits, Idea],
     [@rhsUnits, Idea]
    ],

    ^Do
    [*[
      ^If
      [*
        @lhsUnits =ref @rhsUnits,
	@lhsUnits,
	null
      *]
    ]*]
  *];


  //  PURPOSE:  To compute the units that result when one AnnotatedValue
  //	instance is divided by another.
  sub divideUnitsMetadataCalc Idea
  [*
    [ [@lhsUnits, Idea],
      [@rhsUnits, Idea]
    ],

    ^Do
    [*[
      ^If
      [*
        @lhsUnits =ref @rhsUnits,
	^Return[* unitless *],
	^If
	[* @rhsUnits =ref unitless,
	   ^Return[* @lhsUnits *],
	   ^Return[* null *]
	*]
      *]
    ]*]
  *];
  //  divideUnitsMetadataCalc


  //  PURPOSE:  To return either an individual reference or a bag of references
  //	that combine the reference(s) of '@lhsRef' with those in '@rhsRef'.
  sub numericRefMetadataCalc Idea
  [*
    [ [@lhsRef, Idea],
      [@rhsRef, Idea]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Combine reference(s) of '@lhsRef' with those in '@rhsRef':
      //  II.A.  If they're the same return either one:
      ^If[* (@lhsRef =ref @rhsRef), ^Return[* @lhsRef *]  *],

      //  II.B.  Determine what to do depending on if have bags:
      ^VarDecl[* @lhsIsBag, Boolean, @lhsRef->isInstanceOf(Bag) *],
      ^VarDecl[* @rhsIsBag, Boolean, @rhsRef->isInstanceOf(Bag) *],
      ^VarDecl[* @toReturn, Bag *],

      //  II.B.1.  Handle when neither are bags (we already know they differ):
      ^If
      [*
        (!@lhsIsBag && !@rhsIsBag),

        ^Do
	[*[
	  @toReturn := ^^Bag[**],
	  @toReturn->dataStruct_insert(@lhsRef),
	  @toReturn->dataStruct_insert(@rhsRef),
	  ^Return[* @toReturn *]
	]*]
      *],

      //  II.B.2.  Handle when '@rhsRef' is a bag but '@lhsRef' is not:
      ^If
      [*
        (!@lhsIsBag && @rhsIsBag),

	^Do
	[*[
	  ^If
	  [*
	    @rhsRef->dataStruct_doesHave(@lhsRef),
	    ^Return[* @rhsRef *]
	  *],

	  @toReturn := @rhsRef->dataStruct_copy(),
	  @toReturn->dataStruct_insert(@lhsRef),
	  ^Return[* @toReturn *]
	]*]
      *],

      //  II.B.3.  Handle when '@lhsRef' is a bag but '@rhsRef' is not:
      ^If
      [*
        (@lhsIsBag && !@rhsIsBag),

	^Do
	[*[
	  ^If
	  [*
	    @lhsRef->dataStruct_doesHave(@rhsRef),
	    ^Return[* @lhsRef *]
	  *],

	  @toReturn := @lhsRef->dataStruct_copy(),
	  @toReturn->dataStruct_insert(@rhsRef),
	  ^Return[* @toReturn *]
	]*]
      *],

      //  II.B.4.  Handle when both are bags:
      ^VarDecl[* @rhsIter, Iterator *],
      @toReturn := @lhsRef->dataStruct_copy(),

      ^For
      [*
	@rhsIter := @rhsRef->dataStruct_iter(),

       !@rhsIter->iter_isAtEnd(),

	@toReturn->
		dataStruct_didInsertBecauseNotPresent(@rhsIter->iter_value()),

	@rhsIter->iter_advance()
      *],

      //  III.  Finished:
      ^Return[* @toReturn *]
    ]*]
  *];
  //  End numericRefMetadataCalc


  //  PURPOSE:  To return a Number instance that is equivalent to
  //	'@originalNumber' converted from units '@originalUnits' to
  //	'@requestedUnits'.  '@dimension' tells the dimension of both units.
  sub numberConvertedToRequestedUnits Number
  [*
    [ [@originalNumber,	Number],
      [@originalUnits,	Idea],
      [@requestedUnits,	Idea],
      [@dimension,	Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check:

      //  II.  Try to convert between '@originalUnits' and '@requestedUnits':
      //  II.A.  Handle simplest case: where the units are equal:
      ^If
      [*
	@originalUnits =ref @requestedUnits,
	^Return[* @originalNumber *]
      *],

      //  II.B.  Handle case where knowledge exists to convert directly between
      //	 '@originalUnits' to '@requestedUnits':
      //  II.B.1.  Try to convert from '@originalUnits' to '@requestedUnits':
      ^VarDecl
      [*
	@conversionMap,
	Map,
	Units->localGet(unitsClassesPairToConversionMapA)
      *],
      ^VarDecl
      [*
	@conversion0,
	UnitsToUnitsStruct,
	@conversionMap->
		map_get(^^SingleDistinctPair
			[*
			  @originalUnits,
			  @requestedUnits
			*]
		       )
      *],

      ^If
      [*
       !@conversion0->isNull(),
	^Return[* @conversion0->forwardConvert(@originalNumber) *]
      *],

      //  II.B.2.  Try to convert from '@requestedUnits' to '@originalUnits':
      @conversion0	:= @conversionMap->
				map_get(^^SingleDistinctPair
					[*
					  @requestedUnits,
					  @originalUnits
					*]
				       ),
      ^If
      [*
       !@conversion0->isNull(),
	^Return[* @conversion0->reverseConvert(@originalNumber) *]
      *],


      //  II.C.  Handle cases where can convert between '@originalUnits' to
      //	 '@requestedUnits' with '@primaryUnits' as an intermediary:
      //  II.C.1.  Try to find a conversion between '@originalUnits' and
      //  	   '@primaryUnits':
      ^VarDecl[* @conversion1,		UnitsToUnitsStruct *],
      ^VarDecl[* @isConversion0Forward,	Boolean *],
      ^VarDecl[* @isConversion1Forward,	Boolean *],
      ^VarDecl
      [*
	@primaryUnits,
	Idea,
	@dimension->localGet(dimensionsPrimaryUnitsA)
      *],

      @conversion0		:= @conversionMap->
				    map_get
					(^^SingleDistinctPair
					 [*
					   @originalUnits,
					   @primaryUnits
					 *]
				        ),
      @isConversion0Forward	:= true,
      ^If
      [*
	@conversion0->isNull(),
	^Do
	[*[
	  @conversion0	:= Units->localGet(unitsClassesPairToConversionMapA)
				->map_get(^^SingleDistinctPair
					  [*
					    @primaryUnits,
					    @originalUnits
					  *]
					 ),
	  @isConversion0Forward
			:= false
	]*]
      *],

      ^If
      [*
	@conversion0->isNull(),
	^Do
	[*[
	  ^VarDecl[* @num, Number *],

	  @num := 
	    @this->numberConvertedToRequestedCompositeUnits
		(@originalNumber,
		 @originalUnits,
		 @requestedUnits,
		 @dimension
		),

	  ^Return[* @num *]
	]*]
      *],

      //  II.C.2.  Try to find a conversion between '@primaryUnits' and
      //  	   '@requestedUnits':
      @conversion1	:= @conversionMap
				->map_get(^^SingleDistinctPair
					  [*
					    @primaryUnits,
					    @requestedUnits
					  *]
					 ),
      @isConversion1Forward
			:= true,
      ^If
      [*
	@conversion1->isNull(),
	^Do
	[*[
	  @conversion1	:= Units->localGet(unitsClassesPairToConversionMapA)
				->map_get(^^SingleDistinctPair
					  [*
					    @requestedUnits,
					    @primaryUnits
					  *]
					 ),
	  @isConversion1Forward
			:= false
	]*]
      *],

      ^If
      [*
	@conversion1->isNull(),
	^Return
	[*
	  @this->numberConvertedToRequestedCompositeUnits
		(@originalNumber,
		 @originalUnits,
		 @requestedUnits,
		 @dimension
		)
	*]
      *],

      //  II.C.3.  If get here then have the information for a conversion:
      //  II.C.3.a.  Make a default "conversion" from and to '@originalUnits':
      ^VarDecl
      [*
	@chunkedConversion,
	UnitsToUnitsStruct,
	^^LinearUnitsToUnitsStruct
	[*
	  @originalUnits,
	  @originalUnits,
	  1,
	  0
	*]
      *],

      //  II.C.3.b.  Revise '@chunkedConversion' to do '@conversion0':
      @chunkedConversion
	:=  ^If
	    [*
	      @isConversion0Forward,
	      @conversion0->createForwardConverter(@chunkedConversion),
	      @conversion0->createReverseConverter(@chunkedConversion)
	    *],

      //  II.C.3.c.  Revise '@chunkedConversion' to do '@conversion1' too:
      @chunkedConversion
	:=  ^If
	    [*
	      @isConversion1Forward,
	      @conversion1->createForwardConverter(@chunkedConversion),
	      @conversion1->createReverseConverter(@chunkedConversion)
	    *],

      //  II.C.3.d.  Chunk '@chunkedConversion':
      @conversionMap->map_put
			( ^^SingleDistinctPair
			  [*
			    @originalUnits,
			    @requestedUnits
			  *],
			  @chunkedConversion
			),

      //  III.  Return converted number:
      ^Return[* @chunkedConversion->forwardConvert(@originalNumber) *]
    ]*]
  *];
  //  End numberConvertedToRequestedUnits


  //  PURPOSE:  To return a Number instance that is equivalent to
  //	'@originalNumber' converted from units '@originalUnits' to
  //	'@requestedUnits'.  '@dimension' tells the dimension of both units.
  //	Unlike 'numberConvertedToRequestedUnits()', this method assumes
  //	(and actually checks) that '@dimension' is in
  //	'ConventionallyCompositeDimension'.
  sub numberConvertedToRequestedCompositeUnits Number
  [*
    [ [@originalNumber,	Number],
      [@originalUnits,	Idea],
      [@requestedUnits,	Idea],
      [@dimension,	Dimension]
    ],

    ^Do
    [*[
      //  I.  Application validity check:
      ^If
      [*
       !@dimension->isInstanceOf(ConventionallyCompositeDimension),
	^Throw
	[*
	  ^^InsufficientUnitConversionInfoException
	  [*
	    @originalUnits,
	    @requestedUnits
	  *]
	*]
      *],

      //  II.  Attempt to do conversion:
      ^VarDecl[* @dimCompIter,	 Iterator *],
      ^VarDecl[* @dimCompStruct, CompositeDimensionsBasicDimStruct *],
      ^VarDecl[* @basicDim,	 ConventionallyFundamentalDimension *],
      ^VarDecl[* @power,	 Number *],
      ^VarDecl[* @chunkedConversion,	UnitsToUnitsStruct *],
      ^VarDecl[* @unitsBasicUnitIter,	Iterator *],
      ^VarDecl[* @basicOriginalUnit,	Units *],
      ^VarDecl[* @basicRequestedUnit,	Units *],
      ^VarDecl[* @currentBasicUnitStruct,CompositeUnitsBasicUnitStruct *],
      ^VarDecl[* @currentBasicUnits,	Units *],

      //  II.A.  Create an initial 'null' conversion to modify into the
      //	 conversion we want:
      @chunkedConversion
	:=  ^^LinearUnitsToUnitsStruct
	    [*
	      @originalUnits,
	      @requestedUnits,
	      1,
	      0
	    *],

      //  II.B.  Attempt to convert each fundamental dimension of '@dimension'
      //	 individually:
      //  II.B.1.  Each iteration attempts to convert the units of one
      //	   fundamental dimension of '@dimension' from those given in
      //	   '@originalUnits' to those specified in '@requestedUnits':
      ^For
      [*
	@dimCompIter :=
	    @dimension->
		localProp_iter(compositeDimensionsBasicDimensionCompositionA),

       !@dimCompIter->iter_isAtEnd(),

	^Do
	[*[
	  //  II.B.1.a.  Get basic info on the current dimension
	  @dimCompStruct:= @dimCompIter->iter_value(),
	  @basicDim	:=
	    @dimCompStruct->
		localGet(compositeDimensionsBasicDimStructsToDimensionA),
	  @power	:=
	    @dimCompStruct->
		localGet(compositeDimensionsBasicDimStructsPowerA),

	  //  II.B.1.b.  Get '@basicOriginalUnit' for current '@basicDim':
	  ^For
	  [*
	    @unitsBasicUnitIter	:=
	    	@originalUnits->localProp_iter(compositeUnitsBasicUnitA),

	   !@unitsBasicUnitIter->iter_isAtEnd(),

	    ^Do
	    [*[
	      @currentBasicUnitStruct	:= @unitsBasicUnitIter->iter_value(),
	      @currentBasicUnits	:=
	      	@currentBasicUnitStruct->
		    localGet(compositeUnitsBasicUnitStructsUnitA),

	      ^If
	      [*
		(@currentBasicUnits->get(unitsDimensionA) =ref @basicDim),
		^Break[**]
	      *]
	    ]*],

	    @unitsBasicUnitIter->iter_advance()
	  *],

	  ^If
	  [*
	    @unitsBasicUnitIter->iter_isAtEnd(),
	    ^Throw
	    [*
	      //  "@originalUnits does not have a compositeUnitsBasicUnitA for
	      //   @basicDim"
	    *],
	    @basicOriginalUnit	:= @currentBasicUnits
	  *],

	  //  II.B.1.c.  Get '@basicRequestedUnit' for current '@basicDim':
	  ^For
	  [*
	    @unitsBasicUnitIter	:=
	    	@requestedUnits->localProp_iter(compositeUnitsBasicUnitA),

	   !@unitsBasicUnitIter->iter_isAtEnd(),

	    ^Do
	    [*[
	      @currentBasicUnitStruct	:= @unitsBasicUnitIter->iter_value(),
	      @currentBasicUnits	:=
	      	@currentBasicUnitStruct->
		    localGet(compositeUnitsBasicUnitStructsUnitA),

	      ^If
	      [*
		(@currentBasicUnits->get(unitsDimensionA) =ref @basicDim),
		^Break[**]
	      *]
	    ]*],

	    @unitsBasicUnitIter->iter_advance()
	  *],

	  ^If
	  [*
	    @unitsBasicUnitIter->iter_isAtEnd(),
	    ^Throw
	    [*
	      //  "@requestedUnits does not have a compositeUnitsBasicUnitA for
	      //   @basicDim"
	    *],
	    @basicRequestedUnit	:= @currentBasicUnits
	  *],

	  //  II.B.1.d.  Convert from '@basicOriginalUnit' to
	  //  		 '@basicRequestedUnit' given power '@power':
	  //  II.B.1.d.I.  Only something to do if they are different unit:
	  ^If
	  [*
	    (@basicOriginalUnit !=ref @basicRequestedUnit),
	    ^Do
	    [*[
	      //  Code here that does conversion:
	      ^VarDecl[* @basicScale,	Number *],

	      @basicScale	:= 
			@this->numberConvertedToRequestedUnits
				(1,
				 @basicOriginalUnit,
				 @basicRequestedUnit,
				 @basicDim
				)
			**
			@power,

	      @chunkedConversion->assert
			(linearUnitsToUnitsStructsMultiplierA,
			 @chunkedConversion->
				localGet(linearUnitsToUnitsStructsMultiplierA)
			 *
			 @basicScale
			)
	    ]*]
	  *]

	]*],

	@dimCompIter->iter_advance()
      *],

      //  II.C.  If get here then have created '@chunkedConversion'.
      //  	 Finish it and store it:
      //  II.C.1.  Finish it:
      //  II.C.1.a.  Assign proper "to-units":
      @chunkedConversion->
		assert(linearUnitsToUnitsStructsToUnitsA,@requestedUnits),

      //  II.C.2.  Store it:
      ^VarDecl[* @conversionMap, Map *],

      @conversionMap	:= Units->localGet(unitsClassesPairToConversionMapA),
      @conversionMap->
		map_put(^^SingleDistinctPair[*@originalUnits,@requestedUnits*],
			@chunkedConversion
		       ),

      //  III.  Finished:
      ^Return[* @chunkedConversion->forwardConvert(@originalNumber) *]
    ]*]
  *];
  //  numberConvertedToRequestedCompositeUnits

*};


final
piAnnotated
{*
  instanceOf->assert(AnnotatedValue);
  annotatedValuesTypeA->assert(FloatingPt);
  annotatedValuesValueA->assert(pi);
  valuesDomainA->assert(nonNegativeDimensionlessDomain);
*};

thisSE
{*
  spEnvsWarningGeneratingSemanticDomainClassA->
		assertZ(DomainsRangeDefinitionLimitA);
*};
/? --- end of file --- ?/

/? --- end of file --- ?/


thisSE->parseFile("knowledgebases/standard/genAgreed.som8");
EmpiricalEntity
{*
  isA->assertZ(Idea);
*};


//  PURPOSE:  To represent the degree of detail for which the greater
//	Scienceomatic environment ought to try to answer a query.
ComplexityLevel
{*
  isA->assertZ(ProgramObject);
*};

simpleComplexityLevel
{*
  instanceOf->assertZ(ComplexityLevel);
*};

intermediateComplexityLevel
{*
  instanceOf->assertZ(ComplexityLevel);
*};

detailedComplexityLevel
{*
  instanceOf->assertZ(ComplexityLevel);
*};


//  PURPOSE:  To represent the class of different ways of computing some
//	value of scientific interest.
ComputationalApproach
{*
  isA->assertZ(CulturalConvention);
*};

//  PURPOSE:  To represent the computational approach of reasoning from only
//	definitions, assumptions and expected knowledge.
givenComputation	{* instanceOf->assertZ(ComputationalApproach); *};

//  PURPOSE:  To represent the computational approach of reasoning from first
//	only definitions, assumptions and expected knowledge, and then from
//	theoretical knowledge.
abInitioComputation	{* instanceOf->assertZ(ComputationalApproach); *};

//  PURPOSE:  To represent the computational approach of reasoning from 
//	definitions/assumptions/expected knowledge, stored theory
//	generalizations, and data in that order.
theorizeComputation	{* instanceOf->assertZ(ComputationalApproach); *};

//  PURPOSE:  To represent the computational approach of reasoning from first
//	only definitions, assumptions and expected knowledge, and then from
//	data knowledge.
readDataComputation	{* instanceOf->assertZ(ComputationalApproach); *};

//  PURPOSE:  To represent the computational approach of reasoning from
//	definitions/assumptions/expected knowledge, data, generalizations,
//	and stored theory in that order.
empiricizeComputation	{* instanceOf->assertZ(ComputationalApproach); *};

//  PURPOSE:  To represent the computational approach of reasoning from
//	definitions/assumptions/expected knowledge, stored theory and
//	generalizations in that order for the primary query, and via
//	'theorizeComputation' for subqueries.
forcedTheorizeComputation
			{* instanceOf->assertZ(ComputationalApproach); *};


//  PURPOSE:  To represent a set of choices about which subset of scientific
//	knowledge is actively believed.  Can be taken to be roughly equivalent
//	to Kuhnian "paradigms".
ScientificWorldview
{*
  isA->assertZ(CulturalConvention);
*};

//  PURPOSE:  To represent the ScientificWorldview of science shared by the
//	majority of comtemporary scientists.
contemporaryGeneralScientificWorldview
{*
  instanceOf->assertZ(ScientificWorldview);
*};



//  PURPOSE:  To represent the class of queries to the greater Scienceomatic
//	environment.
Query
{*
  isA->assertZ(ProgramObject);
*};

//  PURPOSE:  To represent the class of attribute with specific domain Query.
QueryA
{*
  isA->assertZ(ProgramObjectA);
*};

//  PURPOSE:  To map from 'ProceduralQuery' instances to the predicate
//	expressions to try to match.
proceduralQuerysPredExprA
{*
  instanceOf->assertZ(QueryA);
*};

//  PURPOSE:  To map from 'ProceduralQuery' instances to the
//	ProceduralKnowledge instances in which to search for Pattern instances
//	to that match the predicate expression.
proceduralQuerysKnowledgeA
{*
  instanceOf->assertZ(QueryA);
*};


//  PURPOSE:  To represent the class of queries of procedural knowledge.
ProceduralQuery
{*
  isA->assertZ(Query);

  ideasImplicitConstructorA->
    subAssert
	(^ImplicitConstructor
	    [* [ [proceduralQuerysPredExprA,  PredicateExpression],
	         [proceduralQuerysKnowledgeA, ProceduralKnowledge]
	       ]
	    *]
	);
*};

PhysicsA
{*
  isA->assertZ(EmpiricalEntityA);
*};

Substance
{*
  isA->assertZ(EmpiricalEntity);
*};


PhysicalField
{*
  isA->assertZ(EmpiricalEntity);
*};


PhysicalObjectCollection
{*
  isA->assertZ(EmpiricalEntity);
*};


PhysicalObject
{*
  isA->assertZ(PhysicalObjectCollection);
*};


TimePassage
{*
  isA->assertZ(EmpiricalEntity);
*};


Process
{*
  isA->assertZ(TimePassage);
*};


ProcessNetworkProcess
{*
  isA->assertZ(Process);
*};


descriptionA
{*
  instanceOf->assertZ(CulturalConventionA);
*};


subProcessA
{*
  instanceOf->assertZ(EmpiricalEntityA);
*};

superProcessA
{*
  instanceOf->assertZ(EmpiricalEntityA);
*};


Evolution
{*
  isA->assertZ(Process);
  instanceOf->assertZ(ProcessNetworkProcess);

  descriptionA->assertZ("The process network process of the processes\n* speciation,\n* genetic drift,\n* extinction\nas they manipulate a population of species.");
  subProcessA->assertZ(Speciation);
  subProcessA->assertZ(GeneticDrift);
  subProcessA->assertZ(Extinction);
*};


Speciation
{*
  isA->assertZ(Process);

  superProcessA->assertZ(Evolution);
  descriptionA->assertZ("Speciation is the primary process by which species are created. (Another is abiogenesis, but this may not have more than once on Earth.)");
*};


GeneticDrift
{*
  isA->assertZ(Process);

  superProcessA->assertZ(Evolution);
  descriptionA->assertZ("Genetic drift is the process of how successive generations of a population assume different allele distributions from a given parent generation.  This may be due to selective pressures, or by 'random' factors (especially in small populations)");
*};


Extinction
{*
  isA->assertZ(Process);

  superProcessA->assertZ(Evolution);
  descriptionA->assertZ("Extinction is the complete die-off of a given population.");
*};


AdaptiveRadiation
{*
  isA->assertZ(Evolution);
*};



/?

graphiteS
{*
  isA->subAssert(mineralS);

  crystalSystem->subAssert(hexagonal);

  color->subAssert(black);

  form->subAssert(hexagonalPlates);

  hardness->subAssert(1);

  streak->subAssertZ(black);
  streak->subAssertZ(steelGray);

  transparency->subAssert(opaque);

  density->subAssert(3);
*};
?/


BasicParticle
{*
  isA->assertZ(PhysicalObject);
*};

Boson
{*
  isA->assertZ(BasicParticle);
*};

Photon
{*
  isA->assertZ(Boson);
  ^DiffDimensionalUnitConversionA
		[*waveNumberA,inverseDistance,frequencyA,inverseTime*]->
  assert(^DiffDimensionalUnitConversionStruct
		[* wavenumbers,
		   hertz,
		   29979245800 /? * ToConvert ?/,
		   [einsteinianWorldView]
		*]
	);
*};

photon0
{*
  instanceOf->assertZ(Photon);
  waveNumberA->assert(100.0[*defaultWavenumbersDomain*]);
*};

photon1
{*
  instanceOf->assertZ(Photon);
  frequencyA->assert(100[*defaultGhzDomain*]);
*};

Fermion
{*
  isA->assertZ(BasicParticle);
*};


AstronomicalObject
{*
  isA->assertZ(EmpiricalEntity);
*};

BlackHole
{*
  isA->assertZ(AstronomicalObject);
*};

NeutronStar
{*
  isA->assertZ(AstronomicalObject);
*};

WhiteDwarf
{*
  isA->assertZ(AstronomicalObject);
*};

Star
{*
  isA->assertZ(AstronomicalObject);
*};

Planet
{*
  isA->assertZ(AstronomicalObject);
*};

  mercury
  {*
    instanceOf->assert(Planet);
  *};

  venus
  {*
    instanceOf->assert(Planet);
  *};

  earth
  {*
    instanceOf->assert(Planet);
  *};

  mars
  {*
    instanceOf->assert(Planet);
  *};

  jupiter
  {*
    instanceOf->assert(Planet);
  *};

  saturn
  {*
    instanceOf->assert(Planet);
  *};

  uranus
  {*
    instanceOf->assert(Planet);
  *};

  neptune
  {*
    instanceOf->assert(Planet);
  *};

Planetoid
{*
  isA->assertZ(AstronomicalObject);
*};

Moon
{*
  isA->assertZ(AstronomicalObject);
*};

Asteroid
{*
  isA->assertZ(AstronomicalObject);
*};

Comet
{*
  isA->assertZ(AstronomicalObject);
*};

LivingObject
{*
  isA->assertZ(PhysicalObject);
*};

Scientist
{*
  isA->assertZ(PhysicalObject);
  isA->assertZ(KnowledgeGeneratingActor);
*};



//  PURPOSE:  To represent procedural knowledge about how to solve problems.
ProceduralKnowledge
{*
  isA->assertZ(EmpiricalEntity);
*};

//  PURPOSE:  To represent the class of attribute with specific domain
//	ProceduralKnowledge.
ProceduralKnowledgeA
{*
  isA->assertZ(EmpiricalEntityA);

  attrsDomainA->subAssertZ(ProceduralKnowledge);
*};

//  PURPOSE:  To map from 'ProceduralKnowledge' instance to the 'Pattern'
//	instances they have to answer queries.
procKnowPatStructPatA
{*
  instanceOf->assert(ProceduralKnowledgeA);
*};

//  PURPOSE:  To be the first ProceduralKnowledge instance used to answer
//	ProceduralQuery instances.  The design-philosophy of this particular
//	ProceduralKnowledge instance is not to answer queries itself but try
//	to identify another ProceduralKnowledge instance more specifically
//	tailored to answer that particular query.
rootProceduralKnowledge
{*
  instanceOf->assertZ(ProceduralKnowledge);

  procKnowPatStructPatA->
    assertA
	(
	  [ ?compute
	    ( ^InClassQuant[* @subj, EmpiricalEntity *],
	      ^InClassQuant[* @attr, PhysicsA *],
	      ^SpecValQuant[* simpleComplexityLevel *],
	      ^SpecValQuant[* contemporaryGeneralScientificWorldview *],
	      ^InClassQuant[* @how, ComputationalApproach *],
	      ^SpecValQuant
	      [* 
		^^ProceduralQuery
		[*  ?compute
		    ( @subj,
		      @attr,
		      simpleComplexityLevel,
		      contemporaryGeneralScientificWorldview,
		      @how,
		      ^InClassQuant[* @ans, Idea *]
		    ),
		    simpleContemporaryPhysicsProceduralKnowledge
		*]
	      *]
	    )
	    :-
	    [ ]
	  ]
	);
*};


//  PURPOSE:  To represent the 'ProceduralKnowledge' instance that attempts to
//	answer queries using simple contemporary physics.
simpleContemporaryPhysicsProceduralKnowledge
{*
  instanceOf->assertZ(ProceduralKnowledge);
*};
/? --- end of file --- ?/


thisSE->parseFile("knowledgebases/standard/local.som8");
jupiterMass {* instanceOf->assertZ(Units); *};
Reference {* isA->assertZ(EmpiricalEntity); *};
minMassA {* instanceOf->assertZ(EmpiricalEntityA); *};
urlA {* instanceOf->assertZ(CulturalConventionA); *};
`HD 142 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.306);*};
`WASP-44 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.888);*};
`WASP-32 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(3.541);*};
`HD 1237 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(3.375);*};
`WASP-26 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.009);*};
`HD 1461 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.024);*};
`HD 1502 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(3.089);*};
`WASP-1 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.828);*};
`WASP-45 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.002);*};
`HD 1690 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(6.191);*};
`HD 2039 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(5.925);*};
`HIP 2247 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(5.123);*};
`HD 2638 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.477);*};
`HAT-P-19 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.292);*};
`HAT-P-16 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.195);*};
`HD 3651 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.229);*};
`HD 4113 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.648);*};
`HD 4208 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.807);*};
`HD 4308 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.048);*};
`HD 4203 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.082);*};
`HD 4313 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.348);*};
`HD 4732 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.377);*};
`HD 4732 c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.365);*};
`HAT-P-28 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.627);*};
`HD 5319 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.938);*};
`HD 5388 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.965);*};
`HD 5891 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(6.779);*};
`HD 6434 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.397);*};
`HIP 5158 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.426);*};
`HD 6718 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.559);*};
`HD 7199 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.295);*};
`HD 7449 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.313);*};
`HD 7924 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.029);*};
`HD 8535 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.682);*};
`HD 8574 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.806);*};
`HD 9446 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.699);*};
`HD 9446 c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.815);*};
`upsilon And d`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.116);*};
`upsilon And b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.669);*};
`upsilon And c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.919);*};
`WASP-18 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(10.064);*};
`HD 10180 c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.042);*};
`HD 10180 h`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.206);*};
`HD 10180 g`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.067);*};
`HD 10180 f`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.074);*};
`HD 10180 e`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.08);*};
`HD 10180 d`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.038);*};
`HD 10180 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.004);*};
`HD 10647 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.925);*};
`HD 10697 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(6.235);*};
`HD 11506 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.735);*};
`HD 11977 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(6.52);*};
`HD 11964 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.618);*};
`HD 11964 c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.078);*};
`HAT-P-32 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.951);*};
`HD 12661 c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.949);*};
`HD 12661 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.341);*};
`alpha Ari b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.86);*};
`HD 13189 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(14.771);*};
`GJ 86 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.001);*};
`HAT-P-29 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.778);*};
`HD 13931 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.881);*};
`HAT-P-38 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.267);*};
`WASP-33 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.0);*};
`WASP-77 A b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.12);*};
`HD 16141 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.25);*};
`30 Ari B b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(9.878);*};
`HD 16417 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.067);*};
`HD 16175 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.379);*};
`81 Cet b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(5.341);*};
`HD 16760 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(13.292);*};
`iota Hor b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.047);*};
`BD +48 738 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.922);*};
`HD 17092 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.962);*};
`HIP 12961 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.354);*};
`HD 17156 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.3);*};
`WASP-50 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.464);*};
`HD 18742 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.719);*};
`WASP-11 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.54);*};
`HIP 14810 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.874);*};
`HIP 14810 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.275);*};
`HIP 14810 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.581);*};
`HD 19994 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.327);*};
`HAT-P-25 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.567);*};
`HD 20794 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.015);*};
`HD 20794 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.008);*};
`HD 20794 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.007);*};
`HD 20782 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.764);*};
`HD 20868 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.009);*};
`WASP-22 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.559);*};
`epsilon Eri b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.054);*};
`HD 23127 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.405);*};
`HD 23079 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.443);*};
`HD 22781 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(13.84);*};
`HD 23596 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.743);*};
`HD 24040 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.836);*};
`HD 25171 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.956);*};
`WASP-78 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.878);*};
`epsilon Ret b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.548);*};
`HD 27894 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.618);*};
`XO-3 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(13.055);*};
`HD 28254 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.161);*};
`HAT-P-15 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.951);*};
`WASP-79 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.885);*};
`HD 28185 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.797);*};
`epsilon Tau b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.62);*};
`HD 28678 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.714);*};
`2M 044144 b`{*  instanceOf->assertZ(Planet);
*};
`HD 30177 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(9.688);*};
`GJ 176 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.026);*};
`HD 30562 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.333);*};
`HD 30856 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.848);*};
`GJ 179 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.824);*};
`HD 31253 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.501);*};
`WASP-61 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.055);*};
`WASP-35 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.717);*};
`HD 33142 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.329);*};
`HD 33283 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.33);*};
`HD 32518 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.345);*};
`HD 33636 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(9.27);*};
`HD 34445 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.791);*};
`HD 33564 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(9.128);*};
`HD 290327 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.548);*};
`HD 38283 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.338);*};
`HD 37124 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.648);*};
`HD 37124 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.674);*};
`HD 37124 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.687);*};
`HD 39091 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(10.088);*};
`HD 37605 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.366);*};
`HD 37605 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.802);*};
`HD 38529 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(13.08);*};
`HD 38529 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.857);*};
`HD 38801 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(10.76);*};
`WASP-62 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.562);*};
`HD 40307 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.028);*};
`HD 40307 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.013);*};
`HD 40307 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.021);*};
`HD 41004 B b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(18.414);*};
`WASP-49 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.377);*};
`HD 40979 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.022);*};
`KELT-2 A b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.52);*};
`HD 43197 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.597);*};
`WASP-63 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.378);*};
`AB Pic b`{*  instanceOf->assertZ(Planet);
*};
`HD 43691 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.497);*};
`HD 44219 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.589);*};
`HD 45364 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.187);*};
`HD 45364 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.659);*};
`CoRoT-19 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.107);*};
`HD 45350 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.836);*};
`HD 45652 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.468);*};
`WASP-12 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.349);*};
`6 Lyn b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.209);*};
`CoRoT-18 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.48);*};
`HD 46375 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.227);*};
`HD 47186 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.348);*};
`HD 47186 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.071);*};
`7 CMa b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.645);*};
`HD 48265 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.206);*};
`CoRoT-12 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.916);*};
`CoRoT-7 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.016);*};
`WASP-23 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.872);*};
`CoRoT-5 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.461);*};
`CoRoT-1 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.026);*};
`CoRoT-4 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.717);*};
`CoRoT-13 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.31);*};
`HD 49674 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.102);*};
`HD 50499 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.745);*};
`CoRoT-14 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.568);*};
`HD 50554 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.399);*};
`HD 52265 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.071);*};
`HAT-P-24 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.686);*};
`HAT-P-9 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.775);*};
`HAT-P-20 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.278);*};
`HAT-P-33 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.765);*};
`HD 60532 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.463);*};
`HD 60532 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.035);*};
`HAT-P-39 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.598);*};
`NGC 2423 3 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(10.637);*};
`HD 63454 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.385);*};
`beta Gem b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.687);*};
`XO-5 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.151);*};
`HD 63765 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.644);*};
`XO-2 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.566);*};
`HD 65216 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.216);*};
`GJ 3470 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`HD 66428 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.75);*};
`GJ 3483 b`{*  instanceOf->assertZ(Planet);
*};
`HAT-P-35 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.053);*};
`HAT-P-30 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.707);*};
`HD 68988 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.8);*};
`HD 69830 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.032);*};
`HD 69830 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.056);*};
`HD 69830 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.037);*};
`HD 70642 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.909);*};
`HD 72659 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.174);*};
`HD 73267 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.063);*};
`HD 73256 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.869);*};
`HD 73526 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.856);*};
`HD 73526 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.421);*};
`HD 73534 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.104);*};
`HAT-P-13 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.851);*};
`HAT-P-13 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(14.27);*};
`4 UMa b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.132);*};
`GJ 317 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.175);*};
`HD 74156 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.773);*};
`HD 74156 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(8.247);*};
`WASP-36 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.255);*};
`HD 75289 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.46);*};
`55 Cnc b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.801);*};
`55 Cnc c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.165);*};
`55 Cnc d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.545);*};
`55 Cnc e`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.026);*};
`55 Cnc f`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.173);*};
`HD 75898 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.515);*};
`HD 76700 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.232);*};
`HD 79498 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.346);*};
`WASP-13 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.478);*};
`HD 80606 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.89);*};
`HD 81040 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.877);*};
`HD 81688 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.691);*};
`HD 82943 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.734);*};
`HD 82943 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.989);*};
`HD 82886 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.305);*};
`HD 83443 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.396);*};
`HD 85390 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.132);*};
`HD 85512 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.011);*};
`WASP-19 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.114);*};
`HD 86081 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.496);*};
`HD 86264 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.627);*};
`BD -08 2823 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.328);*};
`BD -08 2823 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.046);*};
`HD 87883 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.756);*};
`HD 88133 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.299);*};
`BD +20 2457 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(22.673);*};
`BD +20 2457 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(13.174);*};
`HD 89307 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.791);*};
`WASP-43 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.761);*};
`gamma Leo A b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(8.818);*};
`HD 89744 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(8.472);*};
`HAT-P-22 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.148);*};
`24 Sex c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.362);*};
`24 Sex b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.648);*};
`HD 90156 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.057);*};
`WASP-66 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.308);*};
`OGLE-TR-211 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.753);*};
`HD 92788 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.564);*};
`HD 93083 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.368);*};
`OGLE-TR-132 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.169);*};
`OGLE-TR-113 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.255);*};
`OGLE-TR-111 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.548);*};
`BD -10 3166 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.43);*};
`GJ 3634 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.022);*};
`HD 95089 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.236);*};
`47 UMa c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.546);*};
`47 UMa b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.546);*};
`WASP-34 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.581);*};
`CT Cha b`{*  instanceOf->assertZ(Planet);
*};
`HD 96063 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.92);*};
`HD 96167 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.685);*};
`HD 96127 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.007);*};
`OGLE2-TR-L9 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.502);*};
`OGLE-TR-182 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.022);*};
`HD 97658 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.024);*};
`WASP-31 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.477);*};
`HD 98219 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.834);*};
`HD 99109 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.504);*};
`HAT-P-21 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.073);*};
`HD 99492 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.106);*};
`HD 99706 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.403);*};
`HD 100655 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.672);*};
`GJ 433 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.018);*};
`HD 100777 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.165);*};
`HIP 57050 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.298);*};
`HATS-1 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.86);*};
`GJ 436 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.073);*};
`HD 101930 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.299);*};
`HIP 57274 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.529);*};
`HIP 57274 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.41);*};
`HIP 57274 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.037);*};
`HD 102117 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.17);*};
`HD 102195 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.453);*};
`HD 102272 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.913);*};
`HD 102365 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.051);*};
`HD 102329 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.866);*};
`HD 102956 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.951);*};
`HD 103197 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.098);*};
`HD 104067 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.186);*};
`HD 104985 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.551);*};
`2M 1207 b`{*  instanceOf->assertZ(Planet);
*};
`HD 106252 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.959);*};
`HD 106270 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(11.031);*};
`HD 107148 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.212);*};
`11 Com b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(19.434);*};
`NGC 4349 127 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(19.83);*};
`HD 108147 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.258);*};
`HD 108863 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.558);*};
`HD 108874 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.29);*};
`HD 108874 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.028);*};
`HD 109246 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.768);*};
`HAT-P-36 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.835);*};
`HD 109749 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.275);*};
`WASP-41 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.932);*};
`HD 111232 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.842);*};
`WASP-42 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.497);*};
`Ross 458AB c`{*  instanceOf->assertZ(Planet);
*};
`WASP-25 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.578);*};
`HD 114386 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.364);*};
`HD 114762 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(11.635);*};
`HD 114783 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.105);*};
`HD 114729 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.945);*};
`61 Vir b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.016);*};
`61 Vir c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.033);*};
`61 Vir d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.072);*};
`HD 116029 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.14);*};
`70 Vir b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.461);*};
`HD 117207 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.819);*};
`HD 117618 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.177);*};
`HD 118203 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.136);*};
`WASP-55 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.571);*};
`HAT-P-3 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.595);*};
`tau Boo b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.167);*};
`Qatar-2 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.483);*};
`WASP-15 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.541);*};
`HD 121504 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.222);*};
`HAT-P-12 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.211);*};
`HAT-P-26 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.059);*};
`WASP-16 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.839);*};
`HD 125612 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.058);*};
`HD 125612 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.068);*};
`HD 125595 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.042);*};
`HD 126614 A b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.386);*};
`WASP-39 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.284);*};
`WASP-14 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.655);*};
`HD 128311 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.457);*};
`HD 128311 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.248);*};
`alpha Cen B b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.004);*};
`HD 130322 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.043);*};
`WASP-37 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.793);*};
`HAT-P-27 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.614);*};
`HD 131496 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.241);*};
`HD 132406 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.605);*};
`HD 132563 B b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.492);*};
`HD 131664 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(18.328);*};
`WASP-24 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.084);*};
`HD 134987 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.805);*};
`HD 134987 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.563);*};
`11 UMi b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(11.087);*};
`HD 136118 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(11.681);*};
`HD 136418 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.994);*};
`GJ 581 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.019);*};
`GJ 581 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.017);*};
`GJ 581 e`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.006);*};
`GJ 581 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.05);*};
`HAT-P-4 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.672);*};
`iota Dra b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(12.715);*};
`HD 137510 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(26.358);*};
`HD 139357 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(10.075);*};
`HD 137388 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.228);*};
`GQ Lup b`{*  instanceOf->assertZ(Planet);
*};
`HD 330075 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.624);*};
`kappa CrB b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.009);*};
`HD 141937 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(9.475);*};
`HD 142245 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.89);*};
`epsilon CrB b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.756);*};
`HD 142415 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.662);*};
`WASP-17 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.508);*};
`rho CrB b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.064);*};
`HD 143361 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.035);*};
`HD 143567 b`{*  instanceOf->assertZ(Planet);
*};
`XO-1 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.918);*};
`UScoCTIO 108 b`{*  instanceOf->assertZ(Planet);
*};
`1RXS160929 b`{*  instanceOf->assertZ(Planet);
*};
`HD 145457 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.972);*};
`HD 142022 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.468);*};
`14 Her b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.215);*};
`HD 145377 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.782);*};
`HIP 79431 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.113);*};
`WASP-38 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.689);*};
`HAT-P-2 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(8.856);*};
`GSC 06214-00210 b`{*  instanceOf->assertZ(Planet);
*};
`HD 147018 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.127);*};
`HD 147018 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(6.594);*};
`HD 147513 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.18);*};
`SR 12 AB c`{*  instanceOf->assertZ(Planet);
*};
`HD 148156 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.848);*};
`HD 148427 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.213);*};
`HD 149026 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.36);*};
`HD 150706 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.843);*};
`HD 149143 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.328);*};
`HD 152581 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.514);*};
`GJ 649 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.325);*};
`HD 154345 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.957);*};
`HD 153950 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.742);*};
`HAT-P-18 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.197);*};
`HD 155358 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.819);*};
`HD 155358 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.807);*};
`HD 154672 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.006);*};
`HD 154857 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.333);*};
`HD 156279 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(9.785);*};
`GJ 1214 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.02);*};
`HD 156668 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.013);*};
`GJ 667 C b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.017);*};
`GJ 667 C c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.013);*};
`HD 156411 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.737);*};
`HAT-P-14 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.222);*};
`HD 156846 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(11.008);*};
`HD 158038 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.794);*};
`GJ 674 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.035);*};
`GJ 676 A b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.897);*};
`HD 159868 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.107);*};
`HD 159868 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.73);*};
`mu Ara e`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.543);*};
`mu Ara b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.746);*};
`mu Ara c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.889);*};
`mu Ara d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.035);*};
`MOA-2009-BLG-266L b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-05-071L b`{*  instanceOf->assertZ(Planet);
*};
`HD 162020 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(15.214);*};
`MOA-bin-1L b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-TR-10 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.627);*};
`TrES-3 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.873);*};
`OGLE-2006-BLG-109L b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-2006-BLG-109L c`{*  instanceOf->assertZ(Planet);
*};
`TrES-4 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.913);*};
`HD 163607 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.769);*};
`HD 163607 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.292);*};
`MOA-2009-BLG-387L b`{*  instanceOf->assertZ(Planet);
*};
`MOA-2008-BLG-310L b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-05-390L b`{*  instanceOf->assertZ(Planet);
*};
`MOA-2011-BLG-293L b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-2007-BLG-368L b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-TR-56 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.354);*};
`HD 164509 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.48);*};
`HD 164922 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.358);*};
`HD 164604 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.688);*};
`OGLE235-MOA53 b`{*  instanceOf->assertZ(Planet);
*};
`OGLE-05-169L b`{*  instanceOf->assertZ(Planet);
*};
`MOA-2010-BLG-073L b`{*  instanceOf->assertZ(Planet);
*};
`MOA-2010-BLG-477L b`{*  instanceOf->assertZ(Planet);
*};
`HAT-P-31 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.166);*};
`MOA-2009-BLG-319L b`{*  instanceOf->assertZ(Planet);
*};
`MOA-2007-BLG-192L b`{*  instanceOf->assertZ(Planet);
*};
`MOA-2007-BLG-400L b`{*  instanceOf->assertZ(Planet);
*};
`HD 167042 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.697);*};
`HAT-P-5 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.054);*};
`WASP-58 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.89);*};
`HD 168443 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(17.386);*};
`HD 168443 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.697);*};
`HD 168746 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.245);*};
`42 Dra b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.732);*};
`HD 169830 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.889);*};
`HD 169830 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.064);*};
`HD 170469 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.669);*};
`HD 171028 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.962);*};
`CoRoT-16 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.536);*};
`WASP-3 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.004);*};
`HD 171238 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.609);*};
`CoRoT-17 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.459);*};
`CoRoT-23 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.077);*};
`CoRoT-11 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.331);*};
`CoRoT-9 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.844);*};
`HD 173416 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.718);*};
`CoRoT-6 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.953);*};
`Kepler-8 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.583);*};
`HD 175541 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.575);*};
`HAT-P-37 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.172);*};
`Kepler-26 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-26 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`HD 175167 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.778);*};
`Kepler-55 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-55 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-43 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.216);*};
`Kepler-30 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-30 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-30 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-9 d`{*  instanceOf->assertZ(Planet);
*};
`Kepler-9 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.249);*};
`Kepler-9 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.169);*};
`Kepler-4 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.077);*};
`Kepler-10 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-10 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.014);*};
`TrES-1 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.752);*};
`Kepler-12 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.432);*};
`HD 177830 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.532);*};
`Kepler-25 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-25 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-52 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-52 c`{*  instanceOf->assertZ(Planet);
*};
`TrES-2 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.193);*};
`Kepler-38 b`{*  instanceOf->assertZ(Planet);
*};
`KOI-13 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-59 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-59 b`{*  instanceOf->assertZ(Planet);
*};
`HD 178911 B b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(7.291);*};
`Kepler-21 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-20 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.027);*};
`Kepler-20 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.049);*};
`Kepler-20 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.024);*};
`Kepler-20 e`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-20 f`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-14 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(8.406);*};
`HD 179079 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.084);*};
`Kepler-50 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-50 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-7 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.437);*};
`HD 180314 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(22.626);*};
`HD 179949 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.902);*};
`Kepler-60 d`{*  instanceOf->assertZ(Planet);
*};
`Kepler-60 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-60 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-16 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.333);*};
`Kepler-33 e`{*  instanceOf->assertZ(Planet);
*};
`Kepler-33 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-33 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-33 d`{*  instanceOf->assertZ(Planet);
*};
`Kepler-33 f`{*  instanceOf->assertZ(Planet);
*};
`Kepler-22 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-46 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-46 b`{*  instanceOf->assertZ(Planet);
*};
`HD 180902 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.557);*};
`HD 181342 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.0);*};
`Kepler-24 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-24 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-19 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-53 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-53 c`{*  instanceOf->assertZ(Planet);
*};
`HD 181720 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.372);*};
`CoRoT-10 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.754);*};
`WASP-48 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.97);*};
`Kepler-36 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-36 c`{*  instanceOf->assertZ(Planet);
*};
`HD 181433 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.535);*};
`HD 181433 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.64);*};
`HD 181433 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.024);*};
`CoRoT-8 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.216);*};
`CoRoT-2 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.273);*};
`CoRoT-3 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(21.799);*};
`HD 183263 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.476);*};
`HD 183263 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.574);*};
`Kepler-28 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-28 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-42 d`{*  instanceOf->assertZ(Planet);
*};
`Kepler-42 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-42 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-27 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-27 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`HAT-P-7 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.779);*};
`Kepler-49 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-49 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-45 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.511);*};
`HD 231701 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.087);*};
`Kepler-57 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-57 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-56 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-56 c`{*  instanceOf->assertZ(Planet);
*};
`WTS-1 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-31 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-31 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-23 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-23 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`HD 185269 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.954);*};
`Kepler-35 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.127);*};
`Kepler-41 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.493);*};
`Kepler-54 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-54 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-47 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-47 c`{*  instanceOf->assertZ(Planet);
*};
`16 Cyg B b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.64);*};
`WASP-67 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.418);*};
`Kepler-15 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.662);*};
`Kepler-58 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-58 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-34 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.22);*};
`Kepler-51 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-51 c`{*  instanceOf->assertZ(Planet);
*};
`HD 187123 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.942);*};
`HD 187123 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.51);*};
`Kepler-40 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.177);*};
`Kepler-6 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.668);*};
`Kepler-39 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(18.177);*};
`Kepler-11 g`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-11 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.014);*};
`Kepler-11 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.042);*};
`Kepler-11 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.019);*};
`Kepler-11 e`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.026);*};
`Kepler-11 f`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.007);*};
`HAT-P-41 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.8);*};
`HD 187085 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.804);*};
`HAT-P-11 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.083);*};
`Kepler-32 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-32 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`HD 188015 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.47);*};
`Kepler-18 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.054);*};
`Kepler-18 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.022);*};
`Kepler-18 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.052);*};
`PH-1 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-29 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-29 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.0);*};
`Kepler-17 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.477);*};
`xi Aql b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.807);*};
`Kepler-48 b`{*  instanceOf->assertZ(Planet);
*};
`Kepler-48 c`{*  instanceOf->assertZ(Planet);
*};
`Kepler-5 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.112);*};
`Kepler-44 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.015);*};
`HD 189733 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.14);*};
`HD 190228 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(5.942);*};
`HD 190360 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.059);*};
`HD 190360 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.535);*};
`HD 190647 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.903);*};
`HAT-P-34 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.33);*};
`Qatar-1 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.083);*};
`HD 192263 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.639);*};
`HD 192310 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.074);*};
`GJ 785 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.068);*};
`HD 192699 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.397);*};
`TrES-5 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.77);*};
`HAT-P-23 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.088);*};
`HD 195019 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.58);*};
`WASP-2 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.905);*};
`HD 196050 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.843);*};
`HD 197037 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.807);*};
`HD 196885 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.944);*};
`WASP-7 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.919);*};
`18 Del b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(10.21);*};
`HD 200964 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.84);*};
`HD 200964 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.893);*};
`BD +14 4559 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.519);*};
`WASP-46 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.085);*};
`HD 202206 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.331);*};
`HD 202206 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(16.824);*};
`HD 204313 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.606);*};
`HD 204313 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(3.501);*};
`HD 204941 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.267);*};
`GJ 832 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.644);*};
`HD 205739 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.487);*};
`HAT-P-17 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.53);*};
`2M 2140+16 b`{*  instanceOf->assertZ(Planet);
*};
`HD 206610 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.226);*};
`HN Peg b`{*  instanceOf->assertZ(Planet);
*};
`HD 207832 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.564);*};
`HD 207832 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.73);*};
`HD 208527 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(10.014);*};
`HD 208487 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.512);*};
`HD 209458 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.689);*};
`WASP-47 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.136);*};
`HD 210277 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.273);*};
`GJ 849 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.831);*};
`HD 210702 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.965);*};
`HAT-P-40 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.62);*};
`HD 212771 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(2.252);*};
`HD 212301 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.396);*};
`HD 213240 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(4.532);*};
`HD 215497 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.328);*};
`HD 215497 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.021);*};
`HAT-P-8 b`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(1.292);*};
`GJ 876 c`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.612);*};
`GJ 876 d`{*  instanceOf->assertZ(Planet);
  minMassA->assertZ(0.018);*};
`GJ 876 e`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.039);*};
`GJ 876 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.947);*};
`tau Gru b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.215);*};
`HD 216437 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.168);*};
`HD 216770 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.647);*};
`51 Peg b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.461);*};
`HAT-P-1 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.531);*};
`HD 217107 c`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.615);*};
`HD 217107 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.401);*};
`HD 217786 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(13.187);*};
`HR 8799 e`{*  instanceOf->assertZ(Planet); *};
`HD 218566 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.213);*};
`WASP-21 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.3);*};
`HD 240210 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(7.289);*};
`WASP-6 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.521);*};
`WASP-52 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.456);*};
`HD 240237 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(5.319);*};
`WASP-10 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(3.19);*};
`WASP-59 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.859);*};
`HD 219828 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.062);*};
`HD 220074 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(11.188);*};
`HD 220773 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.45);*};
`14 And b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(4.684);*};
`HD 221287 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(3.115);*};
`WASP-4 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.223);*};
`HD 222155 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.026);*};
`HAT-P-6 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.056);*};
`gamma Cep b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.772);*};
`kappa And b`{*  instanceOf->assertZ(Planet); *};
`HD 222582 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(7.63);*};
`WASP-60 b`{*  instanceOf->assertZ(Planet); *};
`WASP-29 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.243);*};
`WASP-5 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.62);*};
`WASP-8 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(2.137);*};
`HD 224693 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(0.715);*};
`XO-4 b`{*  instanceOf->assertZ(Planet); minMassA->assertZ(1.602);*};

`Da Silva 2006 1117398606`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006A%26A...446..717D");*};
`Lendl 2012 288721724`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...544A..72L");*};
`Marcy 2005 -1691312663`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...619..570M");*};
`Rauer 2009 -208635629`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...506..281R");*};
`Fortney 2011 1490639592`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197....9F");*};
`Dumusque 2011 335657062`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...535A..55D");*};
`Joshi 2009 1685155610`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009MNRAS.392.1532J");*};
`Niedzielski 2008 1720843145`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...693..276N");*};
`Santos 2004 -32689664`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...426L..19S");*};
`Naef 2001 1021315095`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001A%26A...375L..27N");*};
`Maxted 2012 -670390904`{*instanceOf->assertZ(Reference); urlA->assertZ("http://arxiv.org/abs/1211.6033");*};
`Pal 2010 1598141597`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010MNRAS.401.2665P");*};
`Maxted 2010 -569822443`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010PASP..122.1465M");*};
`Johnson 2010 298362428`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...721L.153J");*};
`Alonso 2004 -660442401`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...613L.153A");*};
`Bouchy 2011 256811254`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...533A..83B");*};
`Cabrera 2010 729958728`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A&A...522A.110C");*};
`Lee 2006 1947127643`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...632..638V");*};
`Vogt 2010 1454919042`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...708.1366V");*};
`Udry 2002 389461183`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002A%26A...390..267U");*};
`O'Donovan 2006 1773284405`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...651L..61O");*};
`Hebrard 2013 671302693`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2013A%26A...549A.134H");*};
`Melo 2007 -1728983958`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...467..721M");*};
`Smalley 2010 -1614214001`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...520A..56S");*};
`Desert 2011 -1059343791`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197...14D");*};
`Sato 2008 1164705388`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008PASJ...60.1317S");*};
`Hartman 2011 964972090`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...742...59H");*};
`Udry 2006 1639624709`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006A%26A...447..361U");*};
`Correia 2008 -358034324`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...479..271C");*};
`Tinney 2001 1796542701`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001ApJ...551..507T");*};
`Johnson 2011 -1598207319`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197...26J");*};
`Wright 2009 1680932063`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...699L..97W");*};
`Omiya 2012 1002054430`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012PASJ...64...34O");*};
`Mandushev 2007 -1837326464`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...667L.195M");*};
`Carter 2003 -1523518621`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...593L..43C");*};
`Santos 2010 1808098108`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...512A..47S");*};
`Marcy 2002 1478572705`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...614L..81M");*};
`Diaz 2012 -1413469475`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...538A.113D");*};
`Marcy 2002 1051477511`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...581.1375M");*};
`Bonfils 2005 -723880278`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...443L..15B");*};
`Rivera 2010 -44856410`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...719..890R");*};
`Butler 1998 -1140929027`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1998PASP..110.1389B");*};
`Dollinger 2007 -1102513200`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...472..649D");*};
`Howard 2009 804964879`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...696...75H");*};
`Sato 2012 2045334996`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012PASJ...64...97S");*};
`Hellier 2009 -900904410`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009Natur.460.1098H");*};
`Desort 2008 1371999839`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...491..883D");*};
`Maness 2007 1328733856`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007PASP..119...90M");*};
`Howard 2010 2083640398`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...721.1467H");*};
`Faedi 2011 -1666454305`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...531A..40F");*};
`Marcy 2001 2051824059`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001ApJ...555..418M");*};
`Bakos 2011 -2102804265`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...742..116B");*};
`Anderson 2011 221764154`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011PASP..123..555A");*};
`Sozzetti 2006 1061581553`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006A%26A...449..417S");*};
`Triaud 2011 1799079722`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...531A..24T");*};
`Butler 2000 -1741662572`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000ApJ...545..504B");*};
`Fischer 2003 -747295268`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...590.1081F");*};
`Marcy 1996 -263790381`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1996ApJ...464L.147M");*};
`Kurster 2000 1025963856`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000A%26A...353L..33K");*};
`Latham 2010 188726810`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...713L.140L");*};
`Marcy 2000 85606510`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000ApJ...536L..43M");*};
`Fischer 2002 -1574150125`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002PASP..114..529F");*};
`Wright 2009 -141297598`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...657..533W");*};
`Santos 2001 -621418780`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001A%26A...379..999S");*};
`Howard 2011 1929096285`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...726...73H");*};
`Butler 2001 -632067039`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001ApJ...555..410B");*};
`Kipping 2010 1186024985`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...725.2017K");*};
`Hebrard 2010 891932328`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A&A...513A..69H");*};
`Harakawa 2010 977224028`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...715..550H");*};
`Pilyavsky 2011 -1413013449`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...743..162P");*};
`Frink 2002 -1592328497`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...576..478F");*};
`Fischer 2003 1684885050`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...586.1394F");*};
`Fressin 2011 1734301903`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197....5F");*};
`Tinney 2006 1059567163`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...647..594T");*};
`Wittenmyer 2009 1739968152`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJS..182...97W");*};
`Hellier 2009 1795372799`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...690L..89H");*};
`Fischer 2007 716843236`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...669.1336F");*};
`Delfosse 2012 -1199732931`{*instanceOf->assertZ(Reference); urlA->assertZ("http://arxiv.org/abs/1202.2467");*};
`Kipping 2011 -1017884072`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011AJ....142...95K");*};
`Buchhave 2011 -669132218`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...733..116B");*};
`Koch 2010 -1776209101`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...713L.131K");*};
`Dumusque 2012 1833355482`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012Natur.491..207D");*};
`Holman 2010 639286514`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010Sci...330...51H");*};
`Sanchis-Ojeda 2012 -697335947`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012Natur.487..449S");*};
`Johnson 2011 -1455069814`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011AJ....141...16J");*};
`Ballard 2011 28046096`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...743..200B");*};
`Wittenmeyer 2007 -58292870`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...654..625W");*};
`Wright 2009 241072862`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...693.1084W");*};
`Bakos 2007 -1920830523`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...670..826B");*};
`Vogt 2005 631934743`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...632..638V");*};
`Borucki 2012 -321493754`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...745..120B");*};
`Boisse 2010 155987909`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...523A..88B");*};
`Butler 2006 -169095853`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...646..505B");*};
`Bouchy 2004 -1623997704`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...421L..13B");*};
`Lister 2009 414861248`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...703..752L");*};
`Sato 2008 -1068384631`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008PASJ...60..539S");*};
`Marcy 2001 781503584`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001ApJ...556..296M");*};
`Correia 2009 -1548618535`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...496..521C");*};
`Lissauer 2011 -1112952467`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011Natur.470...53L");*};
`Sanchis-Ojeda 2012 -1326644331`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...750..114F");*};
`Hartman 2009 -1486849036`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...706..785H");*};
`Moutou 2005 -1150203803`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...439..367M");*};
`Lee 2011 680901437`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...529A.134L");*};
`Ge 2006 1967277801`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...648..683G");*};
`Hebb 2009 1123172324`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...693.1920H");*};
`Borde 2010 -1167493100`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...520A..66B");*};
`Barge 2008 -1525303899`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...482L..17B");*};
`Johnson 2010 1477748561`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010PASP..122..149J");*};
`Johnson 2008 -1512791206`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...675..784J");*};
`Triaud 2010 -1180394797`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...524A..25T");*};
`Ford 2012 -1155486489`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...750..113F");*};
`Pepe 2007 939050899`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...462..769P");*};
`Wang 2012 898344327`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...761...46W");*};
`Johnson 2007 -378679958`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...665..785J");*};
`Santerne 2011 1881245578`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...536A..70S");*};
`Eggenberger 2006 2014623265`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006A%26A...447.1159E");*};
`Segransan 2010 -85013262`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...511A..45S");*};
`Fischer 2006 ; da Silva 2006 1351037982`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...637.1094F ; http://adsabs.harvard.edu/abs/2006A%26A...446..717D");*};
`Carter 2011 154279757`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...730...82C");*};
`Sato 2008 ; Johnson 2008 -975964262`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008PASJ...60.1317S ; http://adsabs.harvard.edu/abs/2008ApJ...675..784J");*};
`Udry 2003 107278743`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003A%26A...407..679U");*};
`Gregory 2010 1458062996`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010MNRAS.403..731G");*};
`Fridlund 2010 -386619649`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...512A..14F");*};
`Desidera 2011 698875489`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...533A..90D");*};
`Sato 2008 -845444139`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=2008PASJ...60..539S");*};
`Wright 2011 -2038836269`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...730...93W");*};
`Wright 2007 868745752`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...657..533W");*};
`Torres 2010 1950918944`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...715..458T");*};
`Pont 2004 510414928`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...426L..15P");*};
`O'Toole 2009 -1953252744`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...697.1263O");*};
`Mandushev 2011 -1190738660`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...741..114M");*};
`Wittenmyer 2009 -1892250455`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003A%26A...410.1039P");*};
`Gillon 2010 772670125`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...520A..97G");*};
`Hellier 2011 -1919197161`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...730L..31H");*};
`Meschiari 2011 313966205`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...727..117M");*};
`Anderson 2010 -105168883`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...709..159A");*};
`Winn 2009 -180945724`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...703L..99W");*};
`Bonfils 2011 133139788`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...528A.111B");*};
`Liu 2008 972252862`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...672..553L");*};
`Udry 2007 461449332`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...469L..43U");*};
`Gillon 2011 165334749`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...533A..88G");*};
`Moutou 2009 -1398710291`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...496..513M");*};
`Gillon 2010 -726353986`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...511A...3G");*};
`Hartman 2011 311399957`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...726...52H");*};
`Liu 2009 -1481716023`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009RAA.....9....1L");*};
`Tripathi 2010 -114977718`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...715..421T");*};
`Latham 1989 1623604573`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1989Natur.339...38L");*};
`Moutou 2008 -511317202`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...488L..47M");*};
`Fischer 2012 -424419149`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...745...21F");*};
`Bonfils 2011 -1456933660`{*instanceOf->assertZ(Reference); urlA->assertZ("http://arxiv.org/pdf/1111.5019v2.pdf");*};
`Christian 2009 767805737`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009MNRAS.392.1585C");*};
`Kovacs 2007 -2097296445`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...670L..41K");*};
`Butler 1996 -1325919656`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1996ApJ...464L.153B");*};
`Sato 2013 1816838549`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2013ApJ...762....9S");*};
`Hatzes 2003 1675421108`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...599.1383H");*};
`Barbieri 2009 -2134261432`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...503..601B");*};
`Hartman 2012 14117115`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012AJ....144..139H");*};
`Bakos 2007 -119574021`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...671L.173B");*};
`Jones 2003 2063598804`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003MNRAS.341..948J");*};
`Butler 2002 817924205`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...578..565B");*};
`Deeg 2010 497649476`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010Natur.464..384D");*};
`Robert 2012 608875557`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...749...39R");*};
`Sozzetti 2009 1832796197`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...691.1145S");*};
`Fischer 2002 1623317220`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...564.1028F");*};
`Endl 2006 -1224225844`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006AJ....131.3131E");*};
`Gettel 2012 645434425`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...745...28G");*};
`Quinn 2012 -1332984430`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...745...80Q");*};
`Tinney 2002 1253972024`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...571..528T");*};
`Howard 2012 652550580`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...749..134H");*};
`Robertson 2012 469050850`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...749...39R");*};
`Bonfils 2011 689543920`{*instanceOf->assertZ(Reference); urlA->assertZ("http://arxiv.org/abs/1111.5019");*};
`Naef 2007 -1883475402`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...470..721N");*};
`Johnson 2009 -1587039561`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...692L.100J");*};
`Tinney 2003 133901721`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...587..423T");*};
`Udalski 2008 927813220`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...482..299U");*};
`Hebb 2010 -1196562373`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...708..224H");*};
`Sato 2010 -1874386796`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010PASJ...62.1063S");*};
`Maxted 2011 785086848`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011PASP..123..547M");*};
`Johns-Krull 2008 1568209667`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...677..657J");*};
`Naef 2004 640776283`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...414..351N");*};
`Burke 2007 -715389598`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...671.2115B");*};
`Dunham 2010 -728041999`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...713L.136D");*};
`Bakos 2007 -983320151`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...656..552B");*};
`Bakos 2009 -589975292`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...707..446B");*};
`Naef 2003 -1641610031`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003A%26A...410.1051N");*};
`Mayor 2004 -464179024`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002A%26A...390..267U");*};
`Pepe 2011 -39245027`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...534A..58P");*};
`Pont 2008 360110563`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...487..749P");*};
`Diaz 2011 -1130313225`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011EPJWC..1102006D");*};
`Simpson 2011 926384034`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011AJ....141....8S");*};
`Mayor 2009 399736909`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...493..639M");*};
`Borucki 2011 1310671533`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...736...19B");*};
`Wilson 2008 2144733407`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...675L.113W");*};
`Konacki 2004; Bouchy 2004 -848362339`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...609L..37K ; http://adsabs.harvard.edu/abs/2004A%26A...421L..13B");*};
`Queloz 2009 ; Leger 2009 951904970`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...506..303Q ; http://adsabs.harvard.edu/abs/2009A%26A...506..287L");*};
`Santerne 2011 -2088487865`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...528A..63S");*};
`Howell 2012 -1255795379`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...746..123H");*};
`Latham 2009 1951143322`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...704.1107L");*};
`Bouchy 2009 -546170814`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...496..527B");*};
`Rouan 2012 -857684322`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...537A..54R");*};
`Valenti 2009 -903109668`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...702..989V");*};
`Jones 2006 -2141341416`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006MNRAS.369..249J");*};
`Fabrycky 2012 -1121918282`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...750..114F");*};
`Forveille 2011 -2128620027`{*instanceOf->assertZ(Reference); urlA->assertZ("http://xxx.lanl.gov/abs/1109.2505");*};
`Naef 2010 -1900485734`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...523A..15N");*};
`Apps 2010 -221157432`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010PASP..122..156A");*};
`Skillen 2009 1004742245`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...502..391S");*};
`Johnson 2011 629781878`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...735...24J");*};
`Perrier 2003 -1836023129`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003A%26A...410.1039P");*};
`Vogt 2000 828373752`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000ApJ...536..902V");*};
`Naef 2001 -657018347`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001A%26A...375..205N");*};
`Campbell 1988 -1090635396`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1988ApJ...331..902C");*};
`Bonfils 2012 -994188364`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...546A..27B");*};
`Lee 2012 -648211877`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...546A...5L");*};
`Narita 2010 -340519560`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010PASJ...62L..61N");*};
`Alonso 2008 1074570521`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...482L..21A");*};
`Lovis 2011 -922539401`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...528A.112L");*};
`Guenther 2012 306608860`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...537A.136G");*};
`Santos 2000 -1727497623`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000A%26A...356..599S");*};
`Boisse 2012 -346027845`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...545A..55B");*};
`Maxted 2010 -555829643`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010AJ....140.2007M");*};
`Santos 2011 -1264843710`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...526A.112S");*};
`Kovacs 2010 -1099831866`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...724..866K");*};
`Hatzes 2006 -1123819525`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006A%26A...457..335H");*};
`Sato 2005 745753336`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...633..465S");*};
`Mordasini 2011 -116741594`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...526A.111M");*};
`Carter 2009 1052342157`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...696..241C");*};
`Queloz 2000 1632938834`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000A%26A...354...99Q");*};
`Bailey 2009 225512054`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...690..743B");*};
`Alsubai 2011 -1698570550`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011MNRAS.417..709A");*};
`Johnson 2012 -269940192`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012AJ....143..111J");*};
`Brogi 2012 -443540823`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012Natur.486..502B");*};
`Lovis 2006 -1206914057`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006Natur.441..305L");*};
`Moutou 2008 ; Aigrain 2008 -843736627`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...488L..47M ; http://adsabs.harvard.edu/abs/2008A%26A...488L..43A");*};
`Arriagada 2010 1804663586`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...711.1229A");*};
`Winn 2009 186586226`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...700..302W");*};
`Rivera 2005 -1235443546`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...634..625R");*};
`Hebrard 2011 -1227207570`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...533A.130H");*};
`Pepe 2007 ; Gozdiewski 2007 -1984405748`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...462..769P ; http://adsabs.harvard.edu/abs/2007ApJ...657..546G");*};
`Tinney 2011 -1610619756`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...727..103T");*};
`Maciejewski 2011 257965214`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...528A..65M");*};
`Forveille 2009 -643964275`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...493..645F");*};
`Lee 2006 -1637581108`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...641.1178L");*};
`Burke 2008 -1797352073`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...686.1331B");*};
`Sato 2003 -270790951`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...597L.157S");*};
`Pollacco 2008 1596581901`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008MNRAS.385.1576P");*};
`Robinson 2007 -604905032`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...670.1391R");*};
`Mayor 2004 -126876946`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...415..391M");*};
`Simpson 2011 1013572223`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011MNRAS.tmp..600S");*};
`Anderson 2011 340815640`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...531A..60A");*};
`Niedzielski 2009 755305508`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...707..768N");*};
`O'Donovan 2007 202785157`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...663L..37O");*};
`Henry 2000 ; Charbonneau 2000 -240546077`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000ApJ...529L..41H ; http://adsabs.harvard.edu/abs/2000ApJ...529L..45C");*};
`Hellier 2010 -1430163459`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...723L..60H");*};
`Segransan 2011 -916314546`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...535A..54S");*};
`Steffen 2012 -427402272`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012MNRAS.421.2342S");*};
`Csizmadia 2011 -16826631`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...531A..41C");*};
`Noyes 2008 -74198772`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...673L..79N");*};
`Niedzielski 2007 1130321269`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...669.1354N");*};
`Charbonneau 2009 -1068569080`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009Natur.462..891C");*};
`Sato 2007 -1298089812`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...661..527S");*};
`Wright 2008 -1082217735`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...683L..63W");*};
`Endl 2012 898904239`{*instanceOf->assertZ(Reference); urlA->assertZ("http://arxiv.org/abs/1208.5769");*};
`Giguere 2012 268440900`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...744....4G");*};
`Endl 2011 -2126096251`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197...13E");*};
`Hatzes 2005 803967947`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A&A...437..743H");*};
`Bonfils 2007 -1547750672`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...474..293B");*};
`West 2009 ; Bakos 2009 -54720009`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...502..395W ; http://adsabs.harvard.edu/abs/2009ApJ...696.1950B");*};
`Deleuil 2008 -999264469`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...491..889D");*};
`Endl 2012 267277892`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...759...19E");*};
`Wittenmyer 2011 1705524021`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...743..184W");*};
`Smalley 2012 -1608787116`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...547A..61S");*};
`Snellen 2009 1954006642`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...497..545S");*};
`Johnson 2010 2077463319`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010PASP..122..701J");*};
`West 2009 -726529127`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...502..395W");*};
`Fischer 2009 (corrected: priv. comm.) 1217818223`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...703.1545F");*};
`Bouchy 2010 731969577`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A&A...519A..98B");*};
`Anderson 2012 -548942432`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012MNRAS.422.1988A");*};
`Butler 2004 363577970`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...617..580B");*};
`Butler 2006 1121197874`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006PASP..118.1685B");*};
`Haghighipour 2010 -1828191411`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...715..271H");*};
`McArthur 2004 -487798674`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...614L..81M");*};
`Beatty 2012 150370062`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...756L..39B");*};
`Simpson 2011 1688227823`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011MNRAS.414.3023S");*};
`Lopez-Morales 2008 1925043521`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008AJ....136.1901L");*};
`Johnson 2006 2036125858`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...652.1724J");*};
`Collier-Cameron 2007 -998006565`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007MNRAS.375..951C");*};
`Cochran 2011 -540896008`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197....7C");*};
`Bonomo 2012 517309539`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...538A..96B");*};
`O'Toole 2007 -1899548144`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...660.1636O");*};
`Gautier 2012 504265258`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...749...15G");*};
`Cochran 2004 -904945324`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...611L.133C");*};
`Mayor 1995 1711949791`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1995Natur.378..355M");*};
`Penev 2013 -94079451`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2013AJ....145....5P");*};
`Santos 2008 -1215115575`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...487..369S");*};
`Correia 2005 -408602679`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...440..751C");*};
`Fischer 2001 -1310755648`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2001ApJ...551.1107F");*};
`Bouchy 2005 -632972883`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...444L..15B");*};
`Fischer 2006 1947984120`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...637.1094F");*};
`Butler 2003 846381682`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003ApJ...582..455B");*};
`Hellier 2011 468292945`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...535L...7H");*};
`Korzennik 2000 940109919`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000ApJ...533L.147K");*};
`Noyes 1997 -750133612`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1997ApJ...483L.111N");*};
`Mayor 2009 -445431912`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...507..487M");*};
`Jones 2002 151557648`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002MNRAS.333..871J");*};
`Johnson 2006 -82716438`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...647..600J");*};
`Hatzes 2000 -1298384561`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000ApJ...544L.145H");*};
`Endl 2004 -61613608`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...611.1121E");*};
`Mayor 2004 879120561`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...440..751C");*};
`Fischer 2008 -1400042220`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...675..790F");*};
`Zucker 2002 487316332`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...568..363Z");*};
`Jenkins 2010 -1774874501`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...724.1108J");*};
`Bakos 2010 1612077866`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...710.1724B");*};
`Torres 2007 1668186790`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...666L.121T");*};
`Setiawan 2005 542510238`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...437L..31S");*};
`McCullough 2006 800221038`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006ApJ...648.1228M");*};
`Lee 2013 -1927771907`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2013A%26A...549A...2L");*};
`Smith 2012 2119210435`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012AJ....143...81S");*};
`Pepe 2002 -918094341`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002A%26A...388..632P");*};
`Pal 2008 1193913765`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...680.1450P");*};
`Anderson 2008 793073566`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008MNRAS.387L...4A");*};
`Cochran 1997 -1824037292`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1997ApJ...483..457C");*};
`Kane 2011 1394725755`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...737...58K");*};
`Lo Curto 2010 -10199802`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...512A..48L");*};
`Wright 2009 942987122`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...632..638V");*};
`Hebrard 2010 782326201`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...512A..46H");*};
`Borucki 2010 365658427`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...713L.126B");*};
`Hatzes 1993 -418745955`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1993ApJ...413..339H");*};
`Winn 2010 -424112239`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...718..575W");*};
`Tingley 2011 1233138462`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...528A..97T");*};
`Peek 2009 1425533273`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009PASP..121..613P");*};
`Zucker 2004 -703157197`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...426..695Z");*};
`Jones 2010 -1487019903`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010MNRAS.403.1703J");*};
`Enoch 2011 -1730946291`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011AJ....142...86E");*};
`Marcy 1999 -2087176156`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1999ApJ...520..239M");*};
`McCarthy 2004 1484312694`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004ApJ...617..575M");*};
`Street 2010 -1197381949`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...720..337S");*};
`Jones 2002 -2052595149`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002MNRAS.337.1170J");*};
`Butler 1999 -1238229706`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1999ApJ...526..916B");*};
`Fressin 2012 -1642157614`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012Natur.482..195F");*};
`Lo Curto 2006 613698921`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006A%26A...451..345L");*};
`Konacki 2003 967475967`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2003Natur.421..507K");*};
`Forveille 2011 -568042876`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...526A.141F");*};
`Santos 2007 -1060533980`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...474..647S");*};
`Rivera 2010 -253134651`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...708.1492R");*};
`Hartman 2011 -1257913642`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...728..138H");*};
`Barros 2011 167321149`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A&A...525A..54B");*};
`Konacki 2005 -1435517427`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...624..372K");*};
`Johnson 2007 1384123364`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...670..833J");*};
`Kane 2011 -826703503`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...735L..41K");*};
`Shporer 2009 -592564857`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...690.1393S");*};
`Tinney 2011 -457181338`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...732...31T");*};
`Smalley 2011 1500249568`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...526A.130S");*};
`Sato 2009 -529212801`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...703..671S");*};
`Dollinger 2009 856495630`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...505.1311D");*};
`Dollinger 2009 -1535290189`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...499..935D");*};
`Enoch 2011 238620928`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011MNRAS.410.1631E");*};
`Lovis 2007 1816785043`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A&A...472..657L");*};
`Buchhave 2010 403107107`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...720.1118B");*};
`Fischer 2005 -632290279`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...620..481F");*};
`Vogt 2002 -1791946546`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2002ApJ...568..352V");*};
`Wittenmyer 2012 -1209712545`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...753..169W");*};
`Da Silva 2007 -1454494739`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007A%26A...473..323D");*};
`Gillon 2009 1017513039`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...501..785G");*};
`Gandolfi 2010 1522527249`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A&A...524A..55G");*};
`Torres 2008 -1204280544`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008ApJ...677.1324T");*};
`Han 2010 2001088560`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...509A..24H");*};
`Haghighipour 2012 -608184960`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...756...91H");*};
`Howard 2011 -1871791881`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...730...10H");*};
`Bowler 2010 766642140`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010ApJ...709..396B");*};
`Welsh 2012 880225120`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012Natur.481..475W");*};
`Guenther 2009 -171071963`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...507.1659G");*};
`Bryan 2012 -385882092`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...750...84B");*};
`Minniti 2009 308412774`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...693.1424M");*};
`Galland 2005 -1474255151`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...444L..21G");*};
`Tamuz 2008 1702011159`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2008A%26A...480L..33T");*};
`Batalha 2011 1359114802`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJ...729...27B");*};
`Collier-Cameron 2010 1389433708`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010MNRAS.407..507C");*};
`Lovis 2005 1467502150`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005A%26A...437.1121L");*};
`Delfosse 1998 ; Marcy 1998 505820748`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1998A%26A...338L..67D ; http://adsabs.harvard.edu/abs/1998ApJ...505L.147M");*};
`Doyle 2011 -1029992377`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011Sci...333.1602D");*};
`Moutou 2011 -221029029`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011A%26A...527A..63M");*};
`Bucchave 2011 2144143291`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2011ApJS..197....3B");*};
`Fischer 2009 -618162975`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009ApJ...703.1545F");*};
`Tinney 2005 331489435`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2005ApJ...623.1171T");*};
`Ollivier 2012 -231194125`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012A%26A...541A.149O");*};
`Pepe 2004 865801492`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2004A%26A...423..385P");*};
`Udry 2000 980427330`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2000A%26A...356..590U");*};
`Bakos 2012 1639337997`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012AJ....144...19B");*};
`Queloz 2009 402269081`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...506..303Q");*};
`Christian 2006 -416028860`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2006MNRAS.372.1117C");*};
`West 2009 344527391`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009AJ....137.4834W");*};
`Fischer 1999 1386040915`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1999PASP..111...50F");*};
`Moutou 2009 -595751499`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2009A%26A...498L...5M");*};
`Lo Curto 2010 (corrected: priv. comm.) -1687462870`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...512A..48L");*};
`Cochran 2007 -1590524660`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2007ApJ...665.1407C");*};
`Hellier 2012 -19034118`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012MNRAS.426..739H");*};
`Robertson 2012 -1814768607`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2012ApJ...754...50R");*};
`Butler 1997 188628857`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/1997ApJ...474L.115B");*};
`Bonomo 2010 -1247835631`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A&A...520A..65B");*};
`Queloz 2010 -1188977538`{*instanceOf->assertZ(Reference); urlA->assertZ("http://adsabs.harvard.edu/abs/2010A%26A...517L...1Q");*};
/? --- end of file --- ?/


thisSE->parseFile("knowledgebases/standard/personal.som8");
solarSystemsStarA
{*
  instanceOf->assertZ(StructuralA);
*};

CelestialSystem
{*
  isA->assertZ(PhysicalObjectCollection);
*};


SolarSystem
{*
  isA->assertZ(CelestialSystem);

  ideasImplicitConstructorA->
     subAssert(^ImplicitConstructor
		[* [ [solarSystemsStarA,Star]
	           ]
		*]
	     );
*};


Galaxy
{*
  isA->assertZ(CelestialSystem);
*};

CelestialObject
{*
  isA->assertZ(PhysicalObject);
*};


Star
{*
  isA->assertZ(CelestialObject);
*};

Planet
{*
  isA->assertZ(CelestialObject);
*};

Moon
{*
  isA->assertZ(CelestialObject);
*};

solarSystem
{*
  instanceOf->assertZ(SolarSystem);

  solarSystemsStarA->assertZ
	   (sun	{* instanceOf->assertZ(Star);
  	   	 *}
	   );
	   
*};

`Corot 7`
{*
  instanceOf->assertZ(Star);
*};

gj1214
{*
  instanceOf->assertZ(Star);
*};

`Kepler 10`
{*
  instanceOf->assertZ(Star);
*};

muAra
{*
  instanceOf->assertZ(Star);
*};

`Wasp 18`
{*
  instanceOf->assertZ(Star);
*};

`Wasp 19`
{*
  instanceOf->assertZ(Star);
*};
/? --- end of file --- ?/
